<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Provas - SAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
        /* Ajustes de layout */
        .container-full {
            width: 100%;
            max-width: 100%;
            padding-left: 0;
            padding-right: 0;
        }
        .modal-overflow {
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ajusta layout em dispositivos móveis */
        @media (max-width: 768px) {
            .mobile-padding {
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    
    <!-- Success Modal -->
    <div
      id="successModal"
      class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
    >
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4">
            <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-medium text-gray-900" id="successModalTitle">
            Operação Concluída
          </h3>
          <button
            id="closeSuccessModal"
            class="text-gray-400 hover:text-gray-500"
          >
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mb-6 text-center">
                <div class="text-green-500 text-4xl mb-4">
                    <i class="fas fa-check-circle"></i>
                </div>
          <p class="text-gray-700" id="successModalMessage">
            Operação realizada com sucesso!
          </p>
            </div>
            <div class="flex justify-center">
          <button
            id="successModalOkBtn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
                    OK
                </button>
            </div>
        </div>
    </div>
    <!-- Modal -->
<div id="modalProva" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 overflow-y-auto h-full w-full">
  <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <!-- Cabeçalho -->
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-2xl font-bold text-gray-800">Questões da Prova</h3>
      <button onclick="fecharModal()" class="text-gray-500 hover:text-gray-700">&times;</button>
    </div>
    
    <!-- Conteúdo das questões -->
    <div id="questoesContainer" class="space-y-4 max-h-96 overflow-y-auto">
      <!-- As questões serão inseridas aqui via JavaScript -->
    </div>
    
    <!-- Loading -->
    <div id="loading" class="text-center py-4 hidden">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
    </div>
  </div>
</div>
<script>
    function visualizarProva(provaId) {    console.log("ID da prova visualizada:", provaId);    const modal = document.getElementById('modalProva');    const loading = document.getElementById('loading');    const questoesContainer = document.getElementById('questoesContainer');        modal.classList.remove('hidden');    loading.classList.remove('hidden');    questoesContainer.innerHTML = '';        fetch(`https://sag-sag.rak8a3.easypanel.host/api/provas/${provaId}/questoes-detalhadas`)      .then(response => response.json())      .then(data => {        if (data.questoes && data.questoes.length > 0) {          questoesContainer.innerHTML = data.questoes.map((questao, index) => `            <div class="p-4 border rounded-lg">              <h4 class="font-semibold mb-2">Questão ${index + 1}</h4>              <p class="text-gray-600 mb-3">${questao.enunciado}</p>              <ul class="space-y-2">                ${questao.alternativas.map(alt => `                  <li class="${alt.correta ? 'bg-green-100 border-l-4 border-green-500' : ''} p-2 rounded">                    ${alt.texto}                  </li>                `).join('')}              </ul>            </div>          `).join('');
        } else {
          questoesContainer.innerHTML = '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
        }
      })
      .catch(error => {
        console.error('Erro:', error);
        questoesContainer.innerHTML = '<p class="text-center text-red-500">Erro ao carregar questões</p>';
      })
      .finally(() => {
        loading.classList.add('hidden');
      });
  }
  
  function fecharModal() {
    document.getElementById('modalProva').classList.add('hidden');
  }
  
  // Fechar modal ao clicar fora
  window.onclick = function(event) {
    const modal = document.getElementById('modalProva');
    if (event.target === modal) {
      fecharModal();
    }
  }
  </script>
    <script src="js/app.js"></script>
    <script src="js/alert.js"></script>
    <script>
        // Global variables para gerenciamento de habilidades BNCC
        let selectedSkills = [];
        let activeInputElement = null;

        // Base de dados de habilidades BNCC
        const bnccDatabase = {
        Português: {
          PRIMEIRO_ANO: [
            {
              code: "EF01LP01",
              description:
                "Reconhecer que textos são lidos e escritos da esquerda para a direita e de cima para baixo da página.",
            },
            {
              code: "EF01LP02",
              description:
                "Escrever, espontaneamente ou por ditado, palavras e frases de forma alfabética – usando letras/grafemas que representem fonemas.",
            },
            {
              code: "EF01LP03",
              description:
                "Observar escritas convencionais, comparando-as às suas produções escritas, percebendo semelhanças e diferenças.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02LP01",
              description:
                "Utilizar, ao produzir o texto, grafia correta de palavras conhecidas ou com estruturas silábicas já dominadas, letras maiúsculas em início de frases e em substantivos próprios, segmentação entre as palavras, ponto final, ponto de interrogação e ponto de exclamação.",
            },
            {
              code: "EF02LP02",
              description:
                "Segmentar palavras em sílabas e remover e substituir sílabas iniciais, mediais ou finais para criar novas palavras.",
            },
            {
              code: "EF02LP03",
              description:
                "Ler e escrever palavras com correspondências regulares diretas entre letras e fonemas (f, v, t, d, p, b) e correspondências regulares contextuais (c e q; e e o, em posição átona em final de palavra).",
            },
          ],
        },
        Matemática: {
          PRIMEIRO_ANO: [
            {
              code: "EF01MA01",
              description:
                "Utilizar números naturais como indicador de quantidade ou de ordem em diferentes situações cotidianas e reconhecer situações em que os números não indicam contagem nem ordem, mas sim código de identificação.",
            },
            {
              code: "EF01MA02",
              description:
                "Contar de maneira exata ou aproximada, utilizando diferentes estratégias como o pareamento e outros agrupamentos.",
            },
            {
              code: "EF01MA03",
              description:
                'Estimar e comparar quantidades de objetos de dois conjuntos (em torno de 20 elementos), por estimativa e/ou por correspondência (um a um, dois a dois) para indicar "tem mais", "tem menos" ou "tem a mesma quantidade".',
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02MA01",
              description:
                "Comparar e ordenar números naturais (até a ordem de centenas) pela compreensão de características do sistema de numeração decimal (valor posicional e função do zero).",
            },
            {
              code: "EF02MA02",
              description:
                "Fazer estimativas por meio de estratégias diversas a respeito da quantidade de objetos de coleções e registrar o resultado da contagem desses objetos (até 1000 unidades).",
            },
            {
              code: "EF02MA03",
              description:
                'Comparar quantidades de objetos de dois conjuntos, por estimativa e/ou por correspondência (um a um, dois a dois, entre outros), para indicar "tem mais", "tem menos" ou "tem a mesma quantidade", indicando, quando for o caso, quantos a mais e quantos a menos.',
            },
          ],
        },
        Ciências: {
          PRIMEIRO_ANO: [
            {
              code: "EF01CI01",
              description:
                "Comparar características de diferentes materiais presentes em objetos de uso cotidiano.",
            },
            {
              code: "EF01CI02",
              description:
                "Localizar, nomear e representar graficamente (por meio de desenhos) partes do corpo humano e explicar suas funções.",
            },
            {
              code: "EF01CI03",
              description:
                "Discutir as razões pelas quais os hábitos de higiene do corpo são necessários para a manutenção da saúde.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02CI01",
              description:
                "Identificar de que materiais (metais, madeira, vidro etc.) são feitos os objetos que fazem parte da vida cotidiana.",
            },
            {
              code: "EF02CI02",
              description:
                "Propor o uso de diferentes materiais para a construção de objetos de uso cotidiano.",
            },
            {
              code: "EF02CI03",
              description:
                "Discutir os cuidados necessários à prevenção de acidentes domésticos.",
            },
          ],
        },
      };

      document.addEventListener("DOMContentLoaded", function () {
            // Mobile menu toggle
        const mobileMenuBtn = document.getElementById("mobileMenuBtn");
        const mobileMenu = document.getElementById("mobileMenu");
            
            if (mobileMenuBtn && mobileMenu) {
          mobileMenuBtn.addEventListener("click", function () {
            mobileMenu.classList.toggle("hidden");
                });
            }
            
            // Atualizar nome do usuário
        const currentUser = JSON.parse(sessionStorage.getItem("currentUser"));
            if (currentUser) {
          document.getElementById("userName").textContent = currentUser.name;
            }
            
            // Inicializar localStorage para exams se não existir
        if (!localStorage.getItem("exams")) {
          localStorage.setItem("exams", JSON.stringify([]));
            }
            
            // Verificar se é modo de edição
            const urlParams = new URLSearchParams(window.location.search);
        const editExamId = urlParams.get("edit");
            
            if (editExamId) {
                openExamForEditing(parseInt(editExamId));
            }
            
            // Buscar provas da API
            loadExamsFromAPI();
            
            // Adicionar eventos para botões principais
            setupMainButtons();
            
            // Carregar componentes curriculares da API
            loadCurriculumComponentsFromAPI();
            
            // Configurar modal BNCC
        const closeBnccModalBtn = document.getElementById("closeBnccModal");
        const cancelBnccBtn = document.getElementById("cancelBnccBtn");
        const confirmBnccBtn = document.getElementById("confirmBnccBtn");
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const deselectAllBtn = document.getElementById("deselectAllBtn");
        const newSelectBnccBtn = document.getElementById("newSelectBnccBtn");

        if (closeBnccModalBtn)
          closeBnccModalBtn.addEventListener("click", closeBnccModal);
        if (cancelBnccBtn)
          cancelBnccBtn.addEventListener("click", closeBnccModal);
        if (confirmBnccBtn)
          confirmBnccBtn.addEventListener("click", confirmBnccSelection);
        if (bnccComponent)
          bnccComponent.addEventListener("change", updateBnccSkillsList);
        if (bnccGrade)
          bnccGrade.addEventListener("change", updateBnccSkillsList);
        if (bnccSearch) bnccSearch.addEventListener("input", filterBnccSkills);
        if (selectAllBtn)
          selectAllBtn.addEventListener("click", selectAllSkills);
        if (deselectAllBtn)
          deselectAllBtn.addEventListener("click", deselectAllSkills);
        if (newSelectBnccBtn)
          newSelectBnccBtn.addEventListener("click", openBnccSelector);
            
            // Configurar eventos para seletores BNCC em questões existentes
        document.querySelectorAll(".select-bncc-btn").forEach((btn) => {
          btn.addEventListener("click", openBnccSelector);
            });
            
            // Configurar uploads de imagem
            setupImageUploads();
            
            // Configurar botões adicionais para criar prova
        const addAnotherQuestionBtn = document.getElementById(
          "addAnotherQuestionBtn"
        );
            if (addAnotherQuestionBtn) {
          addAnotherQuestionBtn.addEventListener("click", addAnotherQuestion);
            }
            
        const finalizeExamBtnModal = document.getElementById(
          "finalizeExamBtnModal"
        );
            if (finalizeExamBtnModal) {
          finalizeExamBtnModal.addEventListener("click", finalizeExam);
            }
        });
        
        // Variáveis globais para o fluxo de criação de prova
        let currentExamData = {
        name: "",
        description: "",
        questions: [],
        };
        
        function setupMainButtons() {
            // Botão Criar Avaliação
        const createExamBtn = document.getElementById("createExamBtn");
            if (createExamBtn) {
          console.log("Adicionando evento de click ao botão Criar Avaliação");
          createExamBtn.addEventListener("click", function () {
            console.log("Botão Criar Avaliação clicado");
                    // Limpar dados da prova atual
                    currentExamData = {
              name: "",
              description: "",
              questions: [],
            };
            document
              .getElementById("createExamStepOneModal")
              .classList.remove("hidden");
                });
            }
            
            // Botão Vincular Prova
        const linkExamBtn = document.getElementById("linkExamBtn");
            if (linkExamBtn) {
          linkExamBtn.addEventListener("click", async function () {
            document.getElementById("linkExamModal").classList.remove("hidden");
                    
                    try {
                        // Configurar opções de série e turno
                        setupGradeAndShiftOptions();
                        
                        // Utilizar a função populateExamSelector para buscar provas da API
                        await populateExamSelector();
                        
                        // Utilizar a função populateSchoolSelector para buscar escolas da API
                        await populateSchoolSelector();
                    } catch (error) {
              console.error(
                "Erro ao preparar formulário de vinculação:",
                error
              );
              alert("Erro ao carregar dados para vinculação: " + error.message);
                    }
                });
            }
            
            // Botão Exportar Todas
        const exportAllExamsBtn = document.getElementById("exportAllExamsBtn");
            if (exportAllExamsBtn) {
          exportAllExamsBtn.addEventListener("click", exportAllExams);
            }
            
            // Botão Banco de Questões
        const questionBankBtn = document.getElementById("questionBankBtn");
            if (questionBankBtn) {
          questionBankBtn.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.remove("hidden");
                    loadQuestionBank();
                });
            }
            
            // Botão para adicionar questão no formulário principal
        const addQuestionBtn = document.getElementById("addQuestionBtn");
            if (addQuestionBtn) {
          addQuestionBtn.addEventListener("click", function () {
                    // Adicionar lógica para adicionar uma nova questão ao formulário
            alert(
              "Funcionalidade para adicionar questão no formulário principal"
            );
                });
            }
            
            // Botão de fechar o modal de examModal
        const closeExamModal = document.getElementById("closeExamModal");
            if (closeExamModal) {
          closeExamModal.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botão para cancelar adição de exame
        const cancelExamBtn = document.getElementById("cancelExamBtn");
            if (cancelExamBtn) {
          cancelExamBtn.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botões de fechamento de modais
            setupModalCloseButtons();
            
            // Configurar formulários
            setupFormSubmissions();
        }
        
        // Função para configurar opções de série e turno
        function setupGradeAndShiftOptions() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        function setupModalCloseButtons() {
            // Modal Criar Avaliação - Etapa 1
        document
          .getElementById("closeCreateExamStepOneModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelCreateExamStepOneBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
            });
            
            // Modal Adicionar Questão
        document
          .getElementById("closeAddQuestionModal")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
          });

        document
          .getElementById("cancelAddQuestionBtn")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
            });
            
            // Modal Opções de Questão
        document
          .getElementById("closeQuestionOptionsModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionOptionsModal")
              .classList.add("hidden");
            });
            
            // Modal Banco de Questões
        document
          .getElementById("closeQuestionBankModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelQuestionBankBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
            });
            
            // Modal Vincular Prova
        document
          .getElementById("closeLinkExamModal")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
          });

        document
          .getElementById("cancelLinkBtn")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
            });
        }
        
        function setupFormSubmissions() {
            // Formulário Etapa 1 - Informações Básicas
        const createExamStepOneForm = document.getElementById(
          "createExamStepOneForm"
        );
            if (createExamStepOneForm) {
          createExamStepOneForm.addEventListener("submit", function (e) {
                    e.preventDefault();
                    
                    // Obter dados do formulário
            const examName = document.getElementById("newExamName").value;
            const examDescription =
              document.getElementById("newExamDescription").value;
            const examEducationLevel = document.getElementById(
              "newExamEducationLevel"
            ).value;
                    
                    if (!examName) {
              alert("Por favor, insira um nome para a prova.");
                        return;
                    }
                    
                    if (!examEducationLevel) {
              alert("Por favor, selecione um nível de ensino.");
                        return;
                    }
                    
                    // Verificar se é edição ou criação
                    const isEditing = currentExamData.id !== undefined;
                    
                    // Atualizar dados da prova
                    currentExamData.name = examName;
                    currentExamData.description = examDescription;
                    currentExamData.educationLevel = examEducationLevel;
                    
            console.log(
              `${isEditing ? "Editando" : "Criando"} prova:`,
              currentExamData
            );
                    
                    // Se for edição, atualizar a prova no armazenamento
                    if (isEditing) {
              updateExam(currentExamData).then((success) => {
                            if (success) {
                                // Fechar modal
                  document
                    .getElementById("createExamStepOneModal")
                    .classList.add("hidden");
                                
                                // Atualizar lista de provas
                                loadExamsFromAPI();
                                
                                // Mostrar modal de sucesso
                  showSuccessModal(
                    "Avaliação Atualizada",
                    "A avaliação foi atualizada com sucesso!"
                  );
                            } else {
                  alert("Erro ao atualizar avaliação.");
                            }
                        });
                    } else {
                        // Processar para a próxima etapa (criação de nova prova)
              document
                .getElementById("createExamStepOneModal")
                .classList.add("hidden");
              document
                .getElementById("addQuestionModal")
                .classList.remove("hidden");
              document.getElementById("questionNumber").textContent = "1";
                        
                        // Limpar formulário de questão
              document.getElementById("addQuestionForm").reset();
                        
                        // Limpar preview de imagem se existir
              const imagePreview = document.querySelector(
                "#addQuestionModal .image-preview"
              );
                        if (imagePreview) {
                imagePreview.classList.add("hidden");
                const img = imagePreview.querySelector("img");
                if (img) img.src = "";
                        }
                    }
                });
            }
            
            // Formulário Adicionar Questão
        const addQuestionForm = document.getElementById("addQuestionForm");
            if (addQuestionForm) {
          addQuestionForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            if (!document.getElementById("questionText").value) {
              alert("Por favor, insira o texto da questão.");
                        return;
                    }
                    
            if (
              !document.querySelector('input[name="correctAnswer"]:checked')
            ) {
              alert("Por favor, selecione a alternativa correta.");
                        return;
                    }

                    try {
                        // Obter o texto da questão
              const enunciado = document.getElementById("questionText").value;
                        
                        // Obter valor de imagem (se existir)
              const fileInput = document.querySelector("#questionImage");
              const imagePreview = document.querySelector("#addQuestionModal .image-preview");
              const imagem_url = fileInput && fileInput.files[0] ? fileInput.files[0].name : "";
            
              console.log("Caminho da imagem a ser enviada:", imagem_url);
                        
                        // Obter o nível de ensino (usar valor direto da API)
              const nivel_ensino = document.getElementById("educationLevel").value;
                        
                        // Obter série
              const serie = document.getElementById("gradeLevel").value;
                        
                        // Obter dificuldade
              const dificuldade =
                document.getElementById("difficultyLevel").value;
                        
                        // Obter componente curricular ID (deve ser um número)
              const componente_curricular_id = parseInt(
                document.getElementById("curriculumComponent").value,
                10
              );
                        
                        // Processar códigos BNCC (devem ser um array de números)
              const bnccCodesInput = document.getElementById("bnccCodes");
              let codigos_bncc = [];

              if (bnccCodesInput && bnccCodesInput.value) {
                  try {
                      codigos_bncc = JSON.parse(bnccCodesInput.value);
                  } catch (e) {
                      console.warn("Erro ao processar códigos BNCC:", e);
                  }
              }
                        
                        // Obter a resposta correta
              const correctAnswer = document.querySelector(
                'input[name="correctAnswer"]:checked'
              ).value;
                        
                        // Criar array de alternativas
                        const alternativas = [];
                        
                        // Adicionar cada alternativa ao array (apenas se tiver texto)
              const optionA = document.getElementById("optionA").value.trim();
                        if (optionA) {
                            alternativas.push({
                                texto: optionA,
                  correta: correctAnswer === "A",
                            });
                        }
                        
              const optionB = document.getElementById("optionB").value.trim();
                        if (optionB) {
                            alternativas.push({
                                texto: optionB,
                  correta: correctAnswer === "B",
                            });
                        }
                        
              const optionC = document.getElementById("optionC").value.trim();
                        if (optionC) {
                            alternativas.push({
                                texto: optionC,
                  correta: correctAnswer === "C",
                            });
                        }
                        
              const optionD = document.getElementById("optionD").value.trim();
                        if (optionD) {
                            alternativas.push({
                                texto: optionD,
                  correta: correctAnswer === "D",
                            });
                        }
                        
                        // Obter ID da prova atual
              const prova_id = parseInt(currentExamData.apiId, 10);
                        
                        // Validar que temos um ID válido antes de prosseguir
                        if (isNaN(prova_id) || prova_id <= 0) {
                throw new Error(
                    "ID da prova é inválido ou não foi criado. Salve a prova primeiro."
                );
                        }
                        
                        // Construir o objeto da questão exatamente no formato solicitado
                        const questionData = {
                            enunciado,
                            imagem_url,
                            nivel_ensino,
                            dificuldade,
                            serie,
                            pontos: 1,
                            prova_id,
                            componente_curricular_id,
                            codigos_bncc,
                            alternativas,
                        };
                        
              console.log(
                "Enviando questão para API:",
                JSON.stringify(questionData, null, 2)
              );
                        
                        // Enviar a requisição para o endpoint
              const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
              const response = await fetch(`${baseUrl}/api/questoes`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(questionData),
            });
                        
                        if (!response.ok) {
                const errorText = await response
                  .text()
                  .catch(() => "Erro desconhecido");
                throw new Error(
                  `Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`
                );
                        }
                        
                        const savedQuestion = await response.json();
              console.log("Questão salva com sucesso:", savedQuestion);
                        
                        // Capturar dados da questão para o formato local (para histórico)
                        const questionDataLocal = {
                            text: enunciado,
                            educationLevel: nivel_ensino,
                            gradeLevel: serie,
                            difficultyLevel: dificuldade,
                            curriculumComponent: componente_curricular_id.toString(),
                            bnccCodes: codigos_bncc,
                            correctAnswer: correctAnswer,
                            options: {
                                A: optionA || '',
                                B: optionB || '',
                                C: optionC || '',
                                D: optionD || ''
                            },
                            alternativas: alternativas.map(alt => ({
                                letra: alt.letra || "",
                                texto: alt.texto || "",
                                correta: (alt.letra || "").toUpperCase() === correctAnswer.toUpperCase()
                            })),
                            image: imagem_url,
                            apiId: savedQuestion.id,
                        };
                        
                        // Log para debug
                        console.log("Questão adicionada com alternativas:", JSON.stringify(questionDataLocal.options, null, 2));
                        
                        // Adicionar a questão à lista de questões
                        currentExamData.questions.push(questionDataLocal);
              console.log("Questão adicionada localmente:", questionDataLocal);
              console.log(
                `Total de questões: ${currentExamData.questions.length}`
              );
              console.log(
                `IMPORTANTE: Questão salva com ID da API: ${questionDataLocal.apiId}`
              );
              console.log("Estado atual das questões:");
                        currentExamData.questions.forEach((q, idx) => {
                console.log(
                  `  Questão ${idx + 1}: "${q.text.substring(
                    0,
                    30
                  )}..." - ID API: ${q.apiId || "não tem"}`
                );
                        });
                        
                        // Processar para a próxima etapa
              document
                .getElementById("addQuestionModal")
                .classList.add("hidden");
              document
                .getElementById("questionOptionsModal")
                .classList.remove("hidden");
              document.getElementById("totalQuestionsCount").textContent =
                currentExamData.questions.length;
                    } catch (error) {
              console.error("Erro ao salvar questão:", error);
                        alert(`Erro ao salvar questão: ${error.message}`);
                    }
                });
            }
            
            // Formulário Vincular Prova
        const linkExamForm = document.getElementById("linkExamForm");
            if (linkExamForm) {
          linkExamForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            const examId = document.getElementById("examSelect").value;
            const schoolId = document.getElementById("linkSchool").value;
            const grade = document.getElementById("linkGrade").value;
            const classId = document.getElementById("linkClass").value;
            const shift = document.getElementById("linkShift").value;
                    
                    if (!examId || !schoolId || !grade || !classId || !shift) {
              alert("Por favor, preencha todos os campos.");
                        return;
                    }
                    
                    // Desabilitar botão de submit e mostrar indicador de carregamento
                    const submitBtn = this.querySelector('button[type="submit"]');
                    const originalBtnText = submitBtn.innerHTML;
            submitBtn.innerHTML =
              '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
                    submitBtn.disabled = true;
                    
                    try {
                        // Enviar dados para a API com a rota correta
                        const payload = {
                            prova_id: examId,
                turma_id: classId,
                        };
                        
              console.log("Enviando dados para vincular prova:", payload);
                        
                        // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
              const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                        
                        // Enviar para a API
                        const response = await fetch(url, {
                method: "POST",
                            headers: {
                  "Content-Type": "application/json",
                            },
                body: JSON.stringify(payload),
                        });
                        
                        if (!response.ok) {
                throw new Error(
                  `Erro ao vincular prova. Status: ${response.status}`
                );
                        }
                        
                        // Fechar modal e mostrar mensagem de sucesso
              document.getElementById("linkExamModal").classList.add("hidden");
              alert("Prova vinculada com sucesso!");
                        
                        // Recarregar provas
                        loadExamsFromAPI();
                    } catch (error) {
              console.error("Erro ao vincular prova:", error);
              alert("Erro ao vincular prova: " + error.message);
                    } finally {
                        // Restaurar botão
                        submitBtn.innerHTML = originalBtnText;
                        submitBtn.disabled = false;
                    }
                });
            }
            
            // Alteração de escola no modal de vinculação
        document
          .getElementById("linkSchool")
          ?.addEventListener("change", async function () {
                const schoolId = this.value;
                if (!schoolId) return;
                
                try {
                    // Mostrar indicador de carregamento
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Carregando turmas...</option>';
                        classSelect.disabled = true;
                    }
                    
                    // Buscar turmas da API
              const response = await fetch(
                `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
                {
                  method: "GET",
                        headers: {
                    "Content-Type": "application/json",
                  },
                        }
              );
                    
                    if (!response.ok) {
                throw new Error(
                  `Erro ao carregar turmas. Status: ${response.status}`
                );
                    }
                    
                    const classes = await response.json();
                    
                    // Limpar seletor
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Selecione uma turma</option>';
                        
                        // Adicionar cada turma ao seletor
                classes.forEach((cls) => {
                  const option = document.createElement("option");
                            option.value = cls.id;
                            option.textContent = cls.nome || `Turma ${cls.id}`;
                            classSelect.appendChild(option);
                        });
                        
                        // Se não há turmas, mostrar mensagem
                        if (classes.length === 0) {
                  classSelect.innerHTML =
                    '<option value="">Nenhuma turma encontrada</option>';
                        }
                        
                        classSelect.disabled = false;
                    }
                } catch (error) {
              console.error("Erro ao buscar turmas:", error);
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Erro ao carregar turmas</option>';
                        classSelect.disabled = false;
                    }
                }
            });
        }

        // Função para adicionar outra questão
        function addAnotherQuestion() {
        document.getElementById("questionOptionsModal").classList.add("hidden");
        document.getElementById("addQuestionModal").classList.remove("hidden");
            
            // Incrementar número da questão
        const currentNumber = parseInt(
          document.getElementById("questionNumber").textContent || "1"
        );
        document.getElementById("questionNumber").textContent =
          currentNumber + 1;
            
            // Limpar formulário
        document.getElementById("addQuestionForm")?.reset();
            
            // Limpar preview de imagem se existir
        const imagePreview = document.querySelector(
          "#addQuestionModal .image-preview"
        );
            if (imagePreview) {
          imagePreview.classList.add("hidden");
          const img = imagePreview.querySelector("img");
          if (img) img.src = "";
            }
        }
        
        // Função para finalizar a criação da prova
        async function finalizeExam() {
            if (currentExamData.questions.length === 0) {
          alert(
            "Adicione pelo menos uma questão antes de finalizar a avaliação."
          );
                return;
            }
            
            // Mostrar indicador de processamento
        const finalizeBtn = document.getElementById("finalizeExamBtnModal");
            const originalBtnText = finalizeBtn.innerHTML;
        finalizeBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
            finalizeBtn.disabled = true;
            
            try {
          console.log(
            "Iniciando processo de finalização da prova:",
            currentExamData.name
          );
          console.log(
            `Total de questões a serem salvas: ${currentExamData.questions.length}`
          );
                
                // Verificar se a prova já foi criada (tem apiId)
                if (!currentExamData.apiId) {
            console.log("Prova ainda não foi criada na API. Criando agora...");
                    
                    // Determinar o nível de ensino no formato correto para a API
                    let nivelEnsino = "FUNDAMENTAL_I"; // Valor padrão
                    if (currentExamData.educationLevel) {
              switch (currentExamData.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "FUNDAMENTAL_I";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "FUNDAMENTAL_II";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "MEDIO";
                                break;
                            default:
                                nivelEnsino = "FUNDAMENTAL_I";
                        }
                    }
                    
                    // Criar a prova com dados básicos
                    const examData = {
                        nome: currentExamData.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: currentExamData.description || "",
                        nivel_ensino: nivelEnsino,
                        data_aplicacao: new Date().toISOString(),
              arquivo_url: "", // Campo obrigatório
                    };
                    
            console.log(
              "Payload para criação da prova:",
              JSON.stringify(examData, null, 2)
            );
                    
                    // 1. Primeiro, criar a prova sem questões
            const provaResponse = await fetch(
              "https://sag-sag.rak8a3.easypanel.host/api/provas",
              {
                method: "POST",
                        headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                        },
                body: JSON.stringify(examData),
              }
            );
                    
                    if (!provaResponse.ok) {
              const errorText = await provaResponse
                .text()
                .catch(() => "Erro desconhecido");
              throw new Error(
                `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
              );
                    }
                    
                    // Obter a prova criada
                    const savedExam = await provaResponse.json();
            console.log("Prova criada com sucesso. ID:", savedExam.id);
                    
                    if (!savedExam.id) {
              throw new Error(
                "A prova foi criada, mas não recebeu um ID válido da API"
              );
                    }
                    
                    // Atualizar o ID da API no exame atual
                    currentExamData.apiId = savedExam.id;
                } else {
            console.log(
              "Prova já existe na API com ID:",
              currentExamData.apiId
            );
                }
                
                // 2. Adicionar a prova ao armazenamento local
          const newExam = addExam(
            currentExamData.name,
            [],
            currentExamData.description,
            currentExamData.educationLevel
          );
                newExam.apiId = currentExamData.apiId;
                updateLocalExam(newExam);
          console.log(
            "Prova adicionada ao armazenamento local com ID da API:",
            newExam.apiId
          );
                
                // 3. Adicionar cada questão individualmente usando o endpoint /api/questoes
                const savedQuestions = [];
                const failedQuestions = [];
                
          console.log(
            `Começando a adicionar ${currentExamData.questions.length} questões...`
          );
                for (let i = 0; i < currentExamData.questions.length; i++) {
                    try {
                        const question = currentExamData.questions[i];
                        
                        // CORREÇÃO: Verificar se a questão já tem um ID da API (já foi salva)
                        if (question.apiId) {
                console.log(
                  `Questão ${i + 1}/${
                    currentExamData.questions.length
                  } já foi salva anteriormente com ID: ${question.apiId}`
                );
                            savedQuestions.push(question);
                            continue; // Pular para a próxima questão
                        }
                        
              console.log(
                `Adicionando questão ${i + 1}/${
                  currentExamData.questions.length
                }: "${question.text.substring(0, 30)}..."`
              );
                        
                        // Tentar salvar a questão usando saveQuestionToAPI
              const savedQuestion = await saveQuestionToAPI(
                question,
                currentExamData.apiId
              );
                        
                        if (savedQuestion && savedQuestion.apiId) {
                console.log(
                  `Questão ${i + 1} salva com sucesso, ID API: ${
                    savedQuestion.apiId
                  }`
                );
                            savedQuestions.push(savedQuestion);
                        } else {
                console.warn(
                  `Questão ${i + 1} foi processada, mas não retornou ID da API`
                );
                            // Ainda adicionar ao array para manter a consistência
                            savedQuestions.push(question);
                failedQuestions.push(i + 1);
                        }
                    } catch (error) {
              console.error(`Erro ao salvar questão ${i + 1}:`, error);
              failedQuestions.push(i + 1);
                    }
                }
                
                // 4. Atualizar as questões no exame local
                if (savedQuestions.length > 0) {
                    newExam.questions = savedQuestions;
                    updateLocalExam(newExam);
            console.log(
              `Exame local atualizado com ${savedQuestions.length} questões`
            );
                }
                
                // 5. Esconder modal e mostrar mensagem de sucesso
          document
            .getElementById("questionOptionsModal")
            .classList.add("hidden");
                
                // Ajustar mensagem com base no resultado
          let message = "";
                if (failedQuestions.length === 0) {
                    message = `Avaliação criada com sucesso! Todas as ${savedQuestions.length} questões foram adicionadas.`;
                } else {
                    message = `Avaliação criada com sucesso, mas ${failedQuestions.length} questões não puderam ser salvas. ${savedQuestions.length} questões foram adicionadas.`;
                }
                
          showSuccessModal("Avaliação Criada", message, () => {
                        // Limpar dados atuais
                        currentExamData = {
              name: "",
              description: "",
              questions: [],
                        };
                        
                        // Atualizar lista de provas
                        loadExamsFromAPI();
          });
                
                // 6. Atualizar a lista de provas
                await loadExamsFromAPI();
                renderExamsList();
                
          console.log("Processo de criação de prova finalizado com sucesso.");
            } catch (error) {
          console.error("Erro ao finalizar exame:", error);
          alert("Ocorreu um erro ao salvar a avaliação: " + error.message);
            } finally {
                // Restaurar botão
                finalizeBtn.innerHTML = originalBtnText;
                finalizeBtn.disabled = false;
            }
        }
        
        // Função auxiliar para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
          console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }
        
        // Script para atualizar os textos dos selects para mostrar valores dos enums
        function updateSelectOptionsToShowEnumValues() {
            // Garantir que os selects de nível de ensino tenham os valores de enum corretos
        const educationLevelSelects = document.querySelectorAll(
          ".education-level, #educationLevel, #bankEducationLevel, #newExamEducationLevel"
        );
            
            // Para cada select de nível de ensino, verificar se as opções têm os valores corretos
        educationLevelSelects.forEach((select) => {
                if (!select) return;
                
                // Verificar se já possui as opções corretas
                let hasCorrectOptions = false;
                for (let i = 0; i < select.options.length; i++) {
            if (
              select.options[i].value === "ANOS_INICIAIS" &&
              select.options[i].textContent === "Anos Iniciais"
            ) {
                        hasCorrectOptions = true;
                        break;
                    }
                }
                
                // Se já tem as opções corretas, apenas garantir que o texto seja igual ao valor
                if (hasCorrectOptions) {
            Array.from(select.options).forEach((option) => {
                        if (option.value) {
                            switch(option.value) {
                                case "ANOS_INICIAIS":
                                    option.textContent = "Anos Iniciais";
                                    break;
                                case "ANOS_FINAIS":
                                    option.textContent = "Anos Finais";
                                    break;
                                case "ENSINO_MEDIO":
                                    option.textContent = "Ensino Médio";
                                    break;
                            }
                        }
                    });
                } 
                // Caso contrário, recriar as opções com os valores corretos
                else {
                    // Salvar a opção vazia/placeholder
                    let placeholderOption = null;
                    for (let i = 0; i < select.options.length; i++) {
                        if (!select.options[i].value) {
                            placeholderOption = select.options[i].cloneNode(true);
                            break;
                        }
                    }
                    
                    // Limpar e adicionar a opção vazia se existir
            select.innerHTML = "";
                    if (placeholderOption) {
                        select.appendChild(placeholderOption);
                    }
                    
                    // Adicionar as opções com valores corretos
                    const correctValues = [
                        { value: "ANOS_INICIAIS", text: "Anos Iniciais" },
                        { value: "ANOS_FINAIS", text: "Anos Finais" },
                        { value: "ENSINO_MEDIO", text: "Ensino Médio" },
                    ];
                    
            correctValues.forEach((item) => {
              const option = document.createElement("option");
                        option.value = item.value;
                        option.textContent = item.text;
                        select.appendChild(option);
                    });
                }
            });

            // Atualizar os selects de série
            const gradeSelects = document.querySelectorAll(
                ".grade-level, #gradeLevel, #bankGrade, #linkGrade, #bnccGrade"
            );

            gradeSelects.forEach((select) => {
                if (!select) return;

                Array.from(select.options).forEach((option) => {
                    if (option.value) {
                        option.textContent = getFormattedGradeText(option.value);
                    }
                });
            });
        }
        
        // Chamar a função quando o DOM estiver carregado
      document.addEventListener("DOMContentLoaded", function () {
            // Chamar após carregar todos os outros scripts
            setTimeout(updateSelectOptionsToShowEnumValues, 500);
        });
        
        // Função para abrir o seletor de habilidades BNCC
        function openBnccSelector() {
            // Salvar referência ao elemento que receberá os códigos
        const questionItem =
          this.closest(".question-item") || this.closest("form");
        activeInputElement = questionItem
          ? questionItem.querySelector(".bncc-codes-input")
          : null;
            
            // Limpar seleções anteriores
            selectedSkills = [];
            
            // Carregar habilidades selecionadas atuais, se existirem
            if (activeInputElement && activeInputElement.value) {
          const codes = activeInputElement.value.split(",");
          codes.forEach((code) => {
                    const trimmedCode = code.trim();
                    if (trimmedCode) {
                        selectedSkills.push(trimmedCode);
                    }
                });
            }
            
            // Limpar filtros
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
            
            if (bnccComponent) bnccComponent.selectedIndex = 0;
            if (bnccGrade) bnccGrade.selectedIndex = 0;
        if (bnccSearch) bnccSearch.value = "";
            
            // Atualizar contagem de selecionados
        const selectedSkillsCount = document.getElementById(
          "selectedSkillsCount"
        );
        if (selectedSkillsCount)
          selectedSkillsCount.textContent = selectedSkills.length.toString();
            
            // Mostrar mensagem inicial
        const bnccSkillsList = document.getElementById("bnccSkillsList");
            if (bnccSkillsList) {
                bnccSkillsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        Carregando todas as habilidades... Você pode usar os filtros para restringir a lista.
                    </div>
                `;
            }
            
            // Abrir modal
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.remove("hidden");
            
            // Carregar todas as habilidades da API imediatamente
            updateBnccSkillsList();
        }
        
        // Função para fechar o modal BNCC
        function closeBnccModal() {
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.add("hidden");
        }
        
        // Função para confirmar a seleção de habilidades BNCC
        function confirmBnccSelection() {
            if (activeInputElement) {
          // Salvar códigos no input (apenas os códigos, não transformar em números)
          activeInputElement.value = selectedSkills.join(", ");
                
                // Atualizar UI
          const container =
            activeInputElement.closest(".question-item") ||
            activeInputElement.closest("form");
                if (container) {
            const countElement = container.querySelector(
              ".selected-skills-count"
            );
            const listElement = container.querySelector(
              ".selected-skills-list"
            );
                    
                    if (countElement) {
              countElement.textContent =
                selectedSkills.length > 0 ? `(${selectedSkills.length})` : "";
                    }
                    
                    if (listElement) {
              listElement.innerHTML = "";

              selectedSkills.forEach((code) => {
                const div = document.createElement("div");
                div.className =
                  "px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded flex justify-between items-center mb-1";
                            div.innerHTML = `
                                <span>${code}</span>
                                <button type="button" class="remove-skill text-blue-500 hover:text-blue-700" data-code="${code}">
                                    <i class="fas fa-times-circle"></i>
                                </button>
                            `;
                            
                            listElement.appendChild(div);
                            
                            // Adicionar evento para remover habilidade
                const removeBtn = div.querySelector(".remove-skill");
                            if (removeBtn) {
                  removeBtn.addEventListener("click", function () {
                    const codeToRemove = this.getAttribute("data-code");
                                    
                                    // Remover do array
                                    const index = selectedSkills.indexOf(codeToRemove);
                                    if (index !== -1) {
                                        selectedSkills.splice(index, 1);
                                    }
                                    
                    // Atualizar input (apenas os códigos, não transformar em números)
                    activeInputElement.value = selectedSkills.join(", ");
                                    
                                    // Remover elemento visual
                    this.closest("div").remove();
                                    
                                    // Atualizar contagem
                                    if (countElement) {
                      countElement.textContent =
                        selectedSkills.length > 0
                          ? `(${selectedSkills.length})`
                          : "";
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Fechar modal
            closeBnccModal();
        }
        
        // Função para atualizar a lista de habilidades BNCC
        function updateBnccSkillsList() {
        const component = document.getElementById("bnccComponent")?.value;
        const grade = document.getElementById("bnccGrade")?.value;
        const skillsList = document.getElementById("bnccSkillsList");
            
            if (!skillsList) return;
            
            skillsList.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-gray-500">Carregando habilidades...</p>
                </div>
            `;
            
            // Mesmo se componente e série não forem selecionados, vamos carregar todas as habilidades
        loadBnccSkillsFromAPI(grade, component)
          .then((apiSkills) => {
                // Limpar a lista
            skillsList.innerHTML = "";
                
                // Se não houver habilidades, mostrar mensagem
                if (!apiSkills || apiSkills.length === 0) {
                    skillsList.innerHTML = `
                        <div class="text-center text-gray-500 py-4">
                            Nenhuma habilidade encontrada para esta combinação
                        </div>
                    `;
                    return;
                }
                
                // Adicionar cada habilidade à lista
            apiSkills.forEach((skill) => {
              const code = skill.codigo || "";
              const description = skill.descricao || "";
                    
                    const isSelected = selectedSkills.includes(code);
              const div = document.createElement("div");
              div.className =
                "p-2 border-b border-gray-100 last:border-b-0 skill-item";
              div.setAttribute("data-code", code);
              div.setAttribute("data-visible", "true");
                    
                    div.innerHTML = `
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                              isSelected ? "checked" : ""
                            }>
                            <span class="ml-2">
                                <span class="block text-sm font-medium">${code}</span>
                                <span class="block text-xs text-gray-500">${description}</span>
                            </span>
                        </label>
                    `;
                    
                    // Adicionar evento ao checkbox
                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                checkbox.addEventListener("change", function () {
                            if (this.checked) {
                                // Adicionar à seleção
                                if (!selectedSkills.includes(code)) {
                                    selectedSkills.push(code);
                                }
                            } else {
                                // Remover da seleção
                                const index = selectedSkills.indexOf(code);
                                if (index !== -1) {
                                    selectedSkills.splice(index, 1);
                                }
                            }
                            
                            // Atualizar contagem
                  const count = document.getElementById("selectedSkillsCount");
                  if (count)
                    count.textContent = selectedSkills.length.toString();
                        });
                    }
                    
                    skillsList.appendChild(div);
                });
          })
          .catch((error) => {
            console.error("Erro ao carregar habilidades:", error);
                
                skillsList.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        Erro ao carregar habilidades. Tentando usar dados locais...
                    </div>
                `;
                
                // Tentar usar dados locais como fallback
                setTimeout(() => {
                    // Verificar se existem habilidades no banco de dados local para o componente e série
              const localComponent = Object.keys(bnccDatabase).find(
                (key) => key.toLowerCase() === component?.toLowerCase()
              );

              if (
                localComponent &&
                grade &&
                bnccDatabase[localComponent][grade]
              ) {
                        const skills = bnccDatabase[localComponent][grade];
                        
                        // Limpar a lista
                skillsList.innerHTML = "";
                        
                        // Adicionar cada habilidade local à lista
                skills.forEach((skill) => {
                            const isSelected = selectedSkills.includes(skill.code);
                  const div = document.createElement("div");
                  div.className =
                    "p-2 border-b border-gray-100 last:border-b-0 skill-item";
                  div.setAttribute("data-code", skill.code);
                  div.setAttribute("data-visible", "true");
                            
                            div.innerHTML = `
                                <label class="flex items-start cursor-pointer">
                                    <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                                      isSelected ? "checked" : ""
                                    }>
                                    <span class="ml-2">
                                        <span class="block text-sm font-medium">${
                                          skill.code
                                        }</span>
                                        <span class="block text-xs text-gray-500">${
                                          skill.description
                                        }</span>
                                    </span>
                                </label>
                            `;
                            
                            // Adicionar evento ao checkbox
                            const checkbox = div.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                    checkbox.addEventListener("change", function () {
                                    if (this.checked) {
                                        // Adicionar à seleção
                                        if (!selectedSkills.includes(skill.code)) {
                                            selectedSkills.push(skill.code);
                                        }
                                    } else {
                                        // Remover da seleção
                                        const index = selectedSkills.indexOf(skill.code);
                                        if (index !== -1) {
                                            selectedSkills.splice(index, 1);
                                        }
                                    }
                                    
                                    // Atualizar contagem
                      const count = document.getElementById(
                        "selectedSkillsCount"
                      );
                      if (count)
                        count.textContent = selectedSkills.length.toString();
                                });
                            }
                            
                            skillsList.appendChild(div);
                        });
                    } else {
                        skillsList.innerHTML = `
                            <div class="text-center text-gray-500 py-4">
                                Nenhuma habilidade encontrada ${
                                  component ? "para " + component : ""
                                } ${grade ? " - " + grade : ""}
                            </div>
                        `;
                    }
                }, 500);
            });
        }
        
        // Função para filtrar habilidades BNCC
        function filterBnccSkills() {
        const searchText =
          document.getElementById("bnccSearch")?.value.toLowerCase() || "";
        const skillItems = document.querySelectorAll(
          "#bnccSkillsList .skill-item"
        );

        skillItems.forEach((item) => {
          const code = item.getAttribute("data-code") || "";
          const description =
            item.querySelector(".text-gray-500")?.textContent.toLowerCase() ||
            "";
                
                // Verificar se o texto de busca está no código ou na descrição
          if (
            code.toLowerCase().includes(searchText) ||
            description.includes(searchText)
          ) {
            item.style.display = "";
            item.setAttribute("data-visible", "true");
                } else {
            item.style.display = "none";
            item.setAttribute("data-visible", "false");
                }
            });
        }
        
        // Função para selecionar todas as habilidades visíveis
        function selectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && !checkbox.checked && code) {
                    checkbox.checked = true;
                    
                    // Adicionar à seleção
                    if (!selectedSkills.includes(code)) {
                        selectedSkills.push(code);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para desmarcar todas as habilidades visíveis
        function deselectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && checkbox.checked && code) {
                    checkbox.checked = false;
                    
                    // Remover da seleção
                    const index = selectedSkills.indexOf(code);
                    if (index !== -1) {
                        selectedSkills.splice(index, 1);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para configurar uploads de imagem
        function setupImageUploads() {
        document.querySelectorAll(".question-image").forEach((input) => {
          input.addEventListener("change", handleImageUpload);
            });
            
        document.querySelectorAll(".remove-image").forEach((button) => {
          button.addEventListener("click", handleImageRemove);
            });
        }
        
        // Função para tratar upload de imagem
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Pegar o caminho completo do arquivo
            const filePath = file.name;
            
            const reader = new FileReader();
            const container = this.closest(".question-item") || this.closest("form");
            const previewContainer = container?.querySelector(".image-preview");
            const previewImg = previewContainer?.querySelector("img");
            const fileInput = container?.querySelector(".question-image") || container?.querySelector("#questionImage");
            
            if (!previewContainer || !previewImg || !fileInput) return;
            
            reader.onload = function (event) {
                // Mostrar preview da imagem
                previewImg.src = event.target.result;
                previewContainer.classList.remove("hidden");
                
                // Armazenar o caminho do arquivo
                fileInput.dataset.imagePath = filePath;
                
                console.log('Imagem carregada. Caminho:', filePath);
            };
            
            reader.readAsDataURL(file);
        }
        
        
        // Função para remover imagem
        function handleImageRemove() {
        const container =
          this.closest(".question-item") || this.closest("form");
        const previewContainer = container?.querySelector(".image-preview");
        const fileInput =
          container?.querySelector(".question-image") ||
          container?.querySelector("#questionImage");
            
            if (previewContainer) {
          previewContainer.classList.add("hidden");
          const img = previewContainer.querySelector("img");
          if (img) img.src = "";
            }
            
            if (fileInput) {
          fileInput.value = "";
            }
        }
        
        // Função para renderizar lista de avaliações
        function renderExamsList() {
        const examsList = document.getElementById("examsList");
            if (!examsList) return;
            
            // Obter avaliações do localStorage
            let exams = [];
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    exams = JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            
        console.log("Avaliações encontradas:", exams.length, exams);
            
            // Filtrar provas vazias - remover provas com 0 questões e que não existem no banco de dados
            // Remover também as provas simuladas específicas que foram mencionadas
            const namesToRemove = [
          "Avaliação Diagnóstica - Português",
          "Avaliação Diagnóstica - Matemática",
          "Avaliação Bimestral - Português",
          "Avaliação Bimestral - Matemática",
          "Avaliação Final - Ciências",
        ];

        exams = exams.filter((exam) => {
                // Verificar se a prova tem questões
                const questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Incluir a prova apenas se não está na lista de nomes a remover OU tem questões OU tem um ID da API
          return (
            !namesToRemove.includes(exam.name) ||
            questionsCount > 0 ||
            exam.apiId
          );
            });
            
            // Salvar a lista filtrada de volta no localStorage
        localStorage.setItem("exams", JSON.stringify(exams));
            
            // Se não há avaliações, mostrar mensagem
            if (!exams || exams.length === 0) {
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        Nenhuma prova cadastrada
                    </li>
                `;
                return;
            }
            
            // Limpar lista
        examsList.innerHTML = "";
            
            // Adicionar cada avaliação à lista
        exams.forEach((exam) => {
          const li = document.createElement("li");
          li.className = "block hover:bg-gray-50";
                
                // Verificar se a prova tem questões
                let questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Se tiver ID da API mas nenhuma questão local, tentar atualizar o contador com uma mensagem
                let questionCountText = `Questões: ${questionsCount}`;
                if (questionsCount === 0 && exam.apiId) {
                    // Tentar carregar os detalhes da prova da API para mostrar o número correto
                    loadExamDetails(exam.apiId, exams.indexOf(exam), exams)
              .then((success) => {
                            if (success) {
                                // Atualizar a visualização após carregar os detalhes
                                const updatedExams = getExams();
                  const updatedExam = updatedExams.find(
                    (e) => e.id === exam.id
                  );
                                if (updatedExam && updatedExam.questions.length > 0) {
                    const questionCountElement =
                      li.querySelector(".question-count");
                                    if (questionCountElement) {
                                        questionCountElement.textContent = `Questões: ${updatedExam.questions.length}`;
                                    }
                                }
                            }
                        })
              .catch((err) =>
                console.error("Erro ao carregar detalhes da prova:", err)
              );
                        
                    questionCountText = `<span class="question-count">Questões: ${questionsCount} <i class="fas fa-sync-alt fa-spin text-xs ml-1" title="Atualizando contador de questões..."></i></span>`;
                } else {
                    questionCountText = `<span class="question-count">Questões: ${questionsCount}</span>`;
                }
                
                // Formatar data de criação
          let createdAt = "";
                try {
                    if (exam.createdAt) {
                        const date = new Date(exam.createdAt);
              createdAt = date.toLocaleDateString("pt-BR");
                    }
                } catch (e) {
            console.error("Erro ao formatar data:", e);
                }
                
                // Badge para nível de ensino
          const educationLevelBadge = exam.educationLevel
            ? `<span class="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-800 rounded">${exam.educationLevel}</span>`
            : "";
                
          console.log(
            `Renderizando prova: ${exam.name}, API ID: ${exam.apiId}, Questões: ${questionsCount}`
          );
                
                li.innerHTML = `
                    <div class="flex items-center px-4 py-4 sm:px-6">
                        <div class="min-w-0 flex-1 flex items-center">
                            <div class="flex-shrink-0">
                                <span class="h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center">
                                    <i class="fas fa-file-alt text-yellow-600 text-lg"></i>
                                </span>
                            </div>
                            <div class="min-w-0 flex-1 px-4">
                                <div>
                                    <p class="text-sm font-medium text-blue-600 truncate">
                                        ${exam.name} ${educationLevelBadge}
                                    </p>
                                    <p class="mt-1 text-sm text-gray-500">
                                        ${questionCountText} | Criada em: ${createdAt}
                                    </p>
                                    ${
                                      exam.description
                                        ? `<p class="mt-1 text-xs text-gray-400 truncate">${exam.description}</p>`
                                        : ""
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            <button onclick="visualizarProva(${exam.apiId || exam.id})" class="bg-white text-blue-500 p-2 rounded-full hover:bg-blue-100 border border-gray-200" data-id="${exam.id}" title="Visualizar Prova"><i class="fas fa-eye"></i>
</button>
                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${
                              exam.id
                            }" title="Baixar PDF">
                                <i class="fas fa-file-pdf"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                examsList.appendChild(li);
            });
            
            // Adicionar eventos aos botões
            setupExamListButtons();
        }
        
        // Função para configurar botões na lista de avaliações
        function setupExamListButtons() {
            // Visualizar avaliação
            document.querySelectorAll(".viewExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    viewExam(examId);
                });
            });
            
            // Editar avaliação
            document.querySelectorAll(".editExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    openExamForEditing(examId);
                });
            });
            
            // Editar questões da avaliação
            document.querySelectorAll(".editQuestionsExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const apiId = this.getAttribute("data-api-id");
                    if (!apiId) {
                        alert("Esta prova não possui ID da API e não pode ter suas questões editadas.");
                        return;
                    }
                    openEditQuestionsModal(examId, apiId);
                });
            });
            
            // Baixar avaliação
            document.querySelectorAll(".downloadExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    if (exam) {
                        // Adicionar debug para ver a estrutura da prova
                        console.log("ESTRUTURA DA PROVA:", JSON.stringify(exam, null, 2));
                        console.log("QUESTÕES:", JSON.stringify(exam.questions, null, 2));
                        if (exam.questions && exam.questions.length > 0) {
                            console.log("PRIMEIRA QUESTÃO:", JSON.stringify(exam.questions[0], null, 2));
                            console.log("ALTERNATIVAS:", JSON.stringify(exam.questions[0].options || exam.questions[0].alternativas, null, 2));
                        }
                        exportExamToDocx(exam);
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
        }
        
        // Função para visualizar uma avaliação
        function viewExam(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Aqui você pode implementar a visualização completa da avaliação
            // Por enquanto, mostraremos algumas informações básicas
        alert(
          `Visualizando: ${exam.name}\nTotal de questões: ${exam.questions.length}`
        );
            
            // Em um caso real, você abriria um modal ou navegaria para uma página de detalhes
        }
        
        // Função para abrir uma avaliação para edição
        function openExamForEditing(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Preencher dados no modal de edição
        document.getElementById("newExamName").value = exam.name;
        document.getElementById("newExamDescription").value =
          exam.description || "";
            
            // Definir o nível de ensino
        const educationLevelSelect = document.getElementById(
          "newExamEducationLevel"
        );
            if (educationLevelSelect) {
                // Tentar encontrar o option com o valor igual ao do exame
          const eduLevel = exam.educationLevel || "";
                let optionExists = false;
                
                // Procurar pelo valor exato primeiro
                for (let i = 0; i < educationLevelSelect.options.length; i++) {
                    if (educationLevelSelect.options[i].value === eduLevel) {
                        educationLevelSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }
                
                // Se não encontrou, tentar mapear para um valor válido da API
                if (!optionExists) {
            let mappedValue = "";
                    const eduLevelUpper = eduLevel.toUpperCase();
                    
            if (
              eduLevelUpper.includes("INICIAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL I")
            ) {
              mappedValue = "ANOS_INICIAIS";
            } else if (
              eduLevelUpper.includes("FINAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL II")
            ) {
              mappedValue = "ANOS_FINAIS";
            } else if (
              eduLevelUpper.includes("MÉDIO") ||
              eduLevelUpper.includes("MEDIO")
            ) {
              mappedValue = "ENSINO_MEDIO";
                    }
                    
                    if (mappedValue) {
                        for (let i = 0; i < educationLevelSelect.options.length; i++) {
                            if (educationLevelSelect.options[i].value === mappedValue) {
                                educationLevelSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Armazenar o ID da prova que está sendo editada
            currentExamData = {
                id: exam.id,
                apiId: exam.apiId,
                name: exam.name,
          description: exam.description || "",
          questions: [...exam.questions], // Clone para não modificar o original
            };
            
            // Abrir o modal de edição
        document
          .getElementById("createExamStepOneModal")
          .classList.remove("hidden");
            
            // Atualizar o título do modal
        const modalTitle = document.querySelector("#createExamStepOneModal h3");
            if (modalTitle) {
          modalTitle.textContent = "Editar Prova";
            }
            
            // Atualizar o texto do botão
        const submitBtn = document.querySelector(
          '#createExamStepOneForm button[type="submit"]'
        );
            if (submitBtn) {
          submitBtn.textContent = "Continuar para Edição de Questões";
            }
        }
        
        // Função para atualizar uma prova existente
        async function updateExam(exam) {
            try {
          console.log("Iniciando atualização da prova ID:", exam.id);
                
                // Atualizar localmente
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
            console.log("Prova atualizada no armazenamento local");
                } else {
            throw new Error("Prova não encontrada no armazenamento local");
                }
                
                // Se tiver ID da API, atualizar remotamente
                if (exam.apiId) {
                    // Mapear o nível de ensino - usar apenas valores válidos para a API
                    let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                    if (exam.educationLevel) {
              switch (exam.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "ANOS_INICIAIS";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "ANOS_FINAIS";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "ENSINO_MEDIO";
                                break;
                            default:
                                // Caso não identifique, usar o padrão ANOS_INICIAIS
                                nivelEnsino = "ANOS_INICIAIS";
                        }
                    }
                    
                    // Converter para o formato da API
                    const apiExam = {
                        id: exam.apiId,
                        nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: exam.description || "",
                        data_aplicacao: new Date().toISOString(),
              nivel_ensino: nivelEnsino,
                    };
                    
            console.log("Dados enviados para a API:", apiExam);
                    
                    // Adicionar questões se existirem
                    if (exam.questions && exam.questions.length > 0) {
              apiExam.questoes = exam.questions.map((q) => {
                            return {
                                texto: q.text,
                                nivel_ensino: nivelEnsino,
                  serie: q.gradeLevel || "",
                  dificuldade: q.difficultyLevel || "",
                  componente_curricular: q.curriculumComponent || "",
                  codigos_bncc: q.bnccCodes || "",
                  resposta_correta: q.correctAnswer || "A",
                  alternativa_a: q.options.A || "",
                  alternativa_b: q.options.B || "",
                  alternativa_c: q.options.C || "",
                  alternativa_d: q.options.D || "",
                  imagem: q.image || null,
                            };
                        });
                    }
                    
            console.log(
              `Enviando atualização para a API: /api/provas/${exam.apiId}`,
              apiExam
            );

            const response = await fetch(
              `https://sag-sag.rak8a3.easypanel.host/api/provas/${exam.apiId}`,
              {
                method: "PUT",
                        headers: {
                  "Content-Type": "application/json",
                        },
                body: JSON.stringify(apiExam),
              }
            );
                    
                    if (!response.ok) {
              const errorText = await response
                .text()
                .catch(() => "Erro desconhecido");
              console.error(
                `Erro ao atualizar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
              );
              throw new Error(
                `Não foi possível atualizar a prova na API. Status: ${response.status}`
              );
                    }
                    
                    const updatedExam = await response.json().catch(() => null);
            console.log("Prova atualizada com sucesso na API:", updatedExam);
                    
                    // Se a API retornou dados atualizados, sincronizar com a cópia local
                    if (updatedExam) {
                        // Atualizar dados que possam ter sido modificados pela API
                        exam.apiId = updatedExam.id;
                        // Atualizar no armazenamento local
                        exams[index] = exam;
              localStorage.setItem("exams", JSON.stringify(exams));
                        
                        // Recarregar a lista de provas da API para garantir sincronização
              console.log("Recarregando lista de provas da API...");
                        await loadExamsFromAPI();
                    }
                    
                    // Atualizar a interface
                    renderExamsList();
            console.log("Interface atualizada com os novos dados da prova");
                    
                    return true;
                } else {
                    // Se não tem ID da API, tentar criar novo registro na API
                    try {
              console.log(
                "Prova sem ID da API. Tentando criar novo registro na API..."
              );
                        const savedExam = await saveExamToAPI(exam);
                        if (savedExam && savedExam.id) {
                            // Atualizar o ID da API na cópia local
                            exam.apiId = savedExam.id;
                            exams[index] = exam;
                localStorage.setItem("exams", JSON.stringify(exams));
                console.log("Prova criada na API com sucesso:", savedExam);
                            
                            // Recarregar a lista de provas da API
                            await loadExamsFromAPI();
                            
                            // Atualizar a interface
                            renderExamsList();
                        }
                    } catch (apiError) {
              console.error("Erro ao criar prova na API:", apiError);
                        // Continue mesmo se falhar na API, pois já temos localmente
                        
                        // Atualizar a interface de qualquer forma
                        renderExamsList();
                    }
                    return true;
                }
            } catch (error) {
          console.error("Erro ao atualizar prova:", error);
                return false;
            }
        }
        
        // Função para obter todas as avaliações
        function getExams() {
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    return JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            return [];
        }
        
        // Função para adicionar uma nova avaliação
      function addExam(name, questions, description = "", educationLevel = "") {
            // Obter avaliações existentes
            let exams = getExams() || [];
            
            // Gerar ID único
        const newId = exams.length > 0 ? Math.max(...exams.map((e) => e.id)) + 1 : 1;
            
            // Processar as questões para garantir formato correto
            const processedQuestions = questions.map(question => {
                console.log("Processando questão para addExam:", question);
                
                // Garantir que options está no formato correto
                const options = {};
                
                // Caso 1: Se já tem um objeto options com formato {A: "texto", B: "texto"}
                if (question.options && typeof question.options === 'object' && !Array.isArray(question.options)) {
                    options.A = question.options.A || '';
                    options.B = question.options.B || '';
                    options.C = question.options.C || '';
                    options.D = question.options.D || '';
                }
                // Caso 2: Se tem um array de alternativas
                else if (question.alternativas && Array.isArray(question.alternativas)) {
                    const letters = ['A', 'B', 'C', 'D'];
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letra = letters[index];
                            options[letra] = alt.texto || alt.text || '';
                        }
                    });
                }
                
                console.log("Opções processadas:", options);
                
                // Retornar questão processada
                return {
                    ...question,
                    options: options
                };
            });
            
            // Criar objeto de avaliação
            const newExam = {
                id: newId,
                name: name,
                description: description,
                educationLevel: educationLevel,
                questions: processedQuestions,
                createdAt: new Date().toISOString(),
                links: [],
            };
            
            // Adicionar à lista
            exams.push(newExam);
            
            // Salvar no localStorage
            localStorage.setItem("exams", JSON.stringify(exams));
            
            console.log("Nova avaliação adicionada:", newExam);
            
            return newExam;
        }
        
        // Função para popular o seletor de avaliações
        async function populateExamSelector() {
        const examSelect = document.getElementById("examSelect");
            if (!examSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          examSelect.innerHTML =
            '<option value="">Carregando provas...</option>';
                examSelect.disabled = true;
                
                // Buscar provas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/provas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const exams = await response.json();
          console.log("Provas carregadas da API:", exams);
                
                // Limpar seletor
          examSelect.innerHTML =
            '<option value="">Selecione uma prova</option>';
                
                // Verificar se a resposta é um array
                if (Array.isArray(exams) && exams.length > 0) {
                    // Adicionar cada prova ao seletor
            exams.forEach((exam) => {
              const option = document.createElement("option");
                        option.value = exam.id;
                        
                        // Dar preferência ao campo 'nome'
                        if (exam.nome !== undefined) {
                            option.textContent = exam.nome;
                        } else if (exam.titulo !== undefined) {
                            option.textContent = exam.titulo;
                        } else {
                option.textContent = "Prova sem título";
                        }
                        
                        examSelect.appendChild(option);
                    });
                } else {
                    // Se não houver provas, mostrar mensagem
            examSelect.innerHTML =
              '<option value="">Nenhuma prova disponível</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar provas:", error);
          examSelect.innerHTML =
            '<option value="">Erro ao carregar provas</option>';
            } finally {
                examSelect.disabled = false;
            }
            
            return examSelect;
        }
        
        // Função para popular o seletor de escolas
        async function populateSchoolSelector() {
        const schoolSelect = document.getElementById("linkSchool");
            if (!schoolSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          schoolSelect.innerHTML =
            '<option value="">Carregando escolas...</option>';
                schoolSelect.disabled = true;
                
                // Buscar escolas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/escolas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar escolas. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
                
                // Verificar se a resposta é paginada ou direta
                const schools = result.data || result;
                
                // Limpar seletor
          schoolSelect.innerHTML =
            '<option value="">Selecione uma escola</option>';
                
                // Verificar se há escolas
                if (Array.isArray(schools) && schools.length > 0) {
                    // Adicionar cada escola ao seletor
                    schools.forEach((school) => {
                        const option = document.createElement("option");
                        option.value = school.id;
                        option.textContent = school.nome || "Escola sem nome";
                        schoolSelect.appendChild(option);
                    });
                } else {
                    // Se não há escolas, mostrar mensagem
                    schoolSelect.innerHTML =
                        '<option value="">Nenhuma escola encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar escolas:", error);
          schoolSelect.innerHTML =
            '<option value="">Erro ao carregar escolas</option>';
            } finally {
                schoolSelect.disabled = false;
            }
        }
        
        // Função para popular o seletor de turmas
        async function populateClassSelector(schoolId) {
        const classSelect = document.getElementById("linkClass");
            if (!classSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          classSelect.innerHTML =
            '<option value="">Carregando turmas...</option>';
                classSelect.disabled = true;
                
                if (!schoolId) {
            classSelect.innerHTML =
              '<option value="">Selecione uma escola primeiro</option>';
                    classSelect.disabled = true;
                    return;
                }
                
                // Buscar turmas da API
          const response = await fetch(
            `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar turmas. Status: ${response.status}`
            );
                }
                
                const classes = await response.json();
                
                // Limpar seletor
          classSelect.innerHTML =
            '<option value="">Selecione uma turma</option>';
                
                // Adicionar cada turma ao seletor
          classes.forEach((cls) => {
            const option = document.createElement("option");
                    option.value = cls.id;
                    option.textContent = cls.nome || `Turma ${cls.id}`;
                    classSelect.appendChild(option);
                });
                
                // Se não há turmas, mostrar mensagem
                if (classes.length === 0) {
            classSelect.innerHTML =
              '<option value="">Nenhuma turma encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar turmas:", error);
          classSelect.innerHTML =
            '<option value="">Erro ao carregar turmas</option>';
            } finally {
                classSelect.disabled = false;
            }
        }
        
        // Atualizar o formulário de vincular prova
        function updateLinkExamForm() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        // Função para vincular uma avaliação a uma turma
        async function linkExamToClass(examId, schoolId, grade, classId, shift) {
            try {
                const payload = {
                    prova_id: examId,
            turma_id: classId,
                };
                
          console.log("Enviando dados para vincular prova:", payload);
                
                // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao vincular prova. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
          console.log("Prova vinculada com sucesso:", result);
                
                return true;
            } catch (error) {
          console.error("Erro ao vincular prova:", error);
                throw error;
            }
        }
        
        // Função para exportar uma avaliação para PDF
        function exportExamToDocx(exam) {
    // Verificar se o objeto exam é válido
    if (!exam || !exam.name) {
        alert('Prova inválida para exportação!');
        return;
    }

    // Log detalhado de depuração para mostrar as alternativas
    console.log("INICIANDO EXPORTAÇÃO DA PROVA:", exam.name);
    if (exam.questions && exam.questions.length > 0) {
        exam.questions.forEach((q, index) => {
            console.log(`Questão ${index + 1}:`, q.text);
            console.log(`  Alternativas para questão ${index + 1}:`, q.options);
            
            // Verificar se as alternativas estão vazias
            const hasNonEmptyOptions = q.options && Object.values(q.options).some(opt => opt && opt.trim() !== '');
            console.log(`  Tem alternativas não vazias? ${hasNonEmptyOptions}`);
            
            if (!hasNonEmptyOptions) {
                console.warn("⚠️ ALTERNATIVAS VAZIAS DETECTADAS! Verificando alternativas originais no localStorage...");
                
                // Buscar dados originais do localStorage
                try {
                    const exams = JSON.parse(localStorage.getItem("exams")) || [];
                    const localExam = exams.find(e => e.id === exam.id);
                    if (localExam && localExam.questions) {
                        const localQuestion = localExam.questions.find(lq => lq.id === q.id || lq.apiId === q.apiId);
                        if (localQuestion && localQuestion.options) {
                            console.log("  Alternativas no localStorage:", localQuestion.options);
                            
                            // Atualizar as alternativas da questão atual com as do localStorage
                            if (Object.values(localQuestion.options).some(opt => opt && opt.trim() !== '')) {
                                console.log("  ✅ Usando alternativas do localStorage");
                                q.options = localQuestion.options;
                            }
                        }
                    }
                } catch (error) {
                    console.error("Erro ao buscar alternativas do localStorage:", error);
                }
            }
        });
    }

    // Indicar que estamos processando
    const processingMessage = document.createElement('div');
    processingMessage.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    processingMessage.innerHTML = `
        <div class="bg-white p-4 rounded-lg shadow-lg text-center">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mb-4"></div>
            <p class="text-gray-800">Gerando PDF...</p>
        </div>
    `;
    document.body.appendChild(processingMessage);

    // Função para carregar as bibliotecas necessárias (jsPDF e html2canvas)
    function loadPdfLibraries() {
        return new Promise((resolve, reject) => {
            // Verificar se as bibliotecas já estão carregadas
            if (typeof jspdf !== 'undefined' && typeof html2canvas !== 'undefined') {
                resolve({ jspdf, html2canvas });
                return;
            }

            // Contador para controlar o carregamento das duas bibliotecas
            let loaded = 0;
            
            // Carregar jsPDF
            const jspdfScript = document.createElement('script');
            jspdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            jspdfScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            jspdfScript.onerror = () => reject(new Error('Falha ao carregar jsPDF'));
            document.head.appendChild(jspdfScript);
            
            // Carregar html2canvas
            const html2canvasScript = document.createElement('script');
            html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            html2canvasScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            html2canvasScript.onerror = () => reject(new Error('Falha ao carregar html2canvas'));
            document.head.appendChild(html2canvasScript);
        });
    }

    // Função para remover a mensagem de processamento
    function removeProcessingMessage() {
        if (processingMessage && processingMessage.parentNode) {
            processingMessage.parentNode.removeChild(processingMessage);
        }
    }

    // Função para criar o conteúdo HTML que será convertido em PDF
    function createExamContent() {
        // Criar um contêiner para o conteúdo do PDF
        const container = document.createElement('div');
        container.style.width = '210mm'; // Largura A4
        container.style.padding = '20mm';
        container.style.backgroundColor = 'white';
        container.style.color = 'black';
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.top = '0';
        
        // Cabeçalho da avaliação
        container.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">AVALIAÇÃO</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">${exam.name.toUpperCase()}</h2>
                <p style="margin-bottom: 10px; font-size: 16px;">Nome do Aluno: _____________________________________________</p>
                <p style="margin-bottom: 30px; font-size: 16px;">Data: ___/___/______</p>
            </div>
            
            <!-- Instruções -->
            <div style="border: 1px solid #999; padding: 15px; margin-bottom: 30px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #666;">INSTRUÇÕES:</p>
                <p style="margin-bottom: 8px; color: #666;">1. Leia atentamente cada questão antes de respondê-la</p>
                <p style="margin-bottom: 8px; color: #666;">2. Use caneta azul ou preta para marcar suas respostas</p>
                <p style="margin-bottom: 8px; color: #666;">3. Não é permitido o uso de corretivo</p>
                <p style="color: #666;">4. Questões rasuradas serão anuladas</p>
            </div>
        `;
        
        // Adicionar questões
        if (exam.questions && exam.questions.length > 0) {
            const questionsDiv = document.createElement('div');
            
            exam.questions.forEach((question, index) => {
                const questionText = question.text || question.enunciado || "";
                if (!questionText) {
                    console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                    return;
                }
                
                // Cabeçalho da questão
                const questionDiv = document.createElement('div');
                questionDiv.style.marginBottom = '30px';
                questionDiv.style.pageBreakInside = 'avoid';
                
                questionDiv.innerHTML = `
                    <div style="border-top: 1px solid #ccc; margin-top: 15px; margin-bottom: 15px;"></div>
                    <div style="display: flex; margin-bottom: 15px;">
                        <div style="background-color: #666; color: white; padding: 8px 15px; font-weight: bold; width: 30%; display: inline-block;">
                            QUESTÃO ${index + 1}
                        </div>
                        <div style="padding: 8px 15px; width: 70%; text-align: right; display: inline-block;">
                            1 ponto
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 16px; margin-left: 15px;">${questionText}</p>
                `;
                
                // Adicionar imagem se existir
                if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                    questionDiv.innerHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <img src="${question.image}" alt="Imagem da questão" style="max-width: 80%; max-height: 200px; border: 1px solid #ddd; padding: 5px;">
                            <p style="font-style: italic; color: #666; font-size: 12px; margin-top: 5px;">Figura ${index + 1}: Imagem referente à questão</p>
                        </div>
                    `;
                }
                
                // Adicionar alternativas
                const alternativasLetras = ['A', 'B', 'C', 'D'];
                let alternativas = [];
                
                if (question.options && typeof question.options === 'object') {
                    // Formato {A: "texto", B: "texto"}
                    alternativasLetras.forEach(letra => {
                        let texto = '';
                        
                        // Se tem texto na alternativa, use-o
                        if (question.options[letra] && question.options[letra].trim() !== '') {
                            texto = question.options[letra];
                        } 
                        // Caso contrário, use um texto padrão
                        else {
                            texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                        }
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                } else if (question.alternativas && Array.isArray(question.alternativas)) {
                    question.alternativas.forEach((alt, index) => {
                        if (index < alternativasLetras.length) {
                            const letra = alternativasLetras[index];
                            let texto = alt.texto || alt.text || '';
                            
                            if (!texto || texto.trim() === '') {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        }
                    });
                }
                
                // Se não encontrou alternativas, criar alternativas padrão
                if (alternativas.length === 0) {
                    alternativasLetras.forEach(letra => {
                        const texto = letra === question.correctAnswer 
                            ? `Alternativa correta ${letra}`
                            : `Alternativa ${letra}`;
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                }
                
                // Ordenar alternativas por letra
                alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                
                // Adicionar cada alternativa ao HTML
                const alternativesHtml = document.createElement('div');
                alternativesHtml.style.marginLeft = '30px';
                
                alternativas.forEach(({letra, texto}) => {
                    alternativesHtml.innerHTML += `
                        <p style="margin-bottom: 10px; font-size: 16px;">
                            <span style="display: inline-block; width: 25px; height: 25px; border-radius: 50%; border: 1px solid #666; text-align: center; line-height: 23px; margin-right: 10px; font-weight: bold;">${letra}</span>
                            ${texto}
                        </p>
                    `;
                });
                
                questionDiv.appendChild(alternativesHtml);
                questionsDiv.appendChild(questionDiv);
            });
            
            container.appendChild(questionsDiv);
        } else {
            // Se não houver questões, adicionar mensagem
            container.innerHTML += `
                <p style="text-align: center; font-style: italic; margin: 30px 0;">
                    Esta avaliação não contém questões.
                </p>
            `;
        }
        
        return container;
    }

    // Função para gerar o PDF
    async function generatePdf(libraries) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Provas - SAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
        /* Ajustes de layout */
        .container-full {
            width: 100%;
            max-width: 100%;
            padding-left: 0;
            padding-right: 0;
        }
        .modal-overflow {
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ajusta layout em dispositivos móveis */
        @media (max-width: 768px) {
            .mobile-padding {
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="min-h-screen flex flex-col">
        <!-- Navbar -->
        <nav class="bg-blue-600 text-white shadow-md">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center">
                        <div class="flex-shrink-0 flex items-center">
                            <span class="text-xl font-bold">SAG</span>
                        </div>
                        <div class="hidden md:ml-6 md:flex md:items-center md:space-x-4">
                <a
                  href="dashboard.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Dashboard</a
                >
                <a
                  href="escolas.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Escolas</a
                >
                <a
                  href="turmas.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Turmas</a
                >
                <a
                  href="alunos.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Alunos</a
                >
                <a
                  href="provas.html"
                  class="px-3 py-2 rounded-md text-sm font-medium bg-blue-700"
                  >Provas</a
                >
                <a
                  href="usuarios.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Usuários</a
                >
                <a
                  href="gabaritos_geracao.html"
                  class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
                  >Gabaritos</a
                >
                        </div>
                    </div>
                    <div class="flex items-center">
                        <span id="userName" class="mr-4"></span>
              <button
                id="logoutBtn"
                class="px-3 py-2 rounded-md text-sm font-medium hover:bg-blue-700"
              >
                            <i class="fas fa-sign-out-alt mr-1"></i> Sair
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Mobile menu button -->
            <div class="md:hidden flex items-center px-4">
                <button id="mobileMenuBtn" class="text-white focus:outline-none">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
            
            <!-- Mobile menu -->
            <div class="md:hidden hidden" id="mobileMenu">
                <div class="px-2 pt-2 pb-3 space-y-1 sm:px-3">
            <a
              href="dashboard.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Dashboard</a
            >
            <a
              href="escolas.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Escolas</a
            >
            <a
              href="turmas.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Turmas</a
            >
            <a
              href="alunos.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Alunos</a
            >
            <a
              href="provas.html"
              class="block px-3 py-2 rounded-md text-base font-medium bg-blue-700"
              >Provas</a
            >
            <a
              href="usuarios.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Usuários</a
            >
            <a
              href="gabaritos_geracao.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Gabaritos</a
            >
            <a
              href="gabaritos_correcao.html"
              class="block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-700"
              >Correção</a
            >
                </div>
            </div>
        </nav>
        
        <!-- Main content -->
        <main class="flex-grow">
            <div class="py-6 px-4 sm:px-6 lg:px-8 w-full">
                <!-- Page header -->
          <div
            class="px-4 py-5 sm:px-6 bg-white shadow rounded-lg mb-6 flex flex-wrap justify-between items-center"
          >
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">Provas</h1>
              <p class="mt-1 max-w-2xl text-sm text-gray-500">
                Gerenciamento de avaliações
              </p>
                    </div>
                    <div class="flex flex-wrap gap-2 mt-4 sm:mt-0">
                        <div class="flex flex-wrap gap-2">
                <button
                  id="linkExamBtn"
                  class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                >
                                <i class="fas fa-link mr-2"></i> Vincular Prova
                            </button>
                <button
                  id="exportAllExamsBtn"
                  class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500"
                >
                                <i class="fas fa-file-pdf mr-2"></i> Exportar Todas
                            </button>
                        </div>
                        <div class="flex items-center space-x-2">
                <button
                  id="createExamBtn"
                  class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                >
                                Criar Avaliação
                            </button>
                <button
                  id="importExamBtn"
                  class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded hidden"
                >
                                Importar Avaliação
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Exams List -->
                <div class="bg-white shadow overflow-hidden sm:rounded-md">
                    <ul id="examsList" class="divide-y divide-gray-200">
                        <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                            Nenhuma prova cadastrada
                        </li>
                    </ul>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="bg-white">
            <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
          <p class="text-center text-sm text-gray-500">
            SAG - Sistema de Avaliação e Gerenciamento © 2023
          </p>
            </div>
        </footer>
        
        <!-- Add Exam Modal -->
      <div
        id="addExamModal"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-3xl modal-overflow mx-auto my-4"
        >
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-medium text-gray-900">Criar Nova Prova</h3>
            <button
              id="closeExamModal"
              class="text-gray-400 hover:text-gray-500"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <form id="addExamForm" class="space-y-4">
                    <div>
              <label
                for="examName"
                class="block text-sm font-medium text-gray-700"
                >Nome da Prova</label
              >
              <input
                type="text"
                id="examName"
                name="examName"
                required
                class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              />
                    </div>
                    
                    <div id="questionsContainer" class="space-y-6">
                        <!-- Questão 1 -->
                        <div class="question-item bg-gray-50 p-4 rounded-md">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="text-md font-medium">Questão 1</h4>
                            </div>
                            <div class="space-y-3">
                                <div>
                    <label class="block text-sm font-medium text-gray-700"
                      >Enunciado</label
                    >
                    <textarea
                      class="question-text mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                      rows="2"
                      required
                    ></textarea>
                                </div>
                                
                                <!-- Imagem da questão -->
                                <div>
                    <label class="block text-sm font-medium text-gray-700"
                      >Imagem (opcional)</label
                    >
                                    <div class="mt-1 flex items-center">
                      <input
                        type="file"
                        accept="image/*"
                        class="question-image block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                      />
                                    </div>
                                    <div class="mt-2 image-preview hidden">
                      <img src="" alt="Preview" class="max-h-48 rounded" />
                      <button
                        type="button"
                        class="remove-image mt-1 text-xs text-red-600 hover:text-red-900"
                      >
                                            <i class="fas fa-times mr-1"></i> Remover imagem
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Metadados da questão -->
                  <div
                    class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50 rounded-md"
                  >
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Nível de ensino</label
                      >
                      <select
                        class="education-level mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                      >
                                            <option value="">Selecione</option>
                                            <option value="ANOS_INICIAIS">ANOS_INICIAIS</option>
                                            <option value="ANOS_FINAIS">ANOS_FINAIS</option>
                                            <option value="ENSINO_MEDIO">ENSINO_MEDIO</option>
                                        </select>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Série</label
                      >
                      <select
                        class="grade-level mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                      >
                                            <option value="">Selecione</option>
                                            <option value="PRIMEIRO_ANO">PRIMEIRO_ANO</option>
                                            <option value="SEGUNDO_ANO">SEGUNDO_ANO</option>
                                            <option value="TERCEIRO_ANO">TERCEIRO_ANO</option>
                                            <option value="QUARTO_ANO">QUARTO_ANO</option>
                                            <option value="QUINTO_ANO">QUINTO_ANO</option>
                                            <option value="SEXTO_ANO">SEXTO_ANO</option>
                                            <option value="SETIMO_ANO">SETIMO_ANO</option>
                                            <option value="OITAVO_ANO">OITAVO_ANO</option>
                                            <option value="NONO_ANO">NONO_ANO</option>
                                            <option value="PRIMEIRA_SERIE">PRIMEIRA_SERIE</option>
                                            <option value="SEGUNDA_SERIE">SEGUNDA_SERIE</option>
                                            <option value="TERCEIRA_SERIE">TERCEIRA_SERIE</option>
                                        </select>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Dificuldade</label
                      >
                      <select
                        class="difficulty-level mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                      >
                                            <option value="">Selecione</option>
                                            <option value="FACIL">FACIL</option>
                                            <option value="MEDIO">MEDIO</option>
                                            <option value="DIFICIL">DIFICIL</option>
                                        </select>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Componente curricular</label
                      >
                      <select
                        class="curriculum-component mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                      >
                                            <option value="">Selecione</option>
                                            <option value="1">Língua Portuguesa</option>
                                            <option value="2">Matemática</option>
                                            <option value="3">Ciências</option>
                                            <option value="4">História</option>
                                            <option value="5">Geografia</option>
                                            <option value="6">Educação Física</option>
                                            <option value="7">Arte</option>
                                            <option value="8">Inglês</option>
                                        </select>
                                    </div>
                                    <div class="md:col-span-2">
                      <label class="block text-sm font-medium text-gray-700"
                        >Habilidades BNCC</label
                      >
                                        <div class="mb-4">
                        <label
                          class="block text-gray-700 text-sm font-bold mb-2"
                        >
                          Habilidades BNCC
                          <span
                            class="selected-skills-count text-gray-500 text-xs"
                          ></span>
                                            </label>
                        <div
                          class="border border-gray-300 rounded-md p-2 bg-white relative"
                        >
                          <div
                            class="selected-skills-list space-y-1 mb-2"
                          ></div>
                          <button
                            type="button"
                            class="select-bncc-btn w-full py-2 px-3 border border-gray-300 bg-gray-100 rounded-md text-sm text-left text-gray-700 hover:bg-gray-200 focus:outline-none"
                          >
                            <i class="fas fa-plus-circle mr-2"></i> Selecionar
                            habilidades BNCC
                                                </button>
                          <input type="hidden" class="bncc-codes-input" />
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-1 gap-3">
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Alternativa A</label
                      >
                                        <div class="flex items-center mt-1">
                        <input
                          type="radio"
                          name="correctAnswer1"
                          value="A"
                          class="correct-option mr-2"
                          required
                        />
                        <input
                          type="text"
                          class="option-text block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          required
                        />
                                        </div>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Alternativa B</label
                      >
                                        <div class="flex items-center mt-1">
                        <input
                          type="radio"
                          name="correctAnswer1"
                          value="B"
                          class="correct-option mr-2"
                        />
                        <input
                          type="text"
                          class="option-text block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          required
                        />
                                        </div>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Alternativa C</label
                      >
                                        <div class="flex items-center mt-1">
                        <input
                          type="radio"
                          name="correctAnswer1"
                          value="C"
                          class="correct-option mr-2"
                        />
                        <input
                          type="text"
                          class="option-text block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          required
                        />
                                        </div>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Alternativa D</label
                      >
                                        <div class="flex items-center mt-1">
                        <input
                          type="radio"
                          name="correctAnswer1"
                          value="D"
                          class="correct-option mr-2"
                        />
                        <input
                          type="text"
                          class="option-text block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          required
                        />
                                        </div>
                                    </div>
                                    <div>
                      <label class="block text-sm font-medium text-gray-700"
                        >Alternativa E</label
                      >
                                        <div class="flex items-center mt-1">
                        <input
                          type="radio"
                          name="correctAnswer1"
                          value="E"
                          class="correct-option mr-2"
                        />
                        <input
                          type="text"
                          class="option-text block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          required
                        />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
              <button
                type="button"
                id="addQuestionBtn"
                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                            <i class="fas fa-plus mr-2"></i> Adicionar Questão
                        </button>
              <button
                type="button"
                id="questionBankBtn"
                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 ml-2"
              >
                            <i class="fas fa-database mr-2"></i> Banco de Questões
                        </button>
                    </div>
                    
                    <div class="flex justify-end">
              <button
                type="button"
                id="cancelExamBtn"
                class="mr-3 bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
              >
                            Cancelar
                        </button>
              <button
                type="submit"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                            Salvar Prova
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Link Exam Modal -->
      <div
        id="linkExamModal"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4"
        >
                <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-medium text-gray-900">
              Vincular Prova a Turma
            </h3>
            <button
              id="closeLinkExamModal"
              class="text-gray-400 hover:text-gray-500"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <form id="linkExamForm" class="space-y-4">
                    <div>
              <label
                for="examSelect"
                class="block text-sm font-medium text-gray-700"
                >Selecionar Prova</label
              >
              <select
                id="examSelect"
                name="examSelect"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione uma prova</option>
                        </select>
                    </div>
                    <div>
              <label
                for="linkSchool"
                class="block text-sm font-medium text-gray-700"
                >Escola</label
              >
              <select
                id="linkSchool"
                name="linkSchool"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione uma escola</option>
                        </select>
                    </div>
                    <div>
              <label
                for="linkGrade"
                class="block text-sm font-medium text-gray-700"
                >Série</label
              >
              <select
                id="linkGrade"
                name="linkGrade"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione a série</option>
                            <option value="PRIMEIRO_ANO">PRIMEIRO_ANO</option>
                            <option value="SEGUNDO_ANO">SEGUNDO_ANO</option>
                            <option value="TERCEIRO_ANO">TERCEIRO_ANO</option>
                            <option value="QUARTO_ANO">QUARTO_ANO</option>
                            <option value="QUINTO_ANO">QUINTO_ANO</option>
                            <option value="SEXTO_ANO">SEXTO_ANO</option>
                            <option value="SETIMO_ANO">SETIMO_ANO</option>
                            <option value="OITAVO_ANO">OITAVO_ANO</option>
                            <option value="NONO_ANO">NONO_ANO</option>
                            <option value="PRIMEIRA_SERIE">PRIMEIRA_SERIE</option>
                            <option value="SEGUNDA_SERIE">SEGUNDA_SERIE</option>
                            <option value="TERCEIRA_SERIE">TERCEIRA_SERIE</option>
                        </select>
                    </div>
                    <div>
              <label
                for="linkShift"
                class="block text-sm font-medium text-gray-700"
                >Turno</label
              >
              <select
                id="linkShift"
                name="linkShift"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione o turno</option>
                            <option value="MANHA">Matutino</option>
                            <option value="TARDE">Vespertino</option>
                            <option value="NOITE">Noturno</option>
                        </select>
                    </div>
                    <div>
              <label
                for="linkClass"
                class="block text-sm font-medium text-gray-700"
                >Turma</label
              >
              <select
                id="linkClass"
                name="linkClass"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione uma turma</option>
                        </select>
                    </div>
                    <div class="flex justify-end">
              <button
                type="button"
                id="cancelLinkBtn"
                class="mr-3 bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
              >
                            Cancelar
                        </button>
              <button
                type="submit"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                            Vincular
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Novos modais para criar prova por etapas -->
        <!-- Etapa 1: Criar prova (informações básicas) -->
      <div
        id="createExamStepOneModal"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-lg mx-auto my-4"
        >
                <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-medium text-gray-900">
              Criar Nova Prova - Etapa 1
            </h3>
            <button
              id="closeCreateExamStepOneModal"
              class="text-gray-400 hover:text-gray-500"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <form id="createExamStepOneForm" class="space-y-4">
                    <div>
              <label
                for="newExamName"
                class="block text-sm font-medium text-gray-700"
                >Nome da Prova</label
              >
              <input
                type="text"
                id="newExamName"
                name="newExamName"
                required
                class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              />
                    </div>
                    <div>
              <label
                for="newExamDescription"
                class="block text-sm font-medium text-gray-700"
                >Descrição (opcional)</label
              >
              <textarea
                id="newExamDescription"
                name="newExamDescription"
                rows="2"
                class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
              ></textarea>
                    </div>
                    <div>
              <label
                for="newExamEducationLevel"
                class="block text-sm font-medium text-gray-700"
                >Nível de Ensino</label
              >
              <select
                id="newExamEducationLevel"
                name="newExamEducationLevel"
                required
                class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
              >
                            <option value="">Selecione</option>
                            <option value="ANOS_INICIAIS">ANOS_INICIAIS</option>
                            <option value="ANOS_FINAIS">ANOS_FINAIS</option>
                            <option value="ENSINO_MEDIO">ENSINO_MEDIO</option>
                        </select>
                    </div>
                    
                    <div class="flex justify-end">
              <button
                type="button"
                id="cancelCreateExamStepOneBtn"
                class="mr-3 bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
              >
                            Cancelar
                        </button>
              <button
                type="submit"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                            Continuar para Questões
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Etapa 2: Adicionar questão -->
      <div
        id="addQuestionModal"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-3xl mx-auto my-4 modal-overflow"
        >
                <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-medium text-gray-900">
              Adicionar Questão - <span id="questionNumber">1</span>
            </h3>
            <button
              id="closeAddQuestionModal"
              class="text-gray-400 hover:text-gray-500"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <form id="addQuestionForm" class="space-y-4">
                    <div>
              <label class="block text-sm font-medium text-gray-700"
                >Enunciado</label
              >
              <textarea
                id="questionText"
                class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                rows="3"
                required
              ></textarea>
                    </div>
                    
                    <!-- Imagem da questão -->
                    <div>
              <label class="block text-sm font-medium text-gray-700"
                >Imagem (opcional)</label
              >
                        <div class="mt-1 flex items-center">
                <input
                  type="file"
                  accept="image/*"
                  id="questionImage"
                  class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                />
                        </div>
                        <div class="mt-2 image-preview hidden">
                <img src="" alt="Preview" class="max-h-48 rounded" />
                <button
                  type="button"
                  class="remove-image mt-1 text-xs text-red-600 hover:text-red-900"
                >
                                <i class="fas fa-times mr-1"></i> Remover imagem
                            </button>
                        </div>
                    </div>
                    
                    <!-- Metadados da questão -->
            <div
              class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50 rounded-md"
            >
                        <div>
                <label class="block text-sm font-medium text-gray-700"
                  >Nível de ensino</label
                >
                <select
                  id="educationLevel"
                  class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                >
                                <option value="">Selecione</option>
                                <option value="ANOS_INICIAIS">ANOS_INICIAIS</option>
                                <option value="ANOS_FINAIS">ANOS_FINAIS</option>
                                <option value="ENSINO_MEDIO">ENSINO_MEDIO</option>
                            </select>
                        </div>
                        <div>
                <label class="block text-sm font-medium text-gray-700"
                  >Série</label
                >
                <select
                  id="gradeLevel"
                  class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                >
                                <option value="">Selecione</option>
                                <option value="PRIMEIRO_ANO">PRIMEIRO_ANO</option>
                                <option value="SEGUNDO_ANO">SEGUNDO_ANO</option>
                                <option value="TERCEIRO_ANO">TERCEIRO_ANO</option>
                                <option value="QUARTO_ANO">QUARTO_ANO</option>
                                <option value="QUINTO_ANO">QUINTO_ANO</option>
                                <option value="SEXTO_ANO">SEXTO_ANO</option>
                                <option value="SETIMO_ANO">SETIMO_ANO</option>
                                <option value="OITAVO_ANO">OITAVO_ANO</option>
                                <option value="NONO_ANO">NONO_ANO</option>
                                <option value="PRIMEIRA_SERIE">PRIMEIRA_SERIE</option>
                                <option value="SEGUNDA_SERIE">SEGUNDA_SERIE</option>
                                <option value="TERCEIRA_SERIE">TERCEIRA_SERIE</option>
                            </select>
                        </div>
                        <div>
                <label class="block text-sm font-medium text-gray-700"
                  >Dificuldade</label
                >
                <select
                  id="difficultyLevel"
                  class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                >
                                <option value="">Selecione</option>
                                <option value="FACIL">Fácil</option>
                                <option value="MEDIO">Médio</option>
                                <option value="DIFICIL">Difícil</option>
                            </select>
                        </div>
                        <div>
                <label class="block text-sm font-medium text-gray-700"
                  >Componente curricular</label
                >
                <select
                  id="curriculumComponent"
                  class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                >
                                <option value="">Selecione</option>
                                <option value="1">Língua Portuguesa</option>
                                <option value="2">Matemática</option>
                                <option value="3">Ciências</option>
                                <option value="4">História</option>
                                <option value="5">Geografia</option>
                                <option value="6">Educação Física</option>
                                <option value="7">Arte</option>
                                <option value="8">Inglês</option>
                            </select>
                        </div>
                        <div class="md:col-span-2">
                <label class="block text-sm font-medium text-gray-700"
                  >Habilidades BNCC</label
                >
                            <div class="mb-4">
                                <label class="block text-gray-700 text-sm font-bold mb-2">
                    Habilidades BNCC
                    <span
                      class="selected-skills-count text-gray-500 text-xs"
                    ></span>
                                </label>
                  <div
                    class="border border-gray-300 rounded-md p-2 bg-white relative"
                  >
                                    <div class="selected-skills-list space-y-1 mb-2"></div>
                    <button
                      type="button"
                      id="newSelectBnccBtn"
                      class="w-full py-2 px-3 border border-gray-300 bg-gray-100 rounded-md text-sm text-left text-gray-700 hover:bg-gray-200 focus:outline-none"
                    >
                      <i class="fas fa-plus-circle mr-2"></i> Selecionar
                      habilidades BNCC
                                    </button>
                    <input
                      type="hidden"
                      id="bnccCodes"
                      class="bncc-codes-input"
                    />
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Alternativas -->
                    <div>
              <label class="block text-sm font-medium text-gray-700 mb-2"
                >Alternativas</label
              >
                        <div class="space-y-3">
                            <div class="flex items-center mt-1">
                  <input
                    type="radio"
                    name="correctAnswer"
                    value="A"
                    class="mr-2"
                    required
                  />
                                <span class="font-medium w-8">A)</span>
                  <input
                    type="text"
                    id="optionA"
                    class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Alternativa A"
                    required
                  />
                            </div>
                            <div class="flex items-center mt-1">
                  <input
                    type="radio"
                    name="correctAnswer"
                    value="B"
                    class="mr-2"
                  />
                                <span class="font-medium w-8">B)</span>
                  <input
                    type="text"
                    id="optionB"
                    class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Alternativa B"
                    required
                  />
                            </div>
                            <div class="flex items-center mt-1">
                  <input
                    type="radio"
                    name="correctAnswer"
                    value="C"
                    class="mr-2"
                  />
                                <span class="font-medium w-8">C)</span>
                  <input
                    type="text"
                    id="optionC"
                    class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Alternativa C"
                    required
                  />
                            </div>
                            <div class="flex items-center mt-1">
                  <input
                    type="radio"
                    name="correctAnswer"
                    value="D"
                    class="mr-2"
                  />
                                <span class="font-medium w-8">D)</span>
                  <input
                    type="text"
                    id="optionD"
                    class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Alternativa D"
                    required
                  />
                            </div>
                            <div class="flex items-center mt-1">
                  <input
                    type="radio"
                    name="correctAnswer"
                    value="E"
                    class="mr-2"
                  />
                                <span class="font-medium w-8">E)</span>
                  <input
                    type="text"
                    id="optionE"
                    class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                    placeholder="Alternativa E"
                    required
                  />
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-end space-x-2">
              <button
                type="button"
                id="cancelAddQuestionBtn"
                class="bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
              >
                            Cancelar
                        </button>
              <button
                type="submit"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                            Salvar Questão
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Modal de opções após adicionar questão -->
      <div
        id="questionOptionsModal"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4"
        >
                <div class="flex justify-between items-center mb-6">
            <h3 class="text-lg font-medium text-gray-900">
              Questão Adicionada
            </h3>
            <button
              id="closeQuestionOptionsModal"
              class="text-gray-400 hover:text-gray-500"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="mb-6 text-center">
                    <div class="text-green-500 text-4xl mb-4">
                        <i class="fas fa-check-circle"></i>
                    </div>
                    <p class="text-gray-700">A questão foi adicionada com sucesso.</p>
            <p class="text-gray-600 text-sm mt-2">
              Total de questões: <span id="totalQuestionsCount">1</span>
            </p>
                </div>
                <div class="flex justify-center space-x-4">
            <button
              id="addAnotherQuestionBtn"
              class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
                        <i class="fas fa-plus mr-2"></i> Adicionar Outra Questão
                    </button>
            <button
              id="finalizeExamBtnModal"
              class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
            >
                        Finalizar Avaliação
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Modal para seleção de habilidades BNCC -->
      <div
        id="bnccModal"
        class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg w-full max-w-3xl mx-auto my-4 flex flex-col modal-overflow"
          style="max-height: 90vh"
        >
                <div class="p-4 border-b flex justify-between items-center">
            <h3 class="text-lg font-bold text-gray-900">
              Selecionar Habilidades BNCC
            </h3>
            <button
              id="closeBnccModal"
              class="text-gray-500 hover:text-gray-700"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 overflow-y-auto flex-1">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Componente Curricular
                            </label>
                <select
                  id="bnccComponent"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Selecione</option>
                                <option value="Português">Língua Portuguesa</option>
                                <option value="Matemática">Matemática</option>
                                <option value="Ciências">Ciências</option>
                                <option value="História">História</option>
                                <option value="Geografia">Geografia</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Série
                            </label>
                <select
                  id="bnccGrade"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Selecione</option>
                                <option value="PRIMEIRO_ANO">PRIMEIRO_ANO</option>
                                <option value="SEGUNDO_ANO">SEGUNDO_ANO</option>
                                <option value="TERCEIRO_ANO">TERCEIRO_ANO</option>
                                <option value="QUARTO_ANO">QUARTO_ANO</option>
                                <option value="QUINTO_ANO">QUINTO_ANO</option>
                                <option value="SEXTO_ANO">SEXTO_ANO</option>
                                <option value="SETIMO_ANO">SETIMO_ANO</option>
                                <option value="OITAVO_ANO">OITAVO_ANO</option>
                                <option value="NONO_ANO">NONO_ANO</option>
                                <option value="PRIMEIRA_SERIE">PRIMEIRA_SERIE</option>
                                <option value="SEGUNDA_SERIE">SEGUNDA_SERIE</option>
                                <option value="TERCEIRA_SERIE">TERCEIRA_SERIE</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="relative">
                <div
                  class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"
                >
                                <i class="fas fa-search text-gray-400"></i>
                            </div>
                <input
                  id="bnccSearch"
                  type="text"
                  placeholder="Pesquisar por código ou descrição..."
                  class="shadow appearance-none border rounded w-full py-2 pl-10 pr-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                />
                        </div>
                    </div>
                    
                    <div class="flex justify-between items-center mb-2">
                        <div class="text-sm">
                <button
                  id="selectAllBtn"
                  class="text-blue-600 hover:text-blue-800 mr-3"
                >
                                <i class="fas fa-check-square mr-1"></i> Selecionar todas
                            </button>
                <button
                  id="deselectAllBtn"
                  class="text-blue-600 hover:text-blue-800"
                >
                                <i class="fas fa-square mr-1"></i> Desmarcar todas
                            </button>
                        </div>
                    </div>
                    
            <div
              class="border border-gray-200 rounded-md p-2 overflow-y-auto"
              style="max-height: 300px"
            >
                        <div id="bnccSkillsList" class="space-y-2">
                            <div class="text-center text-gray-500 py-4">
                  Selecione um componente curricular e série para ver as
                  habilidades disponíveis
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="border-t p-4 flex justify-between items-center">
                    <div class="text-sm text-gray-500">
                        <span id="selectedSkillsCount">0</span> habilidades selecionadas
                    </div>
                    <div class="flex space-x-2">
              <button
                id="cancelBnccBtn"
                class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-100"
              >
                            Cancelar
                        </button>
              <button
                id="confirmBnccBtn"
                class="px-4 py-2 bg-blue-600 border border-blue-600 rounded-md text-white hover:bg-blue-700"
              >
                            Confirmar
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modal para seleção de questões do banco -->
      <div
        id="questionBankModal"
        class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden p-4 overflow-auto"
      >
        <div
          class="bg-white rounded-lg w-full max-w-5xl mx-auto my-4 flex flex-col modal-overflow"
          style="max-height: 90vh"
        >
                <div class="p-4 border-b flex justify-between items-center">
                    <h3 class="text-lg font-bold text-gray-900">Banco de Questões</h3>
            <button
              id="closeQuestionBankModal"
              class="text-gray-500 hover:text-gray-700"
            >
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="p-4 overflow-y-auto flex-1">
                    <!-- Filtros -->
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Componente Curricular
                            </label>
                <select
                  id="bankComponent"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Todos</option>
                                <option value="1">Língua Portuguesa</option>
                                <option value="2">Matemática</option>
                                <option value="3">Ciências</option>
                                <option value="4">História</option>
                                <option value="5">Geografia</option>
                                <option value="6">Educação Física</option>
                                <option value="7">Arte</option>
                                <option value="8">Inglês</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Série
                            </label>
                <select
                  id="bankGrade"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Todas</option>
                                <option value="PRIMEIRO_ANO">PRIMEIRO_ANO</option>
                                <option value="SEGUNDO_ANO">SEGUNDO_ANO</option>
                                <option value="TERCEIRO_ANO">TERCEIRO_ANO</option>
                                <option value="QUARTO_ANO">QUARTO_ANO</option>
                                <option value="QUINTO_ANO">QUINTO_ANO</option>
                                <option value="SEXTO_ANO">SEXTO_ANO</option>
                                <option value="SETIMO_ANO">SETIMO_ANO</option>
                                <option value="OITAVO_ANO">OITAVO_ANO</option>
                                <option value="NONO_ANO">NONO_ANO</option>
                                <option value="PRIMEIRA_SERIE">PRIMEIRA_SERIE</option>
                                <option value="SEGUNDA_SERIE">SEGUNDA_SERIE</option>
                                <option value="TERCEIRA_SERIE">TERCEIRA_SERIE</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Dificuldade
                            </label>
                <select
                  id="bankDifficulty"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Todas</option>
                                <option value="FACIL">Fácil</option>
                                <option value="MEDIO">Médio</option>
                                <option value="DIFICIL">Difícil</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">
                                Nível de Ensino
                            </label>
                <select
                  id="bankEducationLevel"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                >
                                <option value="">Todos</option>
                                <option value="ANOS_INICIAIS">ANOS_INICIAIS</option>
                                <option value="ANOS_FINAIS">ANOS_FINAIS</option>
                                <option value="ENSINO_MEDIO">ENSINO_MEDIO</option>
                            </select>
                        </div>
                        <div class="flex items-end">
                <button
                  id="applyFiltersBtn"
                  class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full"
                >
                                <i class="fas fa-filter mr-2"></i> Filtrar
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="relative">
                <div
                  class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"
                >
                                <i class="fas fa-search text-gray-400"></i>
                            </div>
                <input
                  id="bankSearch"
                  type="text"
                  placeholder="Pesquisar questões..."
                  class="shadow appearance-none border rounded w-full py-2 pl-10 pr-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                />
                        </div>
                    </div>
                    
                    <!-- Lista de questões -->
            <div
              class="border border-gray-200 rounded-md overflow-y-auto"
              style="max-height: 400px"
            >
                        <div id="questionBankList" class="divide-y divide-gray-200">
                            <div class="text-center text-gray-500 py-8">
                                <p>Nenhuma questão encontrada no banco.</p>
                  <p class="mt-2 text-sm">
                    As questões que você adicionar às provas serão salvas
                    automaticamente no banco.
                  </p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="border-t p-4 flex justify-between items-center">
                    <div class="text-sm text-gray-500">
                        <span id="selectedQuestionsCount">0</span> questões selecionadas
                    </div>
                    <div class="flex space-x-2">
              <button
                id="cancelQuestionBankBtn"
                class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-100"
              >
                            Cancelar
                        </button>
              <button
                id="confirmQuestionBankBtn"
                class="px-4 py-2 bg-blue-600 border border-blue-600 rounded-md text-white hover:bg-blue-700"
              >
                            Adicionar Questões
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div
      id="successModal"
      class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
    >
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4">
            <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-medium text-gray-900" id="successModalTitle">
            Operação Concluída
          </h3>
          <button
            id="closeSuccessModal"
            class="text-gray-400 hover:text-gray-500"
          >
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mb-6 text-center">
                <div class="text-green-500 text-4xl mb-4">
                    <i class="fas fa-check-circle"></i>
                </div>
          <p class="text-gray-700" id="successModalMessage">
            Operação realizada com sucesso!
          </p>
            </div>
            <div class="flex justify-center">
          <button
            id="successModalOkBtn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
                    OK
                </button>
            </div>
        </div>
    </div>
    <!-- Modal -->
<div id="modalProva" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 overflow-y-auto h-full w-full">
  <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <!-- Cabeçalho -->
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-2xl font-bold text-gray-800">Questões da Prova</h3>
      <button onclick="fecharModal()" class="text-gray-500 hover:text-gray-700">&times;</button>
    </div>
    
    <!-- Conteúdo das questões -->
    <div id="questoesContainer" class="space-y-4 max-h-96 overflow-y-auto">
      <!-- As questões serão inseridas aqui via JavaScript -->
    </div>
    
    <!-- Loading -->
    <div id="loading" class="text-center py-4 hidden">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
    </div>
  </div>
</div>
<script>
    function visualizarProva(provaId) {    console.log("ID da prova visualizada:", provaId);    const modal = document.getElementById('modalProva');    const loading = document.getElementById('loading');    const questoesContainer = document.getElementById('questoesContainer');        modal.classList.remove('hidden');    loading.classList.remove('hidden');    questoesContainer.innerHTML = '';        fetch(`https://sag-sag.rak8a3.easypanel.host/api/provas/${provaId}/questoes-detalhadas`)      .then(response => response.json())      .then(data => {        if (data.questoes && data.questoes.length > 0) {          questoesContainer.innerHTML = data.questoes.map((questao, index) => `            <div class="p-4 border rounded-lg">              <h4 class="font-semibold mb-2">Questão ${index + 1}</h4>              <p class="text-gray-600 mb-3">${questao.enunciado}</p>              <ul class="space-y-2">                ${questao.alternativas.map(alt => `                  <li class="${alt.correta ? 'bg-green-100 border-l-4 border-green-500' : ''} p-2 rounded">                    ${alt.texto}                  </li>                `).join('')}              </ul>            </div>          `).join('');
        } else {
          questoesContainer.innerHTML = '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
        }
      })
      .catch(error => {
        console.error('Erro:', error);
        questoesContainer.innerHTML = '<p class="text-center text-red-500">Erro ao carregar questões</p>';
      })
      .finally(() => {
        loading.classList.add('hidden');
      });
  }
  
  function fecharModal() {
    document.getElementById('modalProva').classList.add('hidden');
  }
  
  // Fechar modal ao clicar fora
  window.onclick = function(event) {
    const modal = document.getElementById('modalProva');
    if (event.target === modal) {
      fecharModal();
    }
  }
  </script>
    <script src="js/app.js"></script>
    <script src="js/alert.js"></script>
    <script>
        // Global variables para gerenciamento de habilidades BNCC
        let selectedSkills = [];
        let activeInputElement = null;

        // Base de dados de habilidades BNCC
        const bnccDatabase = {
        Português: {
          PRIMEIRO_ANO: [
            {
              code: "EF01LP01",
              description:
                "Reconhecer que textos são lidos e escritos da esquerda para a direita e de cima para baixo da página.",
            },
            {
              code: "EF01LP02",
              description:
                "Escrever, espontaneamente ou por ditado, palavras e frases de forma alfabética – usando letras/grafemas que representem fonemas.",
            },
            {
              code: "EF01LP03",
              description:
                "Observar escritas convencionais, comparando-as às suas produções escritas, percebendo semelhanças e diferenças.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02LP01",
              description:
                "Utilizar, ao produzir o texto, grafia correta de palavras conhecidas ou com estruturas silábicas já dominadas, letras maiúsculas em início de frases e em substantivos próprios, segmentação entre as palavras, ponto final, ponto de interrogação e ponto de exclamação.",
            },
            {
              code: "EF02LP02",
              description:
                "Segmentar palavras em sílabas e remover e substituir sílabas iniciais, mediais ou finais para criar novas palavras.",
            },
            {
              code: "EF02LP03",
              description:
                "Ler e escrever palavras com correspondências regulares diretas entre letras e fonemas (f, v, t, d, p, b) e correspondências regulares contextuais (c e q; e e o, em posição átona em final de palavra).",
            },
          ],
        },
        Matemática: {
          PRIMEIRO_ANO: [
            {
              code: "EF01MA01",
              description:
                "Utilizar números naturais como indicador de quantidade ou de ordem em diferentes situações cotidianas e reconhecer situações em que os números não indicam contagem nem ordem, mas sim código de identificação.",
            },
            {
              code: "EF01MA02",
              description:
                "Contar de maneira exata ou aproximada, utilizando diferentes estratégias como o pareamento e outros agrupamentos.",
            },
            {
              code: "EF01MA03",
              description:
                'Estimar e comparar quantidades de objetos de dois conjuntos (em torno de 20 elementos), por estimativa e/ou por correspondência (um a um, dois a dois) para indicar "tem mais", "tem menos" ou "tem a mesma quantidade".',
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02MA01",
              description:
                "Comparar e ordenar números naturais (até a ordem de centenas) pela compreensão de características do sistema de numeração decimal (valor posicional e função do zero).",
            },
            {
              code: "EF02MA02",
              description:
                "Fazer estimativas por meio de estratégias diversas a respeito da quantidade de objetos de coleções e registrar o resultado da contagem desses objetos (até 1000 unidades).",
            },
            {
              code: "EF02MA03",
              description:
                'Comparar quantidades de objetos de dois conjuntos, por estimativa e/ou por correspondência (um a um, dois a dois, entre outros), para indicar "tem mais", "tem menos" ou "tem a mesma quantidade", indicando, quando for o caso, quantos a mais e quantos a menos.',
            },
          ],
        },
        Ciências: {
          PRIMEIRO_ANO: [
            {
              code: "EF01CI01",
              description:
                "Comparar características de diferentes materiais presentes em objetos de uso cotidiano.",
            },
            {
              code: "EF01CI02",
              description:
                "Localizar, nomear e representar graficamente (por meio de desenhos) partes do corpo humano e explicar suas funções.",
            },
            {
              code: "EF01CI03",
              description:
                "Discutir as razões pelas quais os hábitos de higiene do corpo são necessários para a manutenção da saúde.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02CI01",
              description:
                "Identificar de que materiais (metais, madeira, vidro etc.) são feitos os objetos que fazem parte da vida cotidiana.",
            },
            {
              code: "EF02CI02",
              description:
                "Propor o uso de diferentes materiais para a construção de objetos de uso cotidiano.",
            },
            {
              code: "EF02CI03",
              description:
                "Discutir os cuidados necessários à prevenção de acidentes domésticos.",
            },
          ],
        },
      };

      document.addEventListener("DOMContentLoaded", function () {
            // Mobile menu toggle
        const mobileMenuBtn = document.getElementById("mobileMenuBtn");
        const mobileMenu = document.getElementById("mobileMenu");
            
            if (mobileMenuBtn && mobileMenu) {
          mobileMenuBtn.addEventListener("click", function () {
            mobileMenu.classList.toggle("hidden");
                });
            }
            
            // Atualizar nome do usuário
        const currentUser = JSON.parse(sessionStorage.getItem("currentUser"));
            if (currentUser) {
          document.getElementById("userName").textContent = currentUser.name;
            }
            
            // Inicializar localStorage para exams se não existir
        if (!localStorage.getItem("exams")) {
          localStorage.setItem("exams", JSON.stringify([]));
            }
            
            // Verificar se é modo de edição
            const urlParams = new URLSearchParams(window.location.search);
        const editExamId = urlParams.get("edit");
            
            if (editExamId) {
                openExamForEditing(parseInt(editExamId));
            }
            
            // Buscar provas da API
            loadExamsFromAPI();
            
            // Adicionar eventos para botões principais
            setupMainButtons();
            
            // Carregar componentes curriculares da API
            loadCurriculumComponentsFromAPI();
            
            // Configurar modal BNCC
        const closeBnccModalBtn = document.getElementById("closeBnccModal");
        const cancelBnccBtn = document.getElementById("cancelBnccBtn");
        const confirmBnccBtn = document.getElementById("confirmBnccBtn");
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const deselectAllBtn = document.getElementById("deselectAllBtn");
        const newSelectBnccBtn = document.getElementById("newSelectBnccBtn");

        if (closeBnccModalBtn)
          closeBnccModalBtn.addEventListener("click", closeBnccModal);
        if (cancelBnccBtn)
          cancelBnccBtn.addEventListener("click", closeBnccModal);
        if (confirmBnccBtn)
          confirmBnccBtn.addEventListener("click", confirmBnccSelection);
        if (bnccComponent)
          bnccComponent.addEventListener("change", updateBnccSkillsList);
        if (bnccGrade)
          bnccGrade.addEventListener("change", updateBnccSkillsList);
        if (bnccSearch) bnccSearch.addEventListener("input", filterBnccSkills);
        if (selectAllBtn)
          selectAllBtn.addEventListener("click", selectAllSkills);
        if (deselectAllBtn)
          deselectAllBtn.addEventListener("click", deselectAllSkills);
        if (newSelectBnccBtn)
          newSelectBnccBtn.addEventListener("click", openBnccSelector);
            
            // Configurar eventos para seletores BNCC em questões existentes
        document.querySelectorAll(".select-bncc-btn").forEach((btn) => {
          btn.addEventListener("click", openBnccSelector);
            });
            
            // Configurar uploads de imagem
            setupImageUploads();
            
            // Configurar botões adicionais para criar prova
        const addAnotherQuestionBtn = document.getElementById(
          "addAnotherQuestionBtn"
        );
            if (addAnotherQuestionBtn) {
          addAnotherQuestionBtn.addEventListener("click", addAnotherQuestion);
            }
            
        const finalizeExamBtnModal = document.getElementById(
          "finalizeExamBtnModal"
        );
            if (finalizeExamBtnModal) {
          finalizeExamBtnModal.addEventListener("click", finalizeExam);
            }
        });
        
        // Variáveis globais para o fluxo de criação de prova
        let currentExamData = {
        name: "",
        description: "",
        questions: [],
        };
        
        function setupMainButtons() {
            // Botão Criar Avaliação
        const createExamBtn = document.getElementById("createExamBtn");
            if (createExamBtn) {
          console.log("Adicionando evento de click ao botão Criar Avaliação");
          createExamBtn.addEventListener("click", function () {
            console.log("Botão Criar Avaliação clicado");
                    // Limpar dados da prova atual
                    currentExamData = {
              name: "",
              description: "",
              questions: [],
            };
            document
              .getElementById("createExamStepOneModal")
              .classList.remove("hidden");
                });
            }
            
            // Botão Vincular Prova
        const linkExamBtn = document.getElementById("linkExamBtn");
            if (linkExamBtn) {
          linkExamBtn.addEventListener("click", async function () {
            document.getElementById("linkExamModal").classList.remove("hidden");
                    
                    try {
                        // Configurar opções de série e turno
                        setupGradeAndShiftOptions();
                        
                        // Utilizar a função populateExamSelector para buscar provas da API
                        await populateExamSelector();
                        
                        // Utilizar a função populateSchoolSelector para buscar escolas da API
                        await populateSchoolSelector();
                    } catch (error) {
              console.error(
                "Erro ao preparar formulário de vinculação:",
                error
              );
              alert("Erro ao carregar dados para vinculação: " + error.message);
                    }
                });
            }
            
            // Botão Exportar Todas
        const exportAllExamsBtn = document.getElementById("exportAllExamsBtn");
            if (exportAllExamsBtn) {
          exportAllExamsBtn.addEventListener("click", exportAllExams);
            }
            
            // Botão Banco de Questões
        const questionBankBtn = document.getElementById("questionBankBtn");
            if (questionBankBtn) {
          questionBankBtn.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.remove("hidden");
                    loadQuestionBank();
                });
            }
            
            // Botão para adicionar questão no formulário principal
        const addQuestionBtn = document.getElementById("addQuestionBtn");
            if (addQuestionBtn) {
          addQuestionBtn.addEventListener("click", function () {
                    // Adicionar lógica para adicionar uma nova questão ao formulário
            alert(
              "Funcionalidade para adicionar questão no formulário principal"
            );
                });
            }
            
            // Botão de fechar o modal de examModal
        const closeExamModal = document.getElementById("closeExamModal");
            if (closeExamModal) {
          closeExamModal.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botão para cancelar adição de exame
        const cancelExamBtn = document.getElementById("cancelExamBtn");
            if (cancelExamBtn) {
          cancelExamBtn.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botões de fechamento de modais
            setupModalCloseButtons();
            
            // Configurar formulários
            setupFormSubmissions();
        }
        
        // Função para configurar opções de série e turno
        function setupGradeAndShiftOptions() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        function setupModalCloseButtons() {
            // Modal Criar Avaliação - Etapa 1
        document
          .getElementById("closeCreateExamStepOneModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelCreateExamStepOneBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
            });
            
            // Modal Adicionar Questão
        document
          .getElementById("closeAddQuestionModal")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
          });

        document
          .getElementById("cancelAddQuestionBtn")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
            });
            
            // Modal Opções de Questão
        document
          .getElementById("closeQuestionOptionsModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionOptionsModal")
              .classList.add("hidden");
            });
            
            // Modal Banco de Questões
        document
          .getElementById("closeQuestionBankModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelQuestionBankBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
            });
            
            // Modal Vincular Prova
        document
          .getElementById("closeLinkExamModal")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
          });

        document
          .getElementById("cancelLinkBtn")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
            });
        }
        
        function setupFormSubmissions() {
            // Formulário Etapa 1 - Informações Básicas
        const createExamStepOneForm = document.getElementById(
          "createExamStepOneForm"
        );
            if (createExamStepOneForm) {
          createExamStepOneForm.addEventListener("submit", function (e) {
                    e.preventDefault();
                    
                    // Obter dados do formulário
            const examName = document.getElementById("newExamName").value;
            const examDescription =
              document.getElementById("newExamDescription").value;
            const examEducationLevel = document.getElementById(
              "newExamEducationLevel"
            ).value;
                    
                    if (!examName) {
              alert("Por favor, insira um nome para a prova.");
                        return;
                    }
                    
                    if (!examEducationLevel) {
              alert("Por favor, selecione um nível de ensino.");
                        return;
                    }
                    
                    // Verificar se é edição ou criação
                    const isEditing = currentExamData.id !== undefined;
                    
                    // Atualizar dados da prova
                    currentExamData.name = examName;
                    currentExamData.description = examDescription;
                    currentExamData.educationLevel = examEducationLevel;
                    
            console.log(
              `${isEditing ? "Editando" : "Criando"} prova:`,
              currentExamData
            );
                    
                    // Se for edição, atualizar a prova no armazenamento
                    if (isEditing) {
              updateExam(currentExamData).then((success) => {
                            if (success) {
                                // Fechar modal
                  document
                    .getElementById("createExamStepOneModal")
                    .classList.add("hidden");
                                
                                // Atualizar lista de provas
                                loadExamsFromAPI();
                                
                                // Mostrar modal de sucesso
                  showSuccessModal(
                    "Avaliação Atualizada",
                    "A avaliação foi atualizada com sucesso!"
                  );
                            } else {
                  alert("Erro ao atualizar avaliação.");
                            }
                        });
                    } else {
                        // Processar para a próxima etapa (criação de nova prova)
              document
                .getElementById("createExamStepOneModal")
                .classList.add("hidden");
              document
                .getElementById("addQuestionModal")
                .classList.remove("hidden");
              document.getElementById("questionNumber").textContent = "1";
                        
                        // Limpar formulário de questão
              document.getElementById("addQuestionForm").reset();
                        
                        // Limpar preview de imagem se existir
              const imagePreview = document.querySelector(
                "#addQuestionModal .image-preview"
              );
                        if (imagePreview) {
                imagePreview.classList.add("hidden");
                const img = imagePreview.querySelector("img");
                if (img) img.src = "";
                        }
                    }
                });
            }
            
            // Formulário Adicionar Questão
        const addQuestionForm = document.getElementById("addQuestionForm");
            if (addQuestionForm) {
          addQuestionForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            if (!document.getElementById("questionText").value) {
              alert("Por favor, insira o texto da questão.");
                        return;
                    }
                    
            if (
              !document.querySelector('input[name="correctAnswer"]:checked')
            ) {
              alert("Por favor, selecione a alternativa correta.");
                        return;
                    }

                    try {
                        // Obter o texto da questão
              const enunciado = document.getElementById("questionText").value;
                        
                        // Obter valor de imagem (se existir)
              const fileInput = document.querySelector("#questionImage");
              const imagePreview = document.querySelector("#addQuestionModal .image-preview");
              const imagem_url = fileInput && fileInput.files[0] ? fileInput.files[0].name : "";
            
              console.log("Caminho da imagem a ser enviada:", imagem_url);
                        
                        // Obter o nível de ensino (usar valor direto da API)
              const nivel_ensino = document.getElementById("educationLevel").value;
                        
                        // Obter série
              const serie = document.getElementById("gradeLevel").value;
                        
                        // Obter dificuldade
              const dificuldade =
                document.getElementById("difficultyLevel").value;
                        
                        // Obter componente curricular ID (deve ser um número)
              const componente_curricular_id = parseInt(
                document.getElementById("curriculumComponent").value,
                10
              );
                        
                        // Processar códigos BNCC (devem ser um array de números)
              const bnccCodesInput = document.getElementById("bnccCodes");
              let codigos_bncc = [];

              if (bnccCodesInput && bnccCodesInput.value) {
                  try {
                      codigos_bncc = JSON.parse(bnccCodesInput.value);
                  } catch (e) {
                      console.warn("Erro ao processar códigos BNCC:", e);
                  }
              }
                        
                        // Obter a resposta correta
              const correctAnswer = document.querySelector(
                'input[name="correctAnswer"]:checked'
              ).value;
                        
                        // Criar array de alternativas
                        const alternativas = [];
                        
                        // Adicionar cada alternativa ao array (apenas se tiver texto)
              const optionA = document.getElementById("optionA").value.trim();
                        if (optionA) {
                            alternativas.push({
                                texto: optionA,
                  correta: correctAnswer === "A",
                            });
                        }
                        
              const optionB = document.getElementById("optionB").value.trim();
                        if (optionB) {
                            alternativas.push({
                                texto: optionB,
                  correta: correctAnswer === "B",
                            });
                        }
                        
              const optionC = document.getElementById("optionC").value.trim();
                        if (optionC) {
                            alternativas.push({
                                texto: optionC,
                  correta: correctAnswer === "C",
                            });
                        }
                        
              const optionD = document.getElementById("optionD").value.trim();
                        if (optionD) {
                            alternativas.push({
                                texto: optionD,
                  correta: correctAnswer === "D",
                            });
                        }
                        
              const optionE = document.getElementById("optionE").value.trim();
                        if (optionE) {
                            alternativas.push({
                                texto: optionE,
                  correta: correctAnswer === "E",
                            });
                        }
                        
                        // Obter ID da prova atual
              const prova_id = parseInt(currentExamData.apiId, 10);
                        
                        // Validar que temos um ID válido antes de prosseguir
                        if (isNaN(prova_id) || prova_id <= 0) {
                throw new Error(
                    "ID da prova é inválido ou não foi criado. Salve a prova primeiro."
                );
                        }
                        
                        // Construir o objeto da questão exatamente no formato solicitado
                        const questionData = {
                            enunciado,
                            imagem_url,
                            nivel_ensino,
                            dificuldade,
                            serie,
                            pontos: 1,
                            prova_id,
                            componente_curricular_id,
                            codigos_bncc,
                            alternativas,
                        };
                        
              console.log(
                "Enviando questão para API:",
                JSON.stringify(questionData, null, 2)
              );
                        
                        // Enviar a requisição para o endpoint
              const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
              const response = await fetch(`${baseUrl}/api/questoes`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(questionData),
            });
                        
                        if (!response.ok) {
                const errorText = await response
                  .text()
                  .catch(() => "Erro desconhecido");
                throw new Error(
                  `Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`
                );
                        }
                        
                        const savedQuestion = await response.json();
              console.log("Questão salva com sucesso:", savedQuestion);
                        
                        // Capturar dados da questão para o formato local (para histórico)
                        const questionDataLocal = {
                            text: enunciado,
                            educationLevel: nivel_ensino,
                            gradeLevel: serie,
                            difficultyLevel: dificuldade,
                            curriculumComponent: componente_curricular_id.toString(),
                            bnccCodes: codigos_bncc,
                            correctAnswer: correctAnswer,
                            options: {
                                A: optionA || '',
                                B: optionB || '',
                                C: optionC || '',
                                D: optionD || '',
                                E: optionE || ''
                            },
                            alternativas: alternativas.map(alt => ({
                                letra: alt.letra || "",
                                texto: alt.texto || "",
                                correta: (alt.letra || "").toUpperCase() === correctAnswer.toUpperCase()
                            })),
                            image: imagem_url,
                            apiId: savedQuestion.id,
                        };
                        
                        // Log para debug
                        console.log("Questão adicionada com alternativas:", JSON.stringify(questionDataLocal.options, null, 2));
                        
                        // Adicionar a questão à lista de questões
                        currentExamData.questions.push(questionDataLocal);
              console.log("Questão adicionada localmente:", questionDataLocal);
              console.log(
                `Total de questões: ${currentExamData.questions.length}`
              );
              console.log(
                `IMPORTANTE: Questão salva com ID da API: ${questionDataLocal.apiId}`
              );
              console.log("Estado atual das questões:");
                        currentExamData.questions.forEach((q, idx) => {
                console.log(
                  `  Questão ${idx + 1}: "${q.text.substring(
                    0,
                    30
                  )}..." - ID API: ${q.apiId || "não tem"}`
                );
                        });
                        
                        // Processar para a próxima etapa
              document
                .getElementById("addQuestionModal")
                .classList.add("hidden");
              document
                .getElementById("questionOptionsModal")
                .classList.remove("hidden");
              document.getElementById("totalQuestionsCount").textContent =
                currentExamData.questions.length;
                    } catch (error) {
              console.error("Erro ao salvar questão:", error);
                        alert(`Erro ao salvar questão: ${error.message}`);
                    }
                });
            }
            
            // Formulário Vincular Prova
        const linkExamForm = document.getElementById("linkExamForm");
            if (linkExamForm) {
          linkExamForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            const examId = document.getElementById("examSelect").value;
            const schoolId = document.getElementById("linkSchool").value;
            const grade = document.getElementById("linkGrade").value;
            const classId = document.getElementById("linkClass").value;
            const shift = document.getElementById("linkShift").value;
                    
                    if (!examId || !schoolId || !grade || !classId || !shift) {
              alert("Por favor, preencha todos os campos.");
                        return;
                    }
                    
                    // Desabilitar botão de submit e mostrar indicador de carregamento
                    const submitBtn = this.querySelector('button[type="submit"]');
                    const originalBtnText = submitBtn.innerHTML;
            submitBtn.innerHTML =
              '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
                    submitBtn.disabled = true;
                    
                    try {
                        // Enviar dados para a API com a rota correta
                        const payload = {
                            prova_id: examId,
                turma_id: classId,
                        };
                        
              console.log("Enviando dados para vincular prova:", payload);
                        
                        // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
              const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                        
                        // Enviar para a API
                        const response = await fetch(url, {
                method: "POST",
                            headers: {
                  "Content-Type": "application/json",
                            },
                body: JSON.stringify(payload),
                        });
                        
                        if (!response.ok) {
                throw new Error(
                  `Erro ao vincular prova. Status: ${response.status}`
                );
                        }
                        
                        // Fechar modal e mostrar mensagem de sucesso
              document.getElementById("linkExamModal").classList.add("hidden");
              alert("Prova vinculada com sucesso!");
                        
                        // Recarregar provas
                        loadExamsFromAPI();
                    } catch (error) {
              console.error("Erro ao vincular prova:", error);
              alert("Erro ao vincular prova: " + error.message);
                    } finally {
                        // Restaurar botão
                        submitBtn.innerHTML = originalBtnText;
                        submitBtn.disabled = false;
                    }
                });
            }
            
            // Alteração de escola no modal de vinculação
        document
          .getElementById("linkSchool")
          ?.addEventListener("change", async function () {
                const schoolId = this.value;
                if (!schoolId) return;
                
                try {
                    // Mostrar indicador de carregamento
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Carregando turmas...</option>';
                        classSelect.disabled = true;
                    }
                    
                    // Buscar turmas da API
              const response = await fetch(
                `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
                {
                  method: "GET",
                        headers: {
                    "Content-Type": "application/json",
                  },
                        }
              );
                    
                    if (!response.ok) {
                throw new Error(
                  `Erro ao carregar turmas. Status: ${response.status}`
                );
                    }
                    
                    const classes = await response.json();
                    
                    // Limpar seletor
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Selecione uma turma</option>';
                        
                        // Adicionar cada turma ao seletor
                classes.forEach((cls) => {
                  const option = document.createElement("option");
                            option.value = cls.id;
                            option.textContent = cls.nome || `Turma ${cls.id}`;
                            classSelect.appendChild(option);
                        });
                        
                        // Se não há turmas, mostrar mensagem
                        if (classes.length === 0) {
                  classSelect.innerHTML =
                    '<option value="">Nenhuma turma encontrada</option>';
                        }
                        
                        classSelect.disabled = false;
                    }
                } catch (error) {
              console.error("Erro ao buscar turmas:", error);
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Erro ao carregar turmas</option>';
                        classSelect.disabled = false;
                    }
                }
            });
        }

        // Função para adicionar outra questão
        function addAnotherQuestion() {
        document.getElementById("questionOptionsModal").classList.add("hidden");
        document.getElementById("addQuestionModal").classList.remove("hidden");
            
            // Incrementar número da questão
        const currentNumber = parseInt(
          document.getElementById("questionNumber").textContent || "1"
        );
        document.getElementById("questionNumber").textContent =
          currentNumber + 1;
            
            // Limpar formulário
        document.getElementById("addQuestionForm")?.reset();
            
            // Limpar preview de imagem se existir
        const imagePreview = document.querySelector(
          "#addQuestionModal .image-preview"
        );
            if (imagePreview) {
          imagePreview.classList.add("hidden");
          const img = imagePreview.querySelector("img");
          if (img) img.src = "";
            }
        }
        
        // Função para finalizar a criação da prova
        async function finalizeExam() {
            if (currentExamData.questions.length === 0) {
          alert(
            "Adicione pelo menos uma questão antes de finalizar a avaliação."
          );
                return;
            }
            
            // Mostrar indicador de processamento
        const finalizeBtn = document.getElementById("finalizeExamBtnModal");
            const originalBtnText = finalizeBtn.innerHTML;
        finalizeBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
            finalizeBtn.disabled = true;
            
            try {
          console.log(
            "Iniciando processo de finalização da prova:",
            currentExamData.name
          );
          console.log(
            `Total de questões a serem salvas: ${currentExamData.questions.length}`
          );
                
                // Verificar se a prova já foi criada (tem apiId)
                if (!currentExamData.apiId) {
            console.log("Prova ainda não foi criada na API. Criando agora...");
                    
                    // Determinar o nível de ensino no formato correto para a API
                    let nivelEnsino = "FUNDAMENTAL_I"; // Valor padrão
                    if (currentExamData.educationLevel) {
              switch (currentExamData.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "FUNDAMENTAL_I";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "FUNDAMENTAL_II";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "MEDIO";
                                break;
                            default:
                                nivelEnsino = "FUNDAMENTAL_I";
                        }
                    }
                    
                    // Criar a prova com dados básicos
                    const examData = {
                        nome: currentExamData.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: currentExamData.description || "",
                        nivel_ensino: nivelEnsino,
                        data_aplicacao: new Date().toISOString(),
              arquivo_url: "", // Campo obrigatório
                    };
                    
            console.log(
              "Payload para criação da prova:",
              JSON.stringify(examData, null, 2)
            );
                    
                    // 1. Primeiro, criar a prova sem questões
            const provaResponse = await fetch(
              "https://sag-sag.rak8a3.easypanel.host/api/provas",
              {
                method: "POST",
                        headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                        },
                body: JSON.stringify(examData),
              }
            );
                    
                    if (!provaResponse.ok) {
              const errorText = await provaResponse
                .text()
                .catch(() => "Erro desconhecido");
              throw new Error(
                `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
              );
                    }
                    
                    // Obter a prova criada
                    const savedExam = await provaResponse.json();
            console.log("Prova criada com sucesso. ID:", savedExam.id);
                    
                    if (!savedExam.id) {
              throw new Error(
                "A prova foi criada, mas não recebeu um ID válido da API"
              );
                    }
                    
                    // Atualizar o ID da API no exame atual
                    currentExamData.apiId = savedExam.id;
                } else {
            console.log(
              "Prova já existe na API com ID:",
              currentExamData.apiId
            );
                }
                
                // 2. Adicionar a prova ao armazenamento local
          const newExam = addExam(
            currentExamData.name,
            [],
            currentExamData.description,
            currentExamData.educationLevel
          );
                newExam.apiId = currentExamData.apiId;
                updateLocalExam(newExam);
          console.log(
            "Prova adicionada ao armazenamento local com ID da API:",
            newExam.apiId
          );
                
                // 3. Adicionar cada questão individualmente usando o endpoint /api/questoes
                const savedQuestions = [];
                const failedQuestions = [];
                
          console.log(
            `Começando a adicionar ${currentExamData.questions.length} questões...`
          );
                for (let i = 0; i < currentExamData.questions.length; i++) {
                    try {
                        const question = currentExamData.questions[i];
                        
                        // CORREÇÃO: Verificar se a questão já tem um ID da API (já foi salva)
                        if (question.apiId) {
                console.log(
                  `Questão ${i + 1}/${
                    currentExamData.questions.length
                  } já foi salva anteriormente com ID: ${question.apiId}`
                );
                            savedQuestions.push(question);
                            continue; // Pular para a próxima questão
                        }
                        
              console.log(
                `Adicionando questão ${i + 1}/${
                  currentExamData.questions.length
                }: "${question.text.substring(0, 30)}..."`
              );
                        
                        // Tentar salvar a questão usando saveQuestionToAPI
              const savedQuestion = await saveQuestionToAPI(
                question,
                currentExamData.apiId
              );
                        
                        if (savedQuestion && savedQuestion.apiId) {
                console.log(
                  `Questão ${i + 1} salva com sucesso, ID API: ${
                    savedQuestion.apiId
                  }`
                );
                            savedQuestions.push(savedQuestion);
                        } else {
                console.warn(
                  `Questão ${i + 1} foi processada, mas não retornou ID da API`
                );
                            // Ainda adicionar ao array para manter a consistência
                            savedQuestions.push(question);
                failedQuestions.push(i + 1);
                        }
                    } catch (error) {
              console.error(`Erro ao salvar questão ${i + 1}:`, error);
              failedQuestions.push(i + 1);
                    }
                }
                
                // 4. Atualizar as questões no exame local
                if (savedQuestions.length > 0) {
                    newExam.questions = savedQuestions;
                    updateLocalExam(newExam);
            console.log(
              `Exame local atualizado com ${savedQuestions.length} questões`
            );
                }
                
                // 5. Esconder modal e mostrar mensagem de sucesso
          document
            .getElementById("questionOptionsModal")
            .classList.add("hidden");
                
                // Ajustar mensagem com base no resultado
          let message = "";
                if (failedQuestions.length === 0) {
                    message = `Avaliação criada com sucesso! Todas as ${savedQuestions.length} questões foram adicionadas.`;
                } else {
                    message = `Avaliação criada com sucesso, mas ${failedQuestions.length} questões não puderam ser salvas. ${savedQuestions.length} questões foram adicionadas.`;
                }
                
          showSuccessModal("Avaliação Criada", message, () => {
                        // Limpar dados atuais
                        currentExamData = {
              name: "",
              description: "",
              questions: [],
                        };
                        
                        // Atualizar lista de provas
                        loadExamsFromAPI();
          });
                
                // 6. Atualizar a lista de provas
                await loadExamsFromAPI();
                renderExamsList();
                
          console.log("Processo de criação de prova finalizado com sucesso.");
            } catch (error) {
          console.error("Erro ao finalizar exame:", error);
          alert("Ocorreu um erro ao salvar a avaliação: " + error.message);
            } finally {
                // Restaurar botão
                finalizeBtn.innerHTML = originalBtnText;
                finalizeBtn.disabled = false;
            }
        }
        
        // Função auxiliar para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
          console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }
        
        // Script para atualizar os textos dos selects para mostrar valores dos enums
        function updateSelectOptionsToShowEnumValues() {
            // Garantir que os selects de nível de ensino tenham os valores de enum corretos
        const educationLevelSelects = document.querySelectorAll(
          ".education-level, #educationLevel, #bankEducationLevel, #newExamEducationLevel"
        );
            
            // Para cada select de nível de ensino, verificar se as opções têm os valores corretos
        educationLevelSelects.forEach((select) => {
                if (!select) return;
                
                // Verificar se já possui as opções corretas
                let hasCorrectOptions = false;
                for (let i = 0; i < select.options.length; i++) {
            if (
              select.options[i].value === "ANOS_INICIAIS" &&
              select.options[i].textContent === "Anos Iniciais"
            ) {
                        hasCorrectOptions = true;
                        break;
                    }
                }
                
                // Se já tem as opções corretas, apenas garantir que o texto seja igual ao valor
                if (hasCorrectOptions) {
            Array.from(select.options).forEach((option) => {
                        if (option.value) {
                            switch(option.value) {
                                case "ANOS_INICIAIS":
                                    option.textContent = "Anos Iniciais";
                                    break;
                                case "ANOS_FINAIS":
                                    option.textContent = "Anos Finais";
                                    break;
                                case "ENSINO_MEDIO":
                                    option.textContent = "Ensino Médio";
                                    break;
                            }
                        }
                    });
                } 
                // Caso contrário, recriar as opções com os valores corretos
                else {
                    // Salvar a opção vazia/placeholder
                    let placeholderOption = null;
                    for (let i = 0; i < select.options.length; i++) {
                        if (!select.options[i].value) {
                            placeholderOption = select.options[i].cloneNode(true);
                            break;
                        }
                    }
                    
                    // Limpar e adicionar a opção vazia se existir
            select.innerHTML = "";
                    if (placeholderOption) {
                        select.appendChild(placeholderOption);
                    }
                    
                    // Adicionar as opções com valores corretos
                    const correctValues = [
                        { value: "ANOS_INICIAIS", text: "Anos Iniciais" },
                        { value: "ANOS_FINAIS", text: "Anos Finais" },
                        { value: "ENSINO_MEDIO", text: "Ensino Médio" },
                    ];
                    
            correctValues.forEach((item) => {
              const option = document.createElement("option");
                        option.value = item.value;
                        option.textContent = item.text;
                        select.appendChild(option);
                    });
                }
            });

            // Atualizar os selects de série
            const gradeSelects = document.querySelectorAll(
                ".grade-level, #gradeLevel, #bankGrade, #linkGrade, #bnccGrade"
            );

            gradeSelects.forEach((select) => {
                if (!select) return;

                Array.from(select.options).forEach((option) => {
                    if (option.value) {
                        option.textContent = getFormattedGradeText(option.value);
                    }
                });
            });
        }
        
        // Chamar a função quando o DOM estiver carregado
      document.addEventListener("DOMContentLoaded", function () {
            // Chamar após carregar todos os outros scripts
            setTimeout(updateSelectOptionsToShowEnumValues, 500);
        });
        
        // Função para abrir o seletor de habilidades BNCC
        function openBnccSelector() {
            // Salvar referência ao elemento que receberá os códigos
        const questionItem =
          this.closest(".question-item") || this.closest("form");
        activeInputElement = questionItem
          ? questionItem.querySelector(".bncc-codes-input")
          : null;
            
            // Limpar seleções anteriores
            selectedSkills = [];
            
            // Carregar habilidades selecionadas atuais, se existirem
            if (activeInputElement && activeInputElement.value) {
          const codes = activeInputElement.value.split(",");
          codes.forEach((code) => {
                    const trimmedCode = code.trim();
                    if (trimmedCode) {
                        selectedSkills.push(trimmedCode);
                    }
                });
            }
            
            // Limpar filtros
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
            
            if (bnccComponent) bnccComponent.selectedIndex = 0;
            if (bnccGrade) bnccGrade.selectedIndex = 0;
        if (bnccSearch) bnccSearch.value = "";
            
            // Atualizar contagem de selecionados
        const selectedSkillsCount = document.getElementById(
          "selectedSkillsCount"
        );
        if (selectedSkillsCount)
          selectedSkillsCount.textContent = selectedSkills.length.toString();
            
            // Mostrar mensagem inicial
        const bnccSkillsList = document.getElementById("bnccSkillsList");
            if (bnccSkillsList) {
                bnccSkillsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        Carregando todas as habilidades... Você pode usar os filtros para restringir a lista.
                    </div>
                `;
            }
            
            // Abrir modal
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.remove("hidden");
            
            // Carregar todas as habilidades da API imediatamente
            updateBnccSkillsList();
        }
        
        // Função para fechar o modal BNCC
        function closeBnccModal() {
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.add("hidden");
        }
        
        // Função para confirmar a seleção de habilidades BNCC
        function confirmBnccSelection() {
            if (activeInputElement) {
          // Salvar códigos no input (apenas os códigos, não transformar em números)
          activeInputElement.value = selectedSkills.join(", ");
                
                // Atualizar UI
          const container =
            activeInputElement.closest(".question-item") ||
            activeInputElement.closest("form");
                if (container) {
            const countElement = container.querySelector(
              ".selected-skills-count"
            );
            const listElement = container.querySelector(
              ".selected-skills-list"
            );
                    
                    if (countElement) {
              countElement.textContent =
                selectedSkills.length > 0 ? `(${selectedSkills.length})` : "";
                    }
                    
                    if (listElement) {
              listElement.innerHTML = "";

              selectedSkills.forEach((code) => {
                const div = document.createElement("div");
                div.className =
                  "px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded flex justify-between items-center mb-1";
                            div.innerHTML = `
                                <span>${code}</span>
                                <button type="button" class="remove-skill text-blue-500 hover:text-blue-700" data-code="${code}">
                                    <i class="fas fa-times-circle"></i>
                                </button>
                            `;
                            
                            listElement.appendChild(div);
                            
                            // Adicionar evento para remover habilidade
                const removeBtn = div.querySelector(".remove-skill");
                            if (removeBtn) {
                  removeBtn.addEventListener("click", function () {
                    const codeToRemove = this.getAttribute("data-code");
                                    
                                    // Remover do array
                                    const index = selectedSkills.indexOf(codeToRemove);
                                    if (index !== -1) {
                                        selectedSkills.splice(index, 1);
                                    }
                                    
                    // Atualizar input (apenas os códigos, não transformar em números)
                    activeInputElement.value = selectedSkills.join(", ");
                                    
                                    // Remover elemento visual
                    this.closest("div").remove();
                                    
                                    // Atualizar contagem
                                    if (countElement) {
                      countElement.textContent =
                        selectedSkills.length > 0
                          ? `(${selectedSkills.length})`
                          : "";
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Fechar modal
            closeBnccModal();
        }
        
        // Função para atualizar a lista de habilidades BNCC
        function updateBnccSkillsList() {
        const component = document.getElementById("bnccComponent")?.value;
        const grade = document.getElementById("bnccGrade")?.value;
        const skillsList = document.getElementById("bnccSkillsList");
            
            if (!skillsList) return;
            
            skillsList.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-gray-500">Carregando habilidades...</p>
                </div>
            `;
            
            // Mesmo se componente e série não forem selecionados, vamos carregar todas as habilidades
        loadBnccSkillsFromAPI(grade, component)
          .then((apiSkills) => {
                // Limpar a lista
            skillsList.innerHTML = "";
                
                // Se não houver habilidades, mostrar mensagem
                if (!apiSkills || apiSkills.length === 0) {
                    skillsList.innerHTML = `
                        <div class="text-center text-gray-500 py-4">
                            Nenhuma habilidade encontrada para esta combinação
                        </div>
                    `;
                    return;
                }
                
                // Adicionar cada habilidade à lista
            apiSkills.forEach((skill) => {
              const code = skill.codigo || "";
              const description = skill.descricao || "";
                    
                    const isSelected = selectedSkills.includes(code);
              const div = document.createElement("div");
              div.className =
                "p-2 border-b border-gray-100 last:border-b-0 skill-item";
              div.setAttribute("data-code", code);
              div.setAttribute("data-visible", "true");
                    
                    div.innerHTML = `
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                              isSelected ? "checked" : ""
                            }>
                            <span class="ml-2">
                                <span class="block text-sm font-medium">${code}</span>
                                <span class="block text-xs text-gray-500">${description}</span>
                            </span>
                        </label>
                    `;
                    
                    // Adicionar evento ao checkbox
                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                checkbox.addEventListener("change", function () {
                            if (this.checked) {
                                // Adicionar à seleção
                                if (!selectedSkills.includes(code)) {
                                    selectedSkills.push(code);
                                }
                            } else {
                                // Remover da seleção
                                const index = selectedSkills.indexOf(code);
                                if (index !== -1) {
                                    selectedSkills.splice(index, 1);
                                }
                            }
                            
                            // Atualizar contagem
                  const count = document.getElementById("selectedSkillsCount");
                  if (count)
                    count.textContent = selectedSkills.length.toString();
                        });
                    }
                    
                    skillsList.appendChild(div);
                });
          })
          .catch((error) => {
            console.error("Erro ao carregar habilidades:", error);
                
                skillsList.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        Erro ao carregar habilidades. Tentando usar dados locais...
                    </div>
                `;
                
                // Tentar usar dados locais como fallback
                setTimeout(() => {
                    // Verificar se existem habilidades no banco de dados local para o componente e série
              const localComponent = Object.keys(bnccDatabase).find(
                (key) => key.toLowerCase() === component?.toLowerCase()
              );

              if (
                localComponent &&
                grade &&
                bnccDatabase[localComponent][grade]
              ) {
                        const skills = bnccDatabase[localComponent][grade];
                        
                        // Limpar a lista
                skillsList.innerHTML = "";
                        
                        // Adicionar cada habilidade local à lista
                skills.forEach((skill) => {
                            const isSelected = selectedSkills.includes(skill.code);
                  const div = document.createElement("div");
                  div.className =
                    "p-2 border-b border-gray-100 last:border-b-0 skill-item";
                  div.setAttribute("data-code", skill.code);
                  div.setAttribute("data-visible", "true");
                            
                            div.innerHTML = `
                                <label class="flex items-start cursor-pointer">
                                    <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                                      isSelected ? "checked" : ""
                                    }>
                                    <span class="ml-2">
                                        <span class="block text-sm font-medium">${
                                          skill.code
                                        }</span>
                                        <span class="block text-xs text-gray-500">${
                                          skill.description
                                        }</span>
                                    </span>
                                </label>
                            `;
                            
                            // Adicionar evento ao checkbox
                            const checkbox = div.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                    checkbox.addEventListener("change", function () {
                                    if (this.checked) {
                                        // Adicionar à seleção
                                        if (!selectedSkills.includes(skill.code)) {
                                            selectedSkills.push(skill.code);
                                        }
                                    } else {
                                        // Remover da seleção
                                        const index = selectedSkills.indexOf(skill.code);
                                        if (index !== -1) {
                                            selectedSkills.splice(index, 1);
                                        }
                                    }
                                    
                                    // Atualizar contagem
                      const count = document.getElementById(
                        "selectedSkillsCount"
                      );
                      if (count)
                        count.textContent = selectedSkills.length.toString();
                                });
                            }
                            
                            skillsList.appendChild(div);
                        });
                    } else {
                        skillsList.innerHTML = `
                            <div class="text-center text-gray-500 py-4">
                                Nenhuma habilidade encontrada ${
                                  component ? "para " + component : ""
                                } ${grade ? " - " + grade : ""}
                            </div>
                        `;
                    }
                }, 500);
            });
        }
        
        // Função para filtrar habilidades BNCC
        function filterBnccSkills() {
        const searchText =
          document.getElementById("bnccSearch")?.value.toLowerCase() || "";
        const skillItems = document.querySelectorAll(
          "#bnccSkillsList .skill-item"
        );

        skillItems.forEach((item) => {
          const code = item.getAttribute("data-code") || "";
          const description =
            item.querySelector(".text-gray-500")?.textContent.toLowerCase() ||
            "";
                
                // Verificar se o texto de busca está no código ou na descrição
          if (
            code.toLowerCase().includes(searchText) ||
            description.includes(searchText)
          ) {
            item.style.display = "";
            item.setAttribute("data-visible", "true");
                } else {
            item.style.display = "none";
            item.setAttribute("data-visible", "false");
                }
            });
        }
        
        // Função para selecionar todas as habilidades visíveis
        function selectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && !checkbox.checked && code) {
                    checkbox.checked = true;
                    
                    // Adicionar à seleção
                    if (!selectedSkills.includes(code)) {
                        selectedSkills.push(code);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para desmarcar todas as habilidades visíveis
        function deselectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && checkbox.checked && code) {
                    checkbox.checked = false;
                    
                    // Remover da seleção
                    const index = selectedSkills.indexOf(code);
                    if (index !== -1) {
                        selectedSkills.splice(index, 1);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para configurar uploads de imagem
        function setupImageUploads() {
        document.querySelectorAll(".question-image").forEach((input) => {
          input.addEventListener("change", handleImageUpload);
            });
            
        document.querySelectorAll(".remove-image").forEach((button) => {
          button.addEventListener("click", handleImageRemove);
            });
        }
        
        // Função para tratar upload de imagem
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Pegar o caminho completo do arquivo
            const filePath = file.name;
            
            const reader = new FileReader();
            const container = this.closest(".question-item") || this.closest("form");
            const previewContainer = container?.querySelector(".image-preview");
            const previewImg = previewContainer?.querySelector("img");
            const fileInput = container?.querySelector(".question-image") || container?.querySelector("#questionImage");
            
            if (!previewContainer || !previewImg || !fileInput) return;
            
            reader.onload = function (event) {
                // Mostrar preview da imagem
                previewImg.src = event.target.result;
                previewContainer.classList.remove("hidden");
                
                // Armazenar o caminho do arquivo
                fileInput.dataset.imagePath = filePath;
                
                console.log('Imagem carregada. Caminho:', filePath);
            };
            
            reader.readAsDataURL(file);
        }
        
        
        // Função para remover imagem
        function handleImageRemove() {
        const container =
          this.closest(".question-item") || this.closest("form");
        const previewContainer = container?.querySelector(".image-preview");
        const fileInput =
          container?.querySelector(".question-image") ||
          container?.querySelector("#questionImage");
            
            if (previewContainer) {
          previewContainer.classList.add("hidden");
          const img = previewContainer.querySelector("img");
          if (img) img.src = "";
            }
            
            if (fileInput) {
          fileInput.value = "";
            }
        }
        
        // Função para renderizar lista de avaliações
        function renderExamsList() {
        const examsList = document.getElementById("examsList");
            if (!examsList) return;
            
            // Obter avaliações do localStorage
            let exams = [];
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    exams = JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            
        console.log("Avaliações encontradas:", exams.length, exams);
            
            // Filtrar provas vazias - remover provas com 0 questões e que não existem no banco de dados
            // Remover também as provas simuladas específicas que foram mencionadas
            const namesToRemove = [
          "Avaliação Diagnóstica - Português",
          "Avaliação Diagnóstica - Matemática",
          "Avaliação Bimestral - Português",
          "Avaliação Bimestral - Matemática",
          "Avaliação Final - Ciências",
        ];

        exams = exams.filter((exam) => {
                // Verificar se a prova tem questões
                const questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Incluir a prova apenas se não está na lista de nomes a remover OU tem questões OU tem um ID da API
          return (
            !namesToRemove.includes(exam.name) ||
            questionsCount > 0 ||
            exam.apiId
          );
            });
            
            // Salvar a lista filtrada de volta no localStorage
        localStorage.setItem("exams", JSON.stringify(exams));
            
            // Se não há avaliações, mostrar mensagem
            if (!exams || exams.length === 0) {
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        Nenhuma prova cadastrada
                    </li>
                `;
                return;
            }
            
            // Limpar lista
        examsList.innerHTML = "";
            
            // Adicionar cada avaliação à lista
        exams.forEach((exam) => {
          const li = document.createElement("li");
          li.className = "block hover:bg-gray-50";
                
                // Verificar se a prova tem questões
                let questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Se tiver ID da API mas nenhuma questão local, tentar atualizar o contador com uma mensagem
                let questionCountText = `Questões: ${questionsCount}`;
                if (questionsCount === 0 && exam.apiId) {
                    // Tentar carregar os detalhes da prova da API para mostrar o número correto
                    loadExamDetails(exam.apiId, exams.indexOf(exam), exams)
              .then((success) => {
                            if (success) {
                                // Atualizar a visualização após carregar os detalhes
                                const updatedExams = getExams();
                  const updatedExam = updatedExams.find(
                    (e) => e.id === exam.id
                  );
                                if (updatedExam && updatedExam.questions.length > 0) {
                    const questionCountElement =
                      li.querySelector(".question-count");
                                    if (questionCountElement) {
                                        questionCountElement.textContent = `Questões: ${updatedExam.questions.length}`;
                                    }
                                }
                            }
                        })
              .catch((err) =>
                console.error("Erro ao carregar detalhes da prova:", err)
              );
                        
                    questionCountText = `<span class="question-count">Questões: ${questionsCount} <i class="fas fa-sync-alt fa-spin text-xs ml-1" title="Atualizando contador de questões..."></i></span>`;
                } else {
                    questionCountText = `<span class="question-count">Questões: ${questionsCount}</span>`;
                }
                
                // Formatar data de criação
          let createdAt = "";
                try {
                    if (exam.createdAt) {
                        const date = new Date(exam.createdAt);
              createdAt = date.toLocaleDateString("pt-BR");
                    }
                } catch (e) {
            console.error("Erro ao formatar data:", e);
                }
                
                // Badge para nível de ensino
          const educationLevelBadge = exam.educationLevel
            ? `<span class="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-800 rounded">${exam.educationLevel}</span>`
            : "";
                
          console.log(
            `Renderizando prova: ${exam.name}, API ID: ${exam.apiId}, Questões: ${questionsCount}`
          );
                
                li.innerHTML = `
                    <div class="flex items-center px-4 py-4 sm:px-6">
                        <div class="min-w-0 flex-1 flex items-center">
                            <div class="flex-shrink-0">
                                <span class="h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center">
                                    <i class="fas fa-file-alt text-yellow-600 text-lg"></i>
                                </span>
                            </div>
                            <div class="min-w-0 flex-1 px-4">
                                <div>
                                    <p class="text-sm font-medium text-blue-600 truncate">
                                        ${exam.name} ${educationLevelBadge}
                                    </p>
                                    <p class="mt-1 text-sm text-gray-500">
                                        ${questionCountText} | Criada em: ${createdAt}
                                    </p>
                                    ${
                                      exam.description
                                        ? `<p class="mt-1 text-xs text-gray-400 truncate">${exam.description}</p>`
                                        : ""
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            <button onclick="visualizarProva(${exam.apiId || exam.id})" class="bg-white text-blue-500 p-2 rounded-full hover:bg-blue-100 border border-gray-200" data-id="${exam.id}" title="Visualizar Prova"><i class="fas fa-eye"></i>
</button>
                            <button class="text-indigo-600 hover:text-indigo-900 editQuestionsExam" data-id="${
                              exam.id
                            }" data-api-id="${exam.apiId || ''}" title="Editar Questões">
                                <i class="fas fa-list-check"></i>
                            </button>
                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${
                              exam.id
                            }" title="Baixar PDF">
                                <i class="fas fa-file-pdf"></i>
                            </button>
                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${
                              exam.id
                            }" title="Excluir prova">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                examsList.appendChild(li);
            });
            
            // Adicionar eventos aos botões
            setupExamListButtons();
        }
        
        // Função para configurar botões na lista de avaliações
        function setupExamListButtons() {
            // Visualizar avaliação
            document.querySelectorAll(".viewExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    viewExam(examId);
                });
            });
            
            // Editar avaliação
            document.querySelectorAll(".editExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    openExamForEditing(examId);
                });
            });
            
            // Editar questões da avaliação
            document.querySelectorAll(".editQuestionsExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const apiId = this.getAttribute("data-api-id");
                    if (!apiId) {
                        alert("Esta prova não possui ID da API e não pode ter suas questões editadas.");
                        return;
                    }
                    openEditQuestionsModal(examId, apiId);
                });
            });
            
            // Baixar avaliação
            document.querySelectorAll(".downloadExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    if (exam) {
                        // Adicionar debug para ver a estrutura da prova
                        console.log("ESTRUTURA DA PROVA:", JSON.stringify(exam, null, 2));
                        console.log("QUESTÕES:", JSON.stringify(exam.questions, null, 2));
                        if (exam.questions && exam.questions.length > 0) {
                            console.log("PRIMEIRA QUESTÃO:", JSON.stringify(exam.questions[0], null, 2));
                            console.log("ALTERNATIVAS:", JSON.stringify(exam.questions[0].options || exam.questions[0].alternativas, null, 2));
                        }
                        exportExamToDocx(exam);
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
        }
        
        // Função para visualizar uma avaliação
        function viewExam(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Aqui você pode implementar a visualização completa da avaliação
            // Por enquanto, mostraremos algumas informações básicas
        alert(
          `Visualizando: ${exam.name}\nTotal de questões: ${exam.questions.length}`
        );
            
            // Em um caso real, você abriria um modal ou navegaria para uma página de detalhes
        }
        
        // Função para abrir uma avaliação para edição
        function openExamForEditing(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Preencher dados no modal de edição
        document.getElementById("newExamName").value = exam.name;
        document.getElementById("newExamDescription").value =
          exam.description || "";
            
            // Definir o nível de ensino
        const educationLevelSelect = document.getElementById(
          "newExamEducationLevel"
        );
            if (educationLevelSelect) {
                // Tentar encontrar o option com o valor igual ao do exame
          const eduLevel = exam.educationLevel || "";
                let optionExists = false;
                
                // Procurar pelo valor exato primeiro
                for (let i = 0; i < educationLevelSelect.options.length; i++) {
                    if (educationLevelSelect.options[i].value === eduLevel) {
                        educationLevelSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }
                
                // Se não encontrou, tentar mapear para um valor válido da API
                if (!optionExists) {
            let mappedValue = "";
                    const eduLevelUpper = eduLevel.toUpperCase();
                    
            if (
              eduLevelUpper.includes("INICIAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL I")
            ) {
              mappedValue = "ANOS_INICIAIS";
            } else if (
              eduLevelUpper.includes("FINAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL II")
            ) {
              mappedValue = "ANOS_FINAIS";
            } else if (
              eduLevelUpper.includes("MÉDIO") ||
              eduLevelUpper.includes("MEDIO")
            ) {
              mappedValue = "ENSINO_MEDIO";
                    }
                    
                    if (mappedValue) {
                        for (let i = 0; i < educationLevelSelect.options.length; i++) {
                            if (educationLevelSelect.options[i].value === mappedValue) {
                                educationLevelSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Armazenar o ID da prova que está sendo editada
            currentExamData = {
                id: exam.id,
                apiId: exam.apiId,
                name: exam.name,
          description: exam.description || "",
          questions: [...exam.questions], // Clone para não modificar o original
            };
            
            // Abrir o modal de edição
        document
          .getElementById("createExamStepOneModal")
          .classList.remove("hidden");
            
            // Atualizar o título do modal
        const modalTitle = document.querySelector("#createExamStepOneModal h3");
            if (modalTitle) {
          modalTitle.textContent = "Editar Prova";
            }
            
            // Atualizar o texto do botão
        const submitBtn = document.querySelector(
          '#createExamStepOneForm button[type="submit"]'
        );
            if (submitBtn) {
          submitBtn.textContent = "Continuar para Edição de Questões";
            }
        }
        
        // Função para atualizar uma prova existente
        async function updateExam(exam) {
            try {
          console.log("Iniciando atualização da prova ID:", exam.id);
                
                // Atualizar localmente
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
            console.log("Prova atualizada no armazenamento local");
                } else {
            throw new Error("Prova não encontrada no armazenamento local");
                }
                
                // Se tiver ID da API, atualizar remotamente
                if (exam.apiId) {
                    // Mapear o nível de ensino - usar apenas valores válidos para a API
                    let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                    if (exam.educationLevel) {
              switch (exam.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "ANOS_INICIAIS";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "ANOS_FINAIS";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "ENSINO_MEDIO";
                                break;
                            default:
                                // Caso não identifique, usar o padrão ANOS_INICIAIS
                                nivelEnsino = "ANOS_INICIAIS";
                        }
                    }
                    
                    // Converter para o formato da API
                    const apiExam = {
                        id: exam.apiId,
                        nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: exam.description || "",
                        data_aplicacao: new Date().toISOString(),
              nivel_ensino: nivelEnsino,
                    };
                    
            console.log("Dados enviados para a API:", apiExam);
                    
                    // Adicionar questões se existirem
                    if (exam.questions && exam.questions.length > 0) {
              apiExam.questoes = exam.questions.map((q) => {
                            return {
                                texto: q.text,
                                nivel_ensino: nivelEnsino,
                  serie: q.gradeLevel || "",
                  dificuldade: q.difficultyLevel || "",
                  componente_curricular: q.curriculumComponent || "",
                  codigos_bncc: q.bnccCodes || "",
                  resposta_correta: q.correctAnswer || "A",
                  alternativa_a: q.options.A || "",
                  alternativa_b: q.options.B || "",
                  alternativa_c: q.options.C || "",
                  alternativa_d: q.options.D || "",
                  alternativa_e: q.options.E || "",
                  imagem: q.image || null,
                            };
                        });
                    }
                    
            console.log(
              `Enviando atualização para a API: /api/provas/${exam.apiId}`,
              apiExam
            );

            const response = await fetch(
              `https://sag-sag.rak8a3.easypanel.host/api/provas/${exam.apiId}`,
              {
                method: "PUT",
                        headers: {
                  "Content-Type": "application/json",
                        },
                body: JSON.stringify(apiExam),
              }
            );
                    
                    if (!response.ok) {
              const errorText = await response
                .text()
                .catch(() => "Erro desconhecido");
              console.error(
                `Erro ao atualizar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
              );
              throw new Error(
                `Não foi possível atualizar a prova na API. Status: ${response.status}`
              );
                    }
                    
                    const updatedExam = await response.json().catch(() => null);
            console.log("Prova atualizada com sucesso na API:", updatedExam);
                    
                    // Se a API retornou dados atualizados, sincronizar com a cópia local
                    if (updatedExam) {
                        // Atualizar dados que possam ter sido modificados pela API
                        exam.apiId = updatedExam.id;
                        // Atualizar no armazenamento local
                        exams[index] = exam;
              localStorage.setItem("exams", JSON.stringify(exams));
                        
                        // Recarregar a lista de provas da API para garantir sincronização
              console.log("Recarregando lista de provas da API...");
                        await loadExamsFromAPI();
                    }
                    
                    // Atualizar a interface
                    renderExamsList();
            console.log("Interface atualizada com os novos dados da prova");
                    
                    return true;
                } else {
                    // Se não tem ID da API, tentar criar novo registro na API
                    try {
              console.log(
                "Prova sem ID da API. Tentando criar novo registro na API..."
              );
                        const savedExam = await saveExamToAPI(exam);
                        if (savedExam && savedExam.id) {
                            // Atualizar o ID da API na cópia local
                            exam.apiId = savedExam.id;
                            exams[index] = exam;
                localStorage.setItem("exams", JSON.stringify(exams));
                console.log("Prova criada na API com sucesso:", savedExam);
                            
                            // Recarregar a lista de provas da API
                            await loadExamsFromAPI();
                            
                            // Atualizar a interface
                            renderExamsList();
                        }
                    } catch (apiError) {
              console.error("Erro ao criar prova na API:", apiError);
                        // Continue mesmo se falhar na API, pois já temos localmente
                        
                        // Atualizar a interface de qualquer forma
                        renderExamsList();
                    }
                    return true;
                }
            } catch (error) {
          console.error("Erro ao atualizar prova:", error);
                return false;
            }
        }
        
        // Função para obter todas as avaliações
        function getExams() {
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    return JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            return [];
        }
        
        // Função para adicionar uma nova avaliação
      function addExam(name, questions, description = "", educationLevel = "") {
            // Obter avaliações existentes
            let exams = getExams() || [];
            
            // Gerar ID único
        const newId = exams.length > 0 ? Math.max(...exams.map((e) => e.id)) + 1 : 1;
            
            // Processar as questões para garantir formato correto
            const processedQuestions = questions.map(question => {
                console.log("Processando questão para addExam:", question);
                
                // Garantir que options está no formato correto
                const options = {};
                
                // Caso 1: Se já tem um objeto options com formato {A: "texto", B: "texto"}
                if (question.options && typeof question.options === 'object' && !Array.isArray(question.options)) {
                    options.A = question.options.A || '';
                    options.B = question.options.B || '';
                    options.C = question.options.C || '';
                    options.D = question.options.D || '';
                    options.E = question.options.E || '';
                }
                // Caso 2: Se tem um array de alternativas
                else if (question.alternativas && Array.isArray(question.alternativas)) {
                    const letters = ['A', 'B', 'C', 'D', 'E'];
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letra = letters[index];
                            options[letra] = alt.texto || alt.text || '';
                        }
                    });
                }
                
                console.log("Opções processadas:", options);
                
                // Retornar questão processada
                return {
                    ...question,
                    options: options
                };
            });
            
            // Criar objeto de avaliação
            const newExam = {
                id: newId,
                name: name,
                description: description,
                educationLevel: educationLevel,
                questions: processedQuestions,
                createdAt: new Date().toISOString(),
                links: [],
            };
            
            // Adicionar à lista
            exams.push(newExam);
            
            // Salvar no localStorage
            localStorage.setItem("exams", JSON.stringify(exams));
            
            console.log("Nova avaliação adicionada:", newExam);
            
            return newExam;
        }
        
        // Função para popular o seletor de avaliações
        async function populateExamSelector() {
        const examSelect = document.getElementById("examSelect");
            if (!examSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          examSelect.innerHTML =
            '<option value="">Carregando provas...</option>';
                examSelect.disabled = true;
                
                // Buscar provas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/provas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const exams = await response.json();
          console.log("Provas carregadas da API:", exams);
                
                // Limpar seletor
          examSelect.innerHTML =
            '<option value="">Selecione uma prova</option>';
                
                // Verificar se a resposta é um array
                if (Array.isArray(exams) && exams.length > 0) {
                    // Adicionar cada prova ao seletor
            exams.forEach((exam) => {
              const option = document.createElement("option");
                        option.value = exam.id;
                        
                        // Dar preferência ao campo 'nome'
                        if (exam.nome !== undefined) {
                            option.textContent = exam.nome;
                        } else if (exam.titulo !== undefined) {
                            option.textContent = exam.titulo;
                        } else {
                option.textContent = "Prova sem título";
                        }
                        
                        examSelect.appendChild(option);
                    });
                } else {
                    // Se não houver provas, mostrar mensagem
            examSelect.innerHTML =
              '<option value="">Nenhuma prova disponível</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar provas:", error);
          examSelect.innerHTML =
            '<option value="">Erro ao carregar provas</option>';
            } finally {
                examSelect.disabled = false;
            }
            
            return examSelect;
        }
        
        // Função para popular o seletor de escolas
        async function populateSchoolSelector() {
        const schoolSelect = document.getElementById("linkSchool");
            if (!schoolSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          schoolSelect.innerHTML =
            '<option value="">Carregando escolas...</option>';
                schoolSelect.disabled = true;
                
                // Buscar escolas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/escolas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar escolas. Status: ${response.status}`
            );
                }
                
                const schools = await response.json();
                
                // Limpar seletor
          schoolSelect.innerHTML =
            '<option value="">Selecione uma escola</option>';
                
                // Adicionar cada escola ao seletor
          schools.forEach((school) => {
            const option = document.createElement("option");
                    option.value = school.id;
            option.textContent = school.nome || "Escola sem nome";
                    schoolSelect.appendChild(option);
                });
            } catch (error) {
          console.error("Erro ao buscar escolas:", error);
          schoolSelect.innerHTML =
            '<option value="">Erro ao carregar escolas</option>';
            } finally {
                schoolSelect.disabled = false;
            }
        }
        
        // Função para popular o seletor de turmas
        async function populateClassSelector(schoolId) {
        const classSelect = document.getElementById("linkClass");
            if (!classSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          classSelect.innerHTML =
            '<option value="">Carregando turmas...</option>';
                classSelect.disabled = true;
                
                if (!schoolId) {
            classSelect.innerHTML =
              '<option value="">Selecione uma escola primeiro</option>';
                    classSelect.disabled = true;
                    return;
                }
                
                // Buscar turmas da API
          const response = await fetch(
            `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar turmas. Status: ${response.status}`
            );
                }
                
                const classes = await response.json();
                
                // Limpar seletor
          classSelect.innerHTML =
            '<option value="">Selecione uma turma</option>';
                
                // Adicionar cada turma ao seletor
          classes.forEach((cls) => {
            const option = document.createElement("option");
                    option.value = cls.id;
                    option.textContent = cls.nome || `Turma ${cls.id}`;
                    classSelect.appendChild(option);
                });
                
                // Se não há turmas, mostrar mensagem
                if (classes.length === 0) {
            classSelect.innerHTML =
              '<option value="">Nenhuma turma encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar turmas:", error);
          classSelect.innerHTML =
            '<option value="">Erro ao carregar turmas</option>';
            } finally {
                classSelect.disabled = false;
            }
        }
        
        // Atualizar o formulário de vincular prova
        function updateLinkExamForm() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        // Função para vincular uma avaliação a uma turma
        async function linkExamToClass(examId, schoolId, grade, classId, shift) {
            try {
                const payload = {
                    prova_id: examId,
            turma_id: classId,
                };
                
          console.log("Enviando dados para vincular prova:", payload);
                
                // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao vincular prova. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
          console.log("Prova vinculada com sucesso:", result);
                
                return true;
            } catch (error) {
          console.error("Erro ao vincular prova:", error);
                throw error;
            }
        }
        
        // Função para exportar uma avaliação para PDF
        function exportExamToDocx(exam) {
    // Verificar se o objeto exam é válido
    if (!exam || !exam.name) {
        alert('Prova inválida para exportação!');
        return;
    }

    // Log detalhado de depuração para mostrar as alternativas
    console.log("INICIANDO EXPORTAÇÃO DA PROVA:", exam.name);
    if (exam.questions && exam.questions.length > 0) {
        exam.questions.forEach((q, index) => {
            console.log(`Questão ${index + 1}:`, q.text);
            console.log(`  Alternativas para questão ${index + 1}:`, q.options);
            
            // Verificar se as alternativas estão vazias
            const hasNonEmptyOptions = q.options && Object.values(q.options).some(opt => opt && opt.trim() !== '');
            console.log(`  Tem alternativas não vazias? ${hasNonEmptyOptions}`);
            
            if (!hasNonEmptyOptions) {
                console.warn("⚠️ ALTERNATIVAS VAZIAS DETECTADAS! Verificando alternativas originais no localStorage...");
                
                // Buscar dados originais do localStorage
                try {
                    const exams = JSON.parse(localStorage.getItem("exams")) || [];
                    const localExam = exams.find(e => e.id === exam.id);
                    if (localExam && localExam.questions) {
                        const localQuestion = localExam.questions.find(lq => lq.id === q.id || lq.apiId === q.apiId);
                        if (localQuestion && localQuestion.options) {
                            console.log("  Alternativas no localStorage:", localQuestion.options);
                            
                            // Atualizar as alternativas da questão atual com as do localStorage
                            if (Object.values(localQuestion.options).some(opt => opt && opt.trim() !== '')) {
                                console.log("  ✅ Usando alternativas do localStorage");
                                q.options = localQuestion.options;
                            }
                        }
                    }
                } catch (error) {
                    console.error("Erro ao buscar alternativas do localStorage:", error);
                }
            }
        });
    }

    // Indicar que estamos processando
    const processingMessage = document.createElement('div');
    processingMessage.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    processingMessage.innerHTML = `
        <div class="bg-white p-4 rounded-lg shadow-lg text-center">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mb-4"></div>
            <p class="text-gray-800">Gerando PDF...</p>
        </div>
    `;
    document.body.appendChild(processingMessage);

    // Função para carregar as bibliotecas necessárias (jsPDF e html2canvas)
    function loadPdfLibraries() {
        return new Promise((resolve, reject) => {
            // Verificar se as bibliotecas já estão carregadas
            if (typeof jspdf !== 'undefined' && typeof html2canvas !== 'undefined') {
                resolve({ jspdf, html2canvas });
                return;
            }

            // Contador para controlar o carregamento das duas bibliotecas
            let loaded = 0;
            
            // Carregar jsPDF
            const jspdfScript = document.createElement('script');
            jspdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            jspdfScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            jspdfScript.onerror = () => reject(new Error('Falha ao carregar jsPDF'));
            document.head.appendChild(jspdfScript);
            
            // Carregar html2canvas
            const html2canvasScript = document.createElement('script');
            html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            html2canvasScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            html2canvasScript.onerror = () => reject(new Error('Falha ao carregar html2canvas'));
            document.head.appendChild(html2canvasScript);
        });
    }

    // Função para remover a mensagem de processamento
    function removeProcessingMessage() {
        if (processingMessage && processingMessage.parentNode) {
            processingMessage.parentNode.removeChild(processingMessage);
        }
    }

    // Função para criar o conteúdo HTML que será convertido em PDF
    function createExamContent() {
        // Criar um contêiner para o conteúdo do PDF
        const container = document.createElement('div');
        container.style.width = '210mm'; // Largura A4
        container.style.padding = '20mm';
        container.style.backgroundColor = 'white';
        container.style.color = 'black';
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.top = '0';
        
        // Cabeçalho da avaliação
        container.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">AVALIAÇÃO</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">${exam.name.toUpperCase()}</h2>
                <p style="margin-bottom: 10px; font-size: 16px;">Nome do Aluno: _____________________________________________</p>
                <p style="margin-bottom: 30px; font-size: 16px;">Data: ___/___/______</p>
            </div>
            
            <!-- Instruções -->
            <div style="border: 1px solid #999; padding: 15px; margin-bottom: 30px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #666;">INSTRUÇÕES:</p>
                <p style="margin-bottom: 8px; color: #666;">1. Leia atentamente cada questão antes de respondê-la</p>
                <p style="margin-bottom: 8px; color: #666;">2. Use caneta azul ou preta para marcar suas respostas</p>
                <p style="margin-bottom: 8px; color: #666;">3. Não é permitido o uso de corretivo</p>
                <p style="color: #666;">4. Questões rasuradas serão anuladas</p>
            </div>
        `;
        
        // Adicionar questões
        if (exam.questions && exam.questions.length > 0) {
            const questionsDiv = document.createElement('div');
            
            exam.questions.forEach((question, index) => {
                const questionText = question.text || question.enunciado || "";
                if (!questionText) {
                    console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                    return;
                }
                
                // Cabeçalho da questão
                const questionDiv = document.createElement('div');
                questionDiv.style.marginBottom = '30px';
                questionDiv.style.pageBreakInside = 'avoid';
                
                questionDiv.innerHTML = `
                    <div style="border-top: 1px solid #ccc; margin-top: 15px; margin-bottom: 15px;"></div>
                    <div style="display: flex; margin-bottom: 15px;">
                        <div style="background-color: #666; color: white; padding: 8px 15px; font-weight: bold; width: 30%; display: inline-block;">
                            QUESTÃO ${index + 1}
                        </div>
                        <div style="padding: 8px 15px; width: 70%; text-align: right; display: inline-block;">
                            1 ponto
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 16px; margin-left: 15px;">${questionText}</p>
                `;
                
                // Adicionar imagem se existir
                if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                    questionDiv.innerHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <img src="${question.image}" alt="Imagem da questão" style="max-width: 80%; max-height: 200px; border: 1px solid #ddd; padding: 5px;">
                            <p style="font-style: italic; color: #666; font-size: 12px; margin-top: 5px;">Figura ${index + 1}: Imagem referente à questão</p>
                        </div>
                    `;
                }
                
                // Adicionar alternativas
                const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                let alternativas = [];
                
                if (question.options && typeof question.options === 'object') {
                    // Formato {A: "texto", B: "texto"}
                    alternativasLetras.forEach(letra => {
                        let texto = '';
                        
                        // Se tem texto na alternativa, use-o
                        if (question.options[letra] && question.options[letra].trim() !== '') {
                            texto = question.options[letra];
                        } 
                        // Caso contrário, use um texto padrão
                        else {
                            texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                        }
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                } else if (question.alternativas && Array.isArray(question.alternativas)) {
                    question.alternativas.forEach((alt, index) => {
                        if (index < alternativasLetras.length) {
                            const letra = alternativasLetras[index];
                            let texto = alt.texto || alt.text || '';
                            
                            if (!texto || texto.trim() === '') {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        }
                    });
                }
                
                // Se não encontrou alternativas, criar alternativas padrão
                if (alternativas.length === 0) {
                    alternativasLetras.forEach(letra => {
                        const texto = letra === question.correctAnswer 
                            ? `Alternativa correta ${letra}`
                            : `Alternativa ${letra}`;
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                }
                
                // Ordenar alternativas por letra
                alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                
                // Adicionar cada alternativa ao HTML
                const alternativesHtml = document.createElement('div');
                alternativesHtml.style.marginLeft = '30px';
                
                alternativas.forEach(({letra, texto}) => {
                    alternativesHtml.innerHTML += `
                        <p style="margin-bottom: 10px; font-size: 16px;">
                            <span style="display: inline-block; width: 25px; height: 25px; border-radius: 50%; border: 1px solid #666; text-align: center; line-height: 23px; margin-right: 10px; font-weight: bold;">${letra}</span>
                            ${texto}
                        </p>
                    `;
                });
                
                questionDiv.appendChild(alternativesHtml);
                questionsDiv.appendChild(questionDiv);
            });
            
            container.appendChild(questionsDiv);
        } else {
            // Se não houver questões, adicionar mensagem
            container.innerHTML += `
                <p style="text-align: center; font-style: italic; margin: 30px 0;">
                    Esta avaliação não contém questões.
                </p>
            `;
        }
        
        return container;
    }

    // Função para gerar o PDF
    async function generatePdf(libraries) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
`<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Provas - SAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
        /* Ajustes de layout */
        .container-full {
            width: 100%;
            max-width: 100%;
            padding-left: 0;
            padding-right: 0;
        }
        .modal-overflow {
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ajusta layout em dispositivos móveis */
        @media (max-width: 768px) {
            .mobile-padding {
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    
    <!-- Success Modal -->
    <div
      id="successModal"
      class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
    >
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4">
            <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-medium text-gray-900" id="successModalTitle">
            Operação Concluída
          </h3>
          <button
            id="closeSuccessModal"
            class="text-gray-400 hover:text-gray-500"
          >
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mb-6 text-center">
                <div class="text-green-500 text-4xl mb-4">
                    <i class="fas fa-check-circle"></i>
                </div>
          <p class="text-gray-700" id="successModalMessage">
            Operação realizada com sucesso!
          </p>
            </div>
            <div class="flex justify-center">
          <button
            id="successModalOkBtn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
                    OK
                </button>
            </div>
        </div>
    </div>
    <!-- Modal -->
<div id="modalProva" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 overflow-y-auto h-full w-full">
  <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <!-- Cabeçalho -->
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-2xl font-bold text-gray-800">Questões da Prova</h3>
      <button onclick="fecharModal()" class="text-gray-500 hover:text-gray-700">&times;</button>
    </div>
    
    <!-- Conteúdo das questões -->
    <div id="questoesContainer" class="space-y-4 max-h-96 overflow-y-auto">
      <!-- As questões serão inseridas aqui via JavaScript -->
    </div>
    
    <!-- Loading -->
    <div id="loading" class="text-center py-4 hidden">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
    </div>
  </div>
</div>`
<script>
   function visualizarProva(provaId) {
  console.log("ID da prova visualizada:", provaId);

  const modal = document.getElementById("modalProva");
  const loading = document.getElementById("loading");
  const questoesContainer = document.getElementById("questoesContainer");

  modal.classList.remove("hidden");
  loading.classList.remove("hidden");
  questoesContainer.innerHTML = "";

  fetch(
    `https://sag-sag.rak8a3.easypanel.host/api/provas/${provaId}/questoes-detalhadas`
  )
    .then((response) => response.json())
    .then((data) => {
      if (data.questoes && data.questoes.length > 0) {
        questoesContainer.innerHTML = data.questoes
          .map(
            (questao, index) => `
            <div class="p-4 border rounded-lg">
              <h4 class="font-semibold mb-2">Questão ${index + 1}</h4>
              <p class="text-gray-600 mb-3">${questao.enunciado}</p>
              <ul class="space-y-2">
                ${questao.alternativas
                  .map(
                    (alt) => `
                  <li class="${
                    alt.correta
                      ? "bg-green-100 border-l-4 border-green-500"
                      : ""
                  } p-2 rounded">
                    ${alt.texto}
                  </li>
                `
                  )
                  .join("")}
              </ul>
            </div>
          `
          )
          .join("");
      } else {
        questoesContainer.innerHTML =
          '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
      }
    })
    .catch((error) => {
      console.error("Erro:", error);
      questoesContainer.innerHTML =
        '<p class="text-center text-red-500">Erro ao carregar questões</p>';
    })
    .finally(() => {
      loading.classList.add("hidden");
    });
}

        } else {
          questoesContainer.innerHTML = '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
        }
      })
      .catch(error => {
        console.error('Erro:', error);
        questoesContainer.innerHTML = '<p class="text-center text-red-500">Erro ao carregar questões</p>';
      })
      .finally(() => {
        loading.classList.add('hidden');
      });
  }
  
  function fecharModal() {
    document.getElementById('modalProva').classList.add('hidden');
  }
  
  // Fechar modal ao clicar fora
  window.onclick = function(event) {
    const modal = document.getElementById('modalProva');
    if (event.target === modal) {
      fecharModal();
    }
  }
  </script>
    <script src="js/app.js"></script>
    <script src="js/alert.js"></script>
    <script>
        // Global variables para gerenciamento de habilidades BNCC
        let selectedSkills = [];
        let activeInputElement = null;

        // Base de dados de habilidades BNCC
        const bnccDatabase = {
        Português: {
          PRIMEIRO_ANO: [
            {
              code: "EF01LP01",
              description:
                "Reconhecer que textos são lidos e escritos da esquerda para a direita e de cima para baixo da página.",
            },
            {
              code: "EF01LP02",
              description:
                "Escrever, espontaneamente ou por ditado, palavras e frases de forma alfabética – usando letras/grafemas que representem fonemas.",
            },
            {
              code: "EF01LP03",
              description:
                "Observar escritas convencionais, comparando-as às suas produções escritas, percebendo semelhanças e diferenças.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02LP01",
              description:
                "Utilizar, ao produzir o texto, grafia correta de palavras conhecidas ou com estruturas silábicas já dominadas, letras maiúsculas em início de frases e em substantivos próprios, segmentação entre as palavras, ponto final, ponto de interrogação e ponto de exclamação.",
            },
            {
              code: "EF02LP02",
              description:
                "Segmentar palavras em sílabas e remover e substituir sílabas iniciais, mediais ou finais para criar novas palavras.",
            },
            {
              code: "EF02LP03",
              description:
                "Ler e escrever palavras com correspondências regulares diretas entre letras e fonemas (f, v, t, d, p, b) e correspondências regulares contextuais (c e q; e e o, em posição átona em final de palavra).",
            },
          ],
        },
        Matemática: {
          PRIMEIRO_ANO: [
            {
              code: "EF01MA01",
              description:
                "Utilizar números naturais como indicador de quantidade ou de ordem em diferentes situações cotidianas e reconhecer situações em que os números não indicam contagem nem ordem, mas sim código de identificação.",
            },
            {
              code: "EF01MA02",
              description:
                "Contar de maneira exata ou aproximada, utilizando diferentes estratégias como o pareamento e outros agrupamentos.",
            },
            {
              code: "EF01MA03",
              description:
                'Estimar e comparar quantidades de objetos de dois conjuntos (em torno de 20 elementos), por estimativa e/ou por correspondência (um a um, dois a dois) para indicar "tem mais", "tem menos" ou "tem a mesma quantidade".',
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02MA01",
              description:
                "Comparar e ordenar números naturais (até a ordem de centenas) pela compreensão de características do sistema de numeração decimal (valor posicional e função do zero).",
            },
            {
              code: "EF02MA02",
              description:
                "Fazer estimativas por meio de estratégias diversas a respeito da quantidade de objetos de coleções e registrar o resultado da contagem desses objetos (até 1000 unidades).",
            },
            {
              code: "EF02MA03",
              description:
                'Comparar quantidades de objetos de dois conjuntos, por estimativa e/ou por correspondência (um a um, dois a dois, entre outros), para indicar "tem mais", "tem menos" ou "tem a mesma quantidade", indicando, quando for o caso, quantos a mais e quantos a menos.',
            },
          ],
        },
        Ciências: {
          PRIMEIRO_ANO: [
            {
              code: "EF01CI01",
              description:
                "Comparar características de diferentes materiais presentes em objetos de uso cotidiano.",
            },
            {
              code: "EF01CI02",
              description:
                "Localizar, nomear e representar graficamente (por meio de desenhos) partes do corpo humano e explicar suas funções.",
            },
            {
              code: "EF01CI03",
              description:
                "Discutir as razões pelas quais os hábitos de higiene do corpo são necessários para a manutenção da saúde.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02CI01",
              description:
                "Identificar de que materiais (metais, madeira, vidro etc.) são feitos os objetos que fazem parte da vida cotidiana.",
            },
            {
              code: "EF02CI02",
              description:
                "Propor o uso de diferentes materiais para a construção de objetos de uso cotidiano.",
            },
            {
              code: "EF02CI03",
              description:
                "Discutir os cuidados necessários à prevenção de acidentes domésticos.",
            },
          ],
        },
      };

      document.addEventListener("DOMContentLoaded", function () {
            // Mobile menu toggle
        const mobileMenuBtn = document.getElementById("mobileMenuBtn");
        const mobileMenu = document.getElementById("mobileMenu");
            
            if (mobileMenuBtn && mobileMenu) {
          mobileMenuBtn.addEventListener("click", function () {
            mobileMenu.classList.toggle("hidden");
                });
            }
            
            // Atualizar nome do usuário
        const currentUser = JSON.parse(sessionStorage.getItem("currentUser"));
            if (currentUser) {
          document.getElementById("userName").textContent = currentUser.name;
            }
            
            // Inicializar localStorage para exams se não existir
        if (!localStorage.getItem("exams")) {
          localStorage.setItem("exams", JSON.stringify([]));
            }
            
            // Verificar se é modo de edição
            const urlParams = new URLSearchParams(window.location.search);
        const editExamId = urlParams.get("edit");
            
            if (editExamId) {
                openExamForEditing(parseInt(editExamId));
            }
            
            // Buscar provas da API
            loadExamsFromAPI();
            
            // Adicionar eventos para botões principais
            setupMainButtons();
            
            // Carregar componentes curriculares da API
            loadCurriculumComponentsFromAPI();
            
            // Configurar modal BNCC
        const closeBnccModalBtn = document.getElementById("closeBnccModal");
        const cancelBnccBtn = document.getElementById("cancelBnccBtn");
        const confirmBnccBtn = document.getElementById("confirmBnccBtn");
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const deselectAllBtn = document.getElementById("deselectAllBtn");
        const newSelectBnccBtn = document.getElementById("newSelectBnccBtn");

        if (closeBnccModalBtn)
          closeBnccModalBtn.addEventListener("click", closeBnccModal);
        if (cancelBnccBtn)
          cancelBnccBtn.addEventListener("click", closeBnccModal);
        if (confirmBnccBtn)
          confirmBnccBtn.addEventListener("click", confirmBnccSelection);
        if (bnccComponent)
          bnccComponent.addEventListener("change", updateBnccSkillsList);
        if (bnccGrade)
          bnccGrade.addEventListener("change", updateBnccSkillsList);
        if (bnccSearch) bnccSearch.addEventListener("input", filterBnccSkills);
        if (selectAllBtn)
          selectAllBtn.addEventListener("click", selectAllSkills);
        if (deselectAllBtn)
          deselectAllBtn.addEventListener("click", deselectAllSkills);
        if (newSelectBnccBtn)
          newSelectBnccBtn.addEventListener("click", openBnccSelector);
            
            // Configurar eventos para seletores BNCC em questões existentes
        document.querySelectorAll(".select-bncc-btn").forEach((btn) => {
          btn.addEventListener("click", openBnccSelector);
            });
            
            // Configurar uploads de imagem
            setupImageUploads();
            
            // Configurar botões adicionais para criar prova
        const addAnotherQuestionBtn = document.getElementById(
          "addAnotherQuestionBtn"
        );
            if (addAnotherQuestionBtn) {
          addAnotherQuestionBtn.addEventListener("click", addAnotherQuestion);
            }
            
        const finalizeExamBtnModal = document.getElementById(
          "finalizeExamBtnModal"
        );
            if (finalizeExamBtnModal) {
          finalizeExamBtnModal.addEventListener("click", finalizeExam);
            }
        });
        
        // Variáveis globais para o fluxo de criação de prova
        let currentExamData = {
        name: "",
        description: "",
        questions: [],
        };
        
        function setupMainButtons() {
            // Botão Criar Avaliação
        const createExamBtn = document.getElementById("createExamBtn");
            if (createExamBtn) {
          console.log("Adicionando evento de click ao botão Criar Avaliação");
          createExamBtn.addEventListener("click", function () {
            console.log("Botão Criar Avaliação clicado");
                    // Limpar dados da prova atual
                    currentExamData = {
              name: "",
              description: "",
              questions: [],
            };
            document
              .getElementById("createExamStepOneModal")
              .classList.remove("hidden");
                });
            }
            
            // Botão Vincular Prova
        const linkExamBtn = document.getElementById("linkExamBtn");
            if (linkExamBtn) {
          linkExamBtn.addEventListener("click", async function () {
            document.getElementById("linkExamModal").classList.remove("hidden");
                    
                    try {
                        // Configurar opções de série e turno
                        setupGradeAndShiftOptions();
                        
                        // Utilizar a função populateExamSelector para buscar provas da API
                        await populateExamSelector();
                        
                        // Utilizar a função populateSchoolSelector para buscar escolas da API
                        await populateSchoolSelector();
                    } catch (error) {
              console.error(
                "Erro ao preparar formulário de vinculação:",
                error
              );
              alert("Erro ao carregar dados para vinculação: " + error.message);
                    }
                });
            }
            
            // Botão Exportar Todas
        const exportAllExamsBtn = document.getElementById("exportAllExamsBtn");
            if (exportAllExamsBtn) {
          exportAllExamsBtn.addEventListener("click", exportAllExams);
            }
            
            // Botão Banco de Questões
        const questionBankBtn = document.getElementById("questionBankBtn");
            if (questionBankBtn) {
          questionBankBtn.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.remove("hidden");
                    loadQuestionBank();
                });
            }
            
            // Botão para adicionar questão no formulário principal
        const addQuestionBtn = document.getElementById("addQuestionBtn");
            if (addQuestionBtn) {
          addQuestionBtn.addEventListener("click", function () {
                    // Adicionar lógica para adicionar uma nova questão ao formulário
            alert(
              "Funcionalidade para adicionar questão no formulário principal"
            );
                });
            }
            
            // Botão de fechar o modal de examModal
        const closeExamModal = document.getElementById("closeExamModal");
            if (closeExamModal) {
          closeExamModal.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botão para cancelar adição de exame
        const cancelExamBtn = document.getElementById("cancelExamBtn");
            if (cancelExamBtn) {
          cancelExamBtn.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botões de fechamento de modais
            setupModalCloseButtons();
            
            // Configurar formulários
            setupFormSubmissions();
        }
        
        // Função para configurar opções de série e turno
        function setupGradeAndShiftOptions() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        function setupModalCloseButtons() {
            // Modal Criar Avaliação - Etapa 1
        document
          .getElementById("closeCreateExamStepOneModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelCreateExamStepOneBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
            });
            
            // Modal Adicionar Questão
        document
          .getElementById("closeAddQuestionModal")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
          });

        document
          .getElementById("cancelAddQuestionBtn")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
            });
            
            // Modal Opções de Questão
        document
          .getElementById("closeQuestionOptionsModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionOptionsModal")
              .classList.add("hidden");
            });
            
            // Modal Banco de Questões
        document
          .getElementById("closeQuestionBankModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelQuestionBankBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
            });
            
            // Modal Vincular Prova
        document
          .getElementById("closeLinkExamModal")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
          });

        document
          .getElementById("cancelLinkBtn")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
            });
        }
        
        function setupFormSubmissions() {
            // Formulário Etapa 1 - Informações Básicas
        const createExamStepOneForm = document.getElementById(
          "createExamStepOneForm"
        );
            if (createExamStepOneForm) {
          createExamStepOneForm.addEventListener("submit", function (e) {
                    e.preventDefault();
                    
                    // Obter dados do formulário
            const examName = document.getElementById("newExamName").value;
            const examDescription =
              document.getElementById("newExamDescription").value;
            const examEducationLevel = document.getElementById(
              "newExamEducationLevel"
            ).value;
                    
                    if (!examName) {
              alert("Por favor, insira um nome para a prova.");
                        return;
                    }
                    
                    if (!examEducationLevel) {
              alert("Por favor, selecione um nível de ensino.");
                        return;
                    }
                    
                    // Verificar se é edição ou criação
                    const isEditing = currentExamData.id !== undefined;
                    
                    // Atualizar dados da prova
                    currentExamData.name = examName;
                    currentExamData.description = examDescription;
                    currentExamData.educationLevel = examEducationLevel;
                    
            console.log(
              `${isEditing ? "Editando" : "Criando"} prova:`,
              currentExamData
            );
                    
                    // Se for edição, atualizar a prova no armazenamento
                    if (isEditing) {
              updateExam(currentExamData).then((success) => {
                            if (success) {
                                // Fechar modal
                  document
                    .getElementById("createExamStepOneModal")
                    .classList.add("hidden");
                                
                                // Atualizar lista de provas
                                loadExamsFromAPI();
                                
                                // Mostrar modal de sucesso
                  showSuccessModal(
                    "Avaliação Atualizada",
                    "A avaliação foi atualizada com sucesso!"
                  );
                            } else {
                  alert("Erro ao atualizar avaliação.");
                            }
                        });
                    } else {
                        // Processar para a próxima etapa (criação de nova prova)
              document
                .getElementById("createExamStepOneModal")
                .classList.add("hidden");
              document
                .getElementById("addQuestionModal")
                .classList.remove("hidden");
              document.getElementById("questionNumber").textContent = "1";
                        
                        // Limpar formulário de questão
              document.getElementById("addQuestionForm").reset();
                        
                        // Limpar preview de imagem se existir
              const imagePreview = document.querySelector(
                "#addQuestionModal .image-preview"
              );
                        if (imagePreview) {
                imagePreview.classList.add("hidden");
                const img = imagePreview.querySelector("img");
                if (img) img.src = "";
                        }
                    }
                });
            }
            
            // Formulário Adicionar Questão
        const addQuestionForm = document.getElementById("addQuestionForm");
            if (addQuestionForm) {
          addQuestionForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            if (!document.getElementById("questionText").value) {
              alert("Por favor, insira o texto da questão.");
                        return;
                    }
                    
            if (
              !document.querySelector('input[name="correctAnswer"]:checked')
            ) {
              alert("Por favor, selecione a alternativa correta.");
                        return;
                    }

                    try {
                        // Obter o texto da questão
              const enunciado = document.getElementById("questionText").value;
                        
                        // Obter valor de imagem (se existir)
              const fileInput = document.querySelector("#questionImage");
              const imagePreview = document.querySelector("#addQuestionModal .image-preview");
              const imagem_url = fileInput && fileInput.files[0] ? fileInput.files[0].name : "";
            
              console.log("Caminho da imagem a ser enviada:", imagem_url);
                        
                        // Obter o nível de ensino (usar valor direto da API)
              const nivel_ensino = document.getElementById("educationLevel").value;
                        
                        // Obter série
              const serie = document.getElementById("gradeLevel").value;
                        
                        // Obter dificuldade
              const dificuldade =
                document.getElementById("difficultyLevel").value;
                        
                        // Obter componente curricular ID (deve ser um número)
              const componente_curricular_id = parseInt(
                document.getElementById("curriculumComponent").value,
                10
              );
                        
                        // Processar códigos BNCC (devem ser um array de números)
              const bnccCodesInput = document.getElementById("bnccCodes");
              let codigos_bncc = [];

              if (bnccCodesInput && bnccCodesInput.value) {
                  try {
                      codigos_bncc = JSON.parse(bnccCodesInput.value);
                  } catch (e) {
                      console.warn("Erro ao processar códigos BNCC:", e);
                  }
              }
                        
                        // Obter a resposta correta
              const correctAnswer = document.querySelector(
                'input[name="correctAnswer"]:checked'
              ).value;
                        
                        // Criar array de alternativas
                        const alternativas = [];
                        
                        // Adicionar cada alternativa ao array (apenas se tiver texto)
              const optionA = document.getElementById("optionA").value.trim();
                        if (optionA) {
                            alternativas.push({
                                texto: optionA,
                  correta: correctAnswer === "A",
                            });
                        }
                        
              const optionB = document.getElementById("optionB").value.trim();
                        if (optionB) {
                            alternativas.push({
                                texto: optionB,
                  correta: correctAnswer === "B",
                            });
                        }
                        
              const optionC = document.getElementById("optionC").value.trim();
                        if (optionC) {
                            alternativas.push({
                                texto: optionC,
                  correta: correctAnswer === "C",
                            });
                        }
                        
              const optionD = document.getElementById("optionD").value.trim();
                        if (optionD) {
                            alternativas.push({
                                texto: optionD,
                  correta: correctAnswer === "D",
                            });
                        }
                        
              const optionE = document.getElementById("optionE").value.trim();
                        if (optionE) {
                            alternativas.push({
                                texto: optionE,
                  correta: correctAnswer === "E",
                            });
                        }
                        
                        // Obter ID da prova atual
              const prova_id = parseInt(currentExamData.apiId, 10);
                        
                        // Validar que temos um ID válido antes de prosseguir
                        if (isNaN(prova_id) || prova_id <= 0) {
                throw new Error(
                    "ID da prova é inválido ou não foi criado. Salve a prova primeiro."
                );
                        }
                        
                        // Construir o objeto da questão exatamente no formato solicitado
                        const questionData = {
                            enunciado,
                            imagem_url,
                            nivel_ensino,
                            dificuldade,
                            serie,
                            pontos: 1,
                            prova_id,
                            componente_curricular_id,
                            codigos_bncc,
                            alternativas,
                        };
                        
              console.log(
                "Enviando questão para API:",
                JSON.stringify(questionData, null, 2)
              );
                        
                        // Enviar a requisição para o endpoint
              const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
              const response = await fetch(`${baseUrl}/api/questoes`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(questionData),
            });
                        
                        if (!response.ok) {
                const errorText = await response
                  .text()
                  .catch(() => "Erro desconhecido");
                throw new Error(
                  `Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`
                );
                        }
                        
                        const savedQuestion = await response.json();
              console.log("Questão salva com sucesso:", savedQuestion);
                        
                        // Capturar dados da questão para o formato local (para histórico)
                        const questionDataLocal = {
                            text: enunciado,
                            educationLevel: nivel_ensino,
                            gradeLevel: serie,
                            difficultyLevel: dificuldade,
                            curriculumComponent: componente_curricular_id.toString(),
                            bnccCodes: codigos_bncc,
                            correctAnswer: correctAnswer,
                            options: {
                                A: optionA || '',
                                B: optionB || '',
                                C: optionC || '',
                                D: optionD || '',
                                E: optionE || ''
                            },
                            alternativas: alternativas.map(alt => ({
                                letra: alt.letra || "",
                                texto: alt.texto || "",
                                correta: (alt.letra || "").toUpperCase() === correctAnswer.toUpperCase()
                            })),
                            image: imagem_url,
                            apiId: savedQuestion.id,
                        };
                        
                        // Log para debug
                        console.log("Questão adicionada com alternativas:", JSON.stringify(questionDataLocal.options, null, 2));
                        
                        // Adicionar a questão à lista de questões
                        currentExamData.questions.push(questionDataLocal);
              console.log("Questão adicionada localmente:", questionDataLocal);
              console.log(
                `Total de questões: ${currentExamData.questions.length}`
              );
              console.log(
                `IMPORTANTE: Questão salva com ID da API: ${questionDataLocal.apiId}`
              );
              console.log("Estado atual das questões:");
                        currentExamData.questions.forEach((q, idx) => {
                console.log(
                  `  Questão ${idx + 1}: "${q.text.substring(
                    0,
                    30
                  )}..." - ID API: ${q.apiId || "não tem"}`
                );
                        });
                        
                        // Processar para a próxima etapa
              document
                .getElementById("addQuestionModal")
                .classList.add("hidden");
              document
                .getElementById("questionOptionsModal")
                .classList.remove("hidden");
              document.getElementById("totalQuestionsCount").textContent =
                currentExamData.questions.length;
                    } catch (error) {
              console.error("Erro ao salvar questão:", error);
                        alert(`Erro ao salvar questão: ${error.message}`);
                    }
                });
            }
            
            // Formulário Vincular Prova
        const linkExamForm = document.getElementById("linkExamForm");
            if (linkExamForm) {
          linkExamForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            const examId = document.getElementById("examSelect").value;
            const schoolId = document.getElementById("linkSchool").value;
            const grade = document.getElementById("linkGrade").value;
            const classId = document.getElementById("linkClass").value;
            const shift = document.getElementById("linkShift").value;
                    
                    if (!examId || !schoolId || !grade || !classId || !shift) {
              alert("Por favor, preencha todos os campos.");
                        return;
                    }
                    
                    // Desabilitar botão de submit e mostrar indicador de carregamento
                    const submitBtn = this.querySelector('button[type="submit"]');
                    const originalBtnText = submitBtn.innerHTML;
            submitBtn.innerHTML =
              '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
                    submitBtn.disabled = true;
                    
                    try {
                        // Enviar dados para a API com a rota correta
                        const payload = {
                            prova_id: examId,
                turma_id: classId,
                        };
                        
              console.log("Enviando dados para vincular prova:", payload);
                        
                        // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
              const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                        
                        // Enviar para a API
                        const response = await fetch(url, {
                method: "POST",
                            headers: {
                  "Content-Type": "application/json",
                            },
                body: JSON.stringify(payload),
                        });
                        
                        if (!response.ok) {
                throw new Error(
                  `Erro ao vincular prova. Status: ${response.status}`
                );
                        }
                        
                        // Fechar modal e mostrar mensagem de sucesso
              document.getElementById("linkExamModal").classList.add("hidden");
              alert("Prova vinculada com sucesso!");
                        
                        // Recarregar provas
                        loadExamsFromAPI();
                    } catch (error) {
              console.error("Erro ao vincular prova:", error);
              alert("Erro ao vincular prova: " + error.message);
                    } finally {
                        // Restaurar botão
                        submitBtn.innerHTML = originalBtnText;
                        submitBtn.disabled = false;
                    }
                });
            }
            
            // Alteração de escola no modal de vinculação
        document
          .getElementById("linkSchool")
          ?.addEventListener("change", async function () {
                const schoolId = this.value;
                if (!schoolId) return;
                
                try {
                    // Mostrar indicador de carregamento
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Carregando turmas...</option>';
                        classSelect.disabled = true;
                    }
                    
                    // Buscar turmas da API
              const response = await fetch(
                `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
                {
                  method: "GET",
                        headers: {
                    "Content-Type": "application/json",
                  },
                        }
              );
                    
                    if (!response.ok) {
                throw new Error(
                  `Erro ao carregar turmas. Status: ${response.status}`
                );
                    }
                    
                    const classes = await response.json();
                    
                    // Limpar seletor
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Selecione uma turma</option>';
                        
                        // Adicionar cada turma ao seletor
                classes.forEach((cls) => {
                  const option = document.createElement("option");
                            option.value = cls.id;
                            option.textContent = cls.nome || `Turma ${cls.id}`;
                            classSelect.appendChild(option);
                        });
                        
                        // Se não há turmas, mostrar mensagem
                        if (classes.length === 0) {
                  classSelect.innerHTML =
                    '<option value="">Nenhuma turma encontrada</option>';
                        }
                        
                        classSelect.disabled = false;
                    }
                } catch (error) {
              console.error("Erro ao buscar turmas:", error);
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Erro ao carregar turmas</option>';
                        classSelect.disabled = false;
                    }
                }
            });
        }

        // Função para adicionar outra questão
        function addAnotherQuestion() {
        document.getElementById("questionOptionsModal").classList.add("hidden");
        document.getElementById("addQuestionModal").classList.remove("hidden");
            
            // Incrementar número da questão
        const currentNumber = parseInt(
          document.getElementById("questionNumber").textContent || "1"
        );
        document.getElementById("questionNumber").textContent =
          currentNumber + 1;
            
            // Limpar formulário
        document.getElementById("addQuestionForm")?.reset();
            
            // Limpar preview de imagem se existir
        const imagePreview = document.querySelector(
          "#addQuestionModal .image-preview"
        );
            if (imagePreview) {
          imagePreview.classList.add("hidden");
          const img = imagePreview.querySelector("img");
          if (img) img.src = "";
            }
        }
        
        // Função para finalizar a criação da prova
        async function finalizeExam() {
            if (currentExamData.questions.length === 0) {
          alert(
            "Adicione pelo menos uma questão antes de finalizar a avaliação."
          );
                return;
            }
            
            // Mostrar indicador de processamento
        const finalizeBtn = document.getElementById("finalizeExamBtnModal");
            const originalBtnText = finalizeBtn.innerHTML;
        finalizeBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
            finalizeBtn.disabled = true;
            
            try {
          console.log(
            "Iniciando processo de finalização da prova:",
            currentExamData.name
          );
          console.log(
            `Total de questões a serem salvas: ${currentExamData.questions.length}`
          );
                
                // Verificar se a prova já foi criada (tem apiId)
                if (!currentExamData.apiId) {
            console.log("Prova ainda não foi criada na API. Criando agora...");
                    
                    // Determinar o nível de ensino no formato correto para a API
                    let nivelEnsino = "FUNDAMENTAL_I"; // Valor padrão
                    if (currentExamData.educationLevel) {
              switch (currentExamData.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "FUNDAMENTAL_I";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "FUNDAMENTAL_II";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "MEDIO";
                                break;
                            default:
                                nivelEnsino = "FUNDAMENTAL_I";
                        }
                    }
                    
                    // Criar a prova com dados básicos
                    const examData = {
                        nome: currentExamData.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: currentExamData.description || "",
                        nivel_ensino: nivelEnsino,
                        data_aplicacao: new Date().toISOString(),
              arquivo_url: "", // Campo obrigatório
                    };
                    
            console.log(
              "Payload para criação da prova:",
              JSON.stringify(examData, null, 2)
            );
                    
                    // 1. Primeiro, criar a prova sem questões
            const provaResponse = await fetch(
              "https://sag-sag.rak8a3.easypanel.host/api/provas",
              {
                method: "POST",
                        headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                        },
                body: JSON.stringify(examData),
              }
            );
                    
                    if (!provaResponse.ok) {
              const errorText = await provaResponse
                .text()
                .catch(() => "Erro desconhecido");
              throw new Error(
                `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
              );
                    }
                    
                    // Obter a prova criada
                    const savedExam = await provaResponse.json();
            console.log("Prova criada com sucesso. ID:", savedExam.id);
                    
                    if (!savedExam.id) {
              throw new Error(
                "A prova foi criada, mas não recebeu um ID válido da API"
              );
                    }
                    
                    // Atualizar o ID da API no exame atual
                    currentExamData.apiId = savedExam.id;
                } else {
            console.log(
              "Prova já existe na API com ID:",
              currentExamData.apiId
            );
                }
                
                // 2. Adicionar a prova ao armazenamento local
          const newExam = addExam(
            currentExamData.name,
            [],
            currentExamData.description,
            currentExamData.educationLevel
          );
                newExam.apiId = currentExamData.apiId;
                updateLocalExam(newExam);
          console.log(
            "Prova adicionada ao armazenamento local com ID da API:",
            newExam.apiId
          );
                
                // 3. Adicionar cada questão individualmente usando o endpoint /api/questoes
                const savedQuestions = [];
                const failedQuestions = [];
                
          console.log(
            `Começando a adicionar ${currentExamData.questions.length} questões...`
          );
                for (let i = 0; i < currentExamData.questions.length; i++) {
                    try {
                        const question = currentExamData.questions[i];
                        
                        // CORREÇÃO: Verificar se a questão já tem um ID da API (já foi salva)
                        if (question.apiId) {
                console.log(
                  `Questão ${i + 1}/${
                    currentExamData.questions.length
                  } já foi salva anteriormente com ID: ${question.apiId}`
                );
                            savedQuestions.push(question);
                            continue; // Pular para a próxima questão
                        }
                        
              console.log(
                `Adicionando questão ${i + 1}/${
                  currentExamData.questions.length
                }: "${question.text.substring(0, 30)}..."`
              );
                        
                        // Tentar salvar a questão usando saveQuestionToAPI
              const savedQuestion = await saveQuestionToAPI(
                question,
                currentExamData.apiId
              );
                        
                        if (savedQuestion && savedQuestion.apiId) {
                console.log(
                  `Questão ${i + 1} salva com sucesso, ID API: ${
                    savedQuestion.apiId
                  }`
                );
                            savedQuestions.push(savedQuestion);
                        } else {
                console.warn(
                  `Questão ${i + 1} foi processada, mas não retornou ID da API`
                );
                            // Ainda adicionar ao array para manter a consistência
                            savedQuestions.push(question);
                failedQuestions.push(i + 1);
                        }
                    } catch (error) {
              console.error(`Erro ao salvar questão ${i + 1}:`, error);
              failedQuestions.push(i + 1);
                    }
                }
                
                // 4. Atualizar as questões no exame local
                if (savedQuestions.length > 0) {
                    newExam.questions = savedQuestions;
                    updateLocalExam(newExam);
            console.log(
              `Exame local atualizado com ${savedQuestions.length} questões`
            );
                }
                
                // 5. Esconder modal e mostrar mensagem de sucesso
          document
            .getElementById("questionOptionsModal")
            .classList.add("hidden");
                
                // Ajustar mensagem com base no resultado
          let message = "";
                if (failedQuestions.length === 0) {
                    message = `Avaliação criada com sucesso! Todas as ${savedQuestions.length} questões foram adicionadas.`;
                } else {
                    message = `Avaliação criada com sucesso, mas ${failedQuestions.length} questões não puderam ser salvas. ${savedQuestions.length} questões foram adicionadas.`;
                }
                
          showSuccessModal("Avaliação Criada", message, () => {
                        // Limpar dados atuais
                        currentExamData = {
              name: "",
              description: "",
              questions: [],
                        };
                        
                        // Atualizar lista de provas
                        loadExamsFromAPI();
          });
                
                // 6. Atualizar a lista de provas
                await loadExamsFromAPI();
                renderExamsList();
                
          console.log("Processo de criação de prova finalizado com sucesso.");
            } catch (error) {
          console.error("Erro ao finalizar exame:", error);
          alert("Ocorreu um erro ao salvar a avaliação: " + error.message);
            } finally {
                // Restaurar botão
                finalizeBtn.innerHTML = originalBtnText;
                finalizeBtn.disabled = false;
            }
        }
        
        // Função auxiliar para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
          console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }
        
        // Script para atualizar os textos dos selects para mostrar valores dos enums
        function updateSelectOptionsToShowEnumValues() {
            // Garantir que os selects de nível de ensino tenham os valores de enum corretos
        const educationLevelSelects = document.querySelectorAll(
          ".education-level, #educationLevel, #bankEducationLevel, #newExamEducationLevel"
        );
            
            // Para cada select de nível de ensino, verificar se as opções têm os valores corretos
        educationLevelSelects.forEach((select) => {
                if (!select) return;
                
                // Verificar se já possui as opções corretas
                let hasCorrectOptions = false;
                for (let i = 0; i < select.options.length; i++) {
            if (
              select.options[i].value === "ANOS_INICIAIS" &&
              select.options[i].textContent === "Anos Iniciais"
            ) {
                        hasCorrectOptions = true;
                        break;
                    }
                }
                
                // Se já tem as opções corretas, apenas garantir que o texto seja igual ao valor
                if (hasCorrectOptions) {
            Array.from(select.options).forEach((option) => {
                        if (option.value) {
                            switch(option.value) {
                                case "ANOS_INICIAIS":
                                    option.textContent = "Anos Iniciais";
                                    break;
                                case "ANOS_FINAIS":
                                    option.textContent = "Anos Finais";
                                    break;
                                case "ENSINO_MEDIO":
                                    option.textContent = "Ensino Médio";
                                    break;
                            }
                        }
                    });
                } 
                // Caso contrário, recriar as opções com os valores corretos
                else {
                    // Salvar a opção vazia/placeholder
                    let placeholderOption = null;
                    for (let i = 0; i < select.options.length; i++) {
                        if (!select.options[i].value) {
                            placeholderOption = select.options[i].cloneNode(true);
                            break;
                        }
                    }
                    
                    // Limpar e adicionar a opção vazia se existir
            select.innerHTML = "";
                    if (placeholderOption) {
                        select.appendChild(placeholderOption);
                    }
                    
                    // Adicionar as opções com valores corretos
                    const correctValues = [
                        { value: "ANOS_INICIAIS", text: "Anos Iniciais" },
                        { value: "ANOS_FINAIS", text: "Anos Finais" },
                        { value: "ENSINO_MEDIO", text: "Ensino Médio" },
                    ];
                    
            correctValues.forEach((item) => {
              const option = document.createElement("option");
                        option.value = item.value;
                        option.textContent = item.text;
                        select.appendChild(option);
                    });
                }
            });

            // Atualizar os selects de série
            const gradeSelects = document.querySelectorAll(
                ".grade-level, #gradeLevel, #bankGrade, #linkGrade, #bnccGrade"
            );

            gradeSelects.forEach((select) => {
                if (!select) return;

                Array.from(select.options).forEach((option) => {
                    if (option.value) {
                        option.textContent = getFormattedGradeText(option.value);
                    }
                });
            });
        }
        
        // Chamar a função quando o DOM estiver carregado
      document.addEventListener("DOMContentLoaded", function () {
            // Chamar após carregar todos os outros scripts
            setTimeout(updateSelectOptionsToShowEnumValues, 500);
        });
        
        // Função para abrir o seletor de habilidades BNCC
        function openBnccSelector() {
            // Salvar referência ao elemento que receberá os códigos
        const questionItem =
          this.closest(".question-item") || this.closest("form");
        activeInputElement = questionItem
          ? questionItem.querySelector(".bncc-codes-input")
          : null;
            
            // Limpar seleções anteriores
            selectedSkills = [];
            
            // Carregar habilidades selecionadas atuais, se existirem
            if (activeInputElement && activeInputElement.value) {
          const codes = activeInputElement.value.split(",");
          codes.forEach((code) => {
                    const trimmedCode = code.trim();
                    if (trimmedCode) {
                        selectedSkills.push(trimmedCode);
                    }
                });
            }
            
            // Limpar filtros
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
            
            if (bnccComponent) bnccComponent.selectedIndex = 0;
            if (bnccGrade) bnccGrade.selectedIndex = 0;
        if (bnccSearch) bnccSearch.value = "";
            
            // Atualizar contagem de selecionados
        const selectedSkillsCount = document.getElementById(
          "selectedSkillsCount"
        );
        if (selectedSkillsCount)
          selectedSkillsCount.textContent = selectedSkills.length.toString();
            
            // Mostrar mensagem inicial
        const bnccSkillsList = document.getElementById("bnccSkillsList");
            if (bnccSkillsList) {
                bnccSkillsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        Carregando todas as habilidades... Você pode usar os filtros para restringir a lista.
                    </div>
                `;
            }
            
            // Abrir modal
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.remove("hidden");
            
            // Carregar todas as habilidades da API imediatamente
            updateBnccSkillsList();
        }
        
        // Função para fechar o modal BNCC
        function closeBnccModal() {
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.add("hidden");
        }
        
        // Função para confirmar a seleção de habilidades BNCC
        function confirmBnccSelection() {
            if (activeInputElement) {
          // Salvar códigos no input (apenas os códigos, não transformar em números)
          activeInputElement.value = selectedSkills.join(", ");
                
                // Atualizar UI
          const container =
            activeInputElement.closest(".question-item") ||
            activeInputElement.closest("form");
                if (container) {
            const countElement = container.querySelector(
              ".selected-skills-count"
            );
            const listElement = container.querySelector(
              ".selected-skills-list"
            );
                    
                    if (countElement) {
              countElement.textContent =
                selectedSkills.length > 0 ? `(${selectedSkills.length})` : "";
                    }
                    
                    if (listElement) {
              listElement.innerHTML = "";

              selectedSkills.forEach((code) => {
                const div = document.createElement("div");
                div.className =
                  "px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded flex justify-between items-center mb-1";
                            div.innerHTML = `
                                <span>${code}</span>
                                <button type="button" class="remove-skill text-blue-500 hover:text-blue-700" data-code="${code}">
                                    <i class="fas fa-times-circle"></i>
                                </button>
                            `;
                            
                            listElement.appendChild(div);
                            
                            // Adicionar evento para remover habilidade
                const removeBtn = div.querySelector(".remove-skill");
                            if (removeBtn) {
                  removeBtn.addEventListener("click", function () {
                    const codeToRemove = this.getAttribute("data-code");
                                    
                                    // Remover do array
                                    const index = selectedSkills.indexOf(codeToRemove);
                                    if (index !== -1) {
                                        selectedSkills.splice(index, 1);
                                    }
                                    
                    // Atualizar input (apenas os códigos, não transformar em números)
                    activeInputElement.value = selectedSkills.join(", ");
                                    
                                    // Remover elemento visual
                    this.closest("div").remove();
                                    
                                    // Atualizar contagem
                                    if (countElement) {
                      countElement.textContent =
                        selectedSkills.length > 0
                          ? `(${selectedSkills.length})`
                          : "";
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Fechar modal
            closeBnccModal();
        }
        
        // Função para atualizar a lista de habilidades BNCC
        function updateBnccSkillsList() {
        const component = document.getElementById("bnccComponent")?.value;
        const grade = document.getElementById("bnccGrade")?.value;
        const skillsList = document.getElementById("bnccSkillsList");
            
            if (!skillsList) return;
            
            skillsList.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-gray-500">Carregando habilidades...</p>
                </div>
            `;
            
            // Mesmo se componente e série não forem selecionados, vamos carregar todas as habilidades
        loadBnccSkillsFromAPI(grade, component)
          .then((apiSkills) => {
                // Limpar a lista
            skillsList.innerHTML = "";
                
                // Se não houver habilidades, mostrar mensagem
                if (!apiSkills || apiSkills.length === 0) {
                    skillsList.innerHTML = `
                        <div class="text-center text-gray-500 py-4">
                            Nenhuma habilidade encontrada para esta combinação
                        </div>
                    `;
                    return;
                }
                
                // Adicionar cada habilidade à lista
            apiSkills.forEach((skill) => {
              const code = skill.codigo || "";
              const description = skill.descricao || "";
                    
                    const isSelected = selectedSkills.includes(code);
              const div = document.createElement("div");
              div.className =
                "p-2 border-b border-gray-100 last:border-b-0 skill-item";
              div.setAttribute("data-code", code);
              div.setAttribute("data-visible", "true");
                    
                    div.innerHTML = `
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                              isSelected ? "checked" : ""
                            }>
                            <span class="ml-2">
                                <span class="block text-sm font-medium">${code}</span>
                                <span class="block text-xs text-gray-500">${description}</span>
                            </span>
                        </label>
                    `;
                    
                    // Adicionar evento ao checkbox
                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                checkbox.addEventListener("change", function () {
                            if (this.checked) {
                                // Adicionar à seleção
                                if (!selectedSkills.includes(code)) {
                                    selectedSkills.push(code);
                                }
                            } else {
                                // Remover da seleção
                                const index = selectedSkills.indexOf(code);
                                if (index !== -1) {
                                    selectedSkills.splice(index, 1);
                                }
                            }
                            
                            // Atualizar contagem
                  const count = document.getElementById("selectedSkillsCount");
                  if (count)
                    count.textContent = selectedSkills.length.toString();
                        });
                    }
                    
                    skillsList.appendChild(div);
                });
          })
          .catch((error) => {
            console.error("Erro ao carregar habilidades:", error);
                
                skillsList.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        Erro ao carregar habilidades. Tentando usar dados locais...
                    </div>
                `;
                
                // Tentar usar dados locais como fallback
                setTimeout(() => {
                    // Verificar se existem habilidades no banco de dados local para o componente e série
              const localComponent = Object.keys(bnccDatabase).find(
                (key) => key.toLowerCase() === component?.toLowerCase()
              );

              if (
                localComponent &&
                grade &&
                bnccDatabase[localComponent][grade]
              ) {
                        const skills = bnccDatabase[localComponent][grade];
                        
                        // Limpar a lista
                skillsList.innerHTML = "";
                        
                        // Adicionar cada habilidade local à lista
                skills.forEach((skill) => {
                            const isSelected = selectedSkills.includes(skill.code);
                  const div = document.createElement("div");
                  div.className =
                    "p-2 border-b border-gray-100 last:border-b-0 skill-item";
                  div.setAttribute("data-code", skill.code);
                  div.setAttribute("data-visible", "true");
                            
                            div.innerHTML = `
                                <label class="flex items-start cursor-pointer">
                                    <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                                      isSelected ? "checked" : ""
                                    }>
                                    <span class="ml-2">
                                        <span class="block text-sm font-medium">${
                                          skill.code
                                        }</span>
                                        <span class="block text-xs text-gray-500">${
                                          skill.description
                                        }</span>
                                    </span>
                                </label>
                            `;
                            
                            // Adicionar evento ao checkbox
                            const checkbox = div.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                    checkbox.addEventListener("change", function () {
                                    if (this.checked) {
                                        // Adicionar à seleção
                                        if (!selectedSkills.includes(skill.code)) {
                                            selectedSkills.push(skill.code);
                                        }
                                    } else {
                                        // Remover da seleção
                                        const index = selectedSkills.indexOf(skill.code);
                                        if (index !== -1) {
                                            selectedSkills.splice(index, 1);
                                        }
                                    }
                                    
                                    // Atualizar contagem
                      const count = document.getElementById(
                        "selectedSkillsCount"
                      );
                      if (count)
                        count.textContent = selectedSkills.length.toString();
                                });
                            }
                            
                            skillsList.appendChild(div);
                        });
                    } else {
                        skillsList.innerHTML = `
                            <div class="text-center text-gray-500 py-4">
                                Nenhuma habilidade encontrada ${
                                  component ? "para " + component : ""
                                } ${grade ? " - " + grade : ""}
                            </div>
                        `;
                    }
                }, 500);
            });
        }
        
        // Função para filtrar habilidades BNCC
        function filterBnccSkills() {
        const searchText =
          document.getElementById("bnccSearch")?.value.toLowerCase() || "";
        const skillItems = document.querySelectorAll(
          "#bnccSkillsList .skill-item"
        );

        skillItems.forEach((item) => {
          const code = item.getAttribute("data-code") || "";
          const description =
            item.querySelector(".text-gray-500")?.textContent.toLowerCase() ||
            "";
                
                // Verificar se o texto de busca está no código ou na descrição
          if (
            code.toLowerCase().includes(searchText) ||
            description.includes(searchText)
          ) {
            item.style.display = "";
            item.setAttribute("data-visible", "true");
                } else {
            item.style.display = "none";
            item.setAttribute("data-visible", "false");
                }
            });
        }
        
        // Função para selecionar todas as habilidades visíveis
        function selectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && !checkbox.checked && code) {
                    checkbox.checked = true;
                    
                    // Adicionar à seleção
                    if (!selectedSkills.includes(code)) {
                        selectedSkills.push(code);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para desmarcar todas as habilidades visíveis
        function deselectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && checkbox.checked && code) {
                    checkbox.checked = false;
                    
                    // Remover da seleção
                    const index = selectedSkills.indexOf(code);
                    if (index !== -1) {
                        selectedSkills.splice(index, 1);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para configurar uploads de imagem
        function setupImageUploads() {
        document.querySelectorAll(".question-image").forEach((input) => {
          input.addEventListener("change", handleImageUpload);
            });
            
        document.querySelectorAll(".remove-image").forEach((button) => {
          button.addEventListener("click", handleImageRemove);
            });
        }
        
        // Função para tratar upload de imagem
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Pegar o caminho completo do arquivo
            const filePath = file.name;
            
            const reader = new FileReader();
            const container = this.closest(".question-item") || this.closest("form");
            const previewContainer = container?.querySelector(".image-preview");
            const previewImg = previewContainer?.querySelector("img");
            const fileInput = container?.querySelector(".question-image") || container?.querySelector("#questionImage");
            
            if (!previewContainer || !previewImg || !fileInput) return;
            
            reader.onload = function (event) {
                // Mostrar preview da imagem
                previewImg.src = event.target.result;
                previewContainer.classList.remove("hidden");
                
                // Armazenar o caminho do arquivo
                fileInput.dataset.imagePath = filePath;
                
                console.log('Imagem carregada. Caminho:', filePath);
            };
            
            reader.readAsDataURL(file);
        }
        
        
        // Função para remover imagem
        function handleImageRemove() {
        const container =
          this.closest(".question-item") || this.closest("form");
        const previewContainer = container?.querySelector(".image-preview");
        const fileInput =
          container?.querySelector(".question-image") ||
          container?.querySelector("#questionImage");
            
            if (previewContainer) {
          previewContainer.classList.add("hidden");
          const img = previewContainer.querySelector("img");
          if (img) img.src = "";
            }
            
            if (fileInput) {
          fileInput.value = "";
            }
        }
        
        // Função para renderizar lista de avaliações
        function renderExamsList() {
        const examsList = document.getElementById("examsList");
            if (!examsList) return;
            
            // Obter avaliações do localStorage
            let exams = [];
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    exams = JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            
        console.log("Avaliações encontradas:", exams.length, exams);
            
            // Filtrar provas vazias - remover provas com 0 questões e que não existem no banco de dados
            // Remover também as provas simuladas específicas que foram mencionadas
            const namesToRemove = [
          "Avaliação Diagnóstica - Português",
          "Avaliação Diagnóstica - Matemática",
          "Avaliação Bimestral - Português",
          "Avaliação Bimestral - Matemática",
          "Avaliação Final - Ciências",
        ];

        exams = exams.filter((exam) => {
                // Verificar se a prova tem questões
                const questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Incluir a prova apenas se não está na lista de nomes a remover OU tem questões OU tem um ID da API
          return (
            !namesToRemove.includes(exam.name) ||
            questionsCount > 0 ||
            exam.apiId
          );
            });
            
            // Salvar a lista filtrada de volta no localStorage
        localStorage.setItem("exams", JSON.stringify(exams));
            
            // Se não há avaliações, mostrar mensagem
            if (!exams || exams.length === 0) {
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        Nenhuma prova cadastrada
                    </li>
                `;
                return;
            }
            
            // Limpar lista
        examsList.innerHTML = "";
            
            // Adicionar cada avaliação à lista
        exams.forEach((exam) => {
          const li = document.createElement("li");
          li.className = "block hover:bg-gray-50";
                
                // Verificar se a prova tem questões
                let questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Se tiver ID da API mas nenhuma questão local, tentar atualizar o contador com uma mensagem
                let questionCountText = `Questões: ${questionsCount}`;
                if (questionsCount === 0 && exam.apiId) {
                    // Tentar carregar os detalhes da prova da API para mostrar o número correto
                    loadExamDetails(exam.apiId, exams.indexOf(exam), exams)
              .then((success) => {
                            if (success) {
                                // Atualizar a visualização após carregar os detalhes
                                const updatedExams = getExams();
                  const updatedExam = updatedExams.find(
                    (e) => e.id === exam.id
                  );
                                if (updatedExam && updatedExam.questions.length > 0) {
                    const questionCountElement =
                      li.querySelector(".question-count");
                                    if (questionCountElement) {
                                        questionCountElement.textContent = `Questões: ${updatedExam.questions.length}`;
                                    }
                                }
                            }
                        })
              .catch((err) =>
                console.error("Erro ao carregar detalhes da prova:", err)
              );
                        
                    questionCountText = `<span class="question-count">Questões: ${questionsCount} <i class="fas fa-sync-alt fa-spin text-xs ml-1" title="Atualizando contador de questões..."></i></span>`;
                } else {
                    questionCountText = `<span class="question-count">Questões: ${questionsCount}</span>`;
                }
                
                // Formatar data de criação
          let createdAt = "";
                try {
                    if (exam.createdAt) {
                        const date = new Date(exam.createdAt);
              createdAt = date.toLocaleDateString("pt-BR");
                    }
                } catch (e) {
            console.error("Erro ao formatar data:", e);
                }
                
                // Badge para nível de ensino
          const educationLevelBadge = exam.educationLevel
            ? `<span class="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-800 rounded">${exam.educationLevel}</span>`
            : "";
                
          console.log(
            `Renderizando prova: ${exam.name}, API ID: ${exam.apiId}, Questões: ${questionsCount}`
          );
                
                li.innerHTML = `
                    <div class="flex items-center px-4 py-4 sm:px-6">
                        <div class="min-w-0 flex-1 flex items-center">
                            <div class="flex-shrink-0">
                                <span class="h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center">
                                    <i class="fas fa-file-alt text-yellow-600 text-lg"></i>
                                </span>
                            </div>
                            <div class="min-w-0 flex-1 px-4">
                                <div>
                                    <p class="text-sm font-medium text-blue-600 truncate">
                                        ${exam.name} ${educationLevelBadge}
                                    </p>
                                    <p class="mt-1 text-sm text-gray-500">
                                        ${questionCountText} | Criada em: ${createdAt}
                                    </p>
                                    ${
                                      exam.description
                                        ? `<p class="mt-1 text-xs text-gray-400 truncate">${exam.description}</p>`
                                        : ""
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            <button onclick="visualizarProva(${exam.apiId || exam.id})" class="bg-white text-blue-500 p-2 rounded-full hover:bg-blue-100 border border-gray-200" data-id="${exam.id}" title="Visualizar Prova"><i class="fas fa-eye"></i>
</button>
                            <button class="text-blue-600 hover:text-blue-900 editExam" data-id="${
                              exam.id
                            }" title="Editar">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="text-indigo-600 hover:text-indigo-900 editQuestionsExam" data-id="${
                              exam.id
                            }" data-api-id="${exam.apiId || ''}" title="Editar Questões">
                                <i class="fas fa-list-check"></i>
                            </button>
                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${
                              exam.id
                            }" title="Baixar PDF">
                                <i class="fas fa-file-pdf"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                examsList.appendChild(li);
            });
            
            // Adicionar eventos aos botões
            setupExamListButtons();
        }
        
        // Função para configurar botões na lista de avaliações
        function setupExamListButtons() {
            // Visualizar avaliação
            document.querySelectorAll(".viewExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    viewExam(examId);
                });
            });
            
            // Editar avaliação
            document.querySelectorAll(".editExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    openExamForEditing(examId);
                });
            });
            
            // Editar questões da avaliação
            document.querySelectorAll(".editQuestionsExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const apiId = this.getAttribute("data-api-id");
                    if (!apiId) {
                        alert("Esta prova não possui ID da API e não pode ter suas questões editadas.");
                        return;
                    }
                    openEditQuestionsModal(examId, apiId);
                });
            });
            
            // Baixar avaliação
            document.querySelectorAll(".downloadExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    if (exam) {
                        // Adicionar debug para ver a estrutura da prova
                        console.log("ESTRUTURA DA PROVA:", JSON.stringify(exam, null, 2));
                        console.log("QUESTÕES:", JSON.stringify(exam.questions, null, 2));
                        if (exam.questions && exam.questions.length > 0) {
                            console.log("PRIMEIRA QUESTÃO:", JSON.stringify(exam.questions[0], null, 2));
                            console.log("ALTERNATIVAS:", JSON.stringify(exam.questions[0].options || exam.questions[0].alternativas, null, 2));
                        }
                        exportExamToDocx(exam);
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
        }
        
        // Função para visualizar uma avaliação
        function viewExam(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Aqui você pode implementar a visualização completa da avaliação
            // Por enquanto, mostraremos algumas informações básicas
        alert(
          `Visualizando: ${exam.name}\nTotal de questões: ${exam.questions.length}`
        );
            
            // Em um caso real, você abriria um modal ou navegaria para uma página de detalhes
        }
        
        // Função para abrir uma avaliação para edição
        function openExamForEditing(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Preencher dados no modal de edição
        document.getElementById("newExamName").value = exam.name;
        document.getElementById("newExamDescription").value =
          exam.description || "";
            
            // Definir o nível de ensino
        const educationLevelSelect = document.getElementById(
          "newExamEducationLevel"
        );
            if (educationLevelSelect) {
                // Tentar encontrar o option com o valor igual ao do exame
          const eduLevel = exam.educationLevel || "";
                let optionExists = false;
                
                // Procurar pelo valor exato primeiro
                for (let i = 0; i < educationLevelSelect.options.length; i++) {
                    if (educationLevelSelect.options[i].value === eduLevel) {
                        educationLevelSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }
                
                // Se não encontrou, tentar mapear para um valor válido da API
                if (!optionExists) {
            let mappedValue = "";
                    const eduLevelUpper = eduLevel.toUpperCase();
                    
            if (
              eduLevelUpper.includes("INICIAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL I")
            ) {
              mappedValue = "ANOS_INICIAIS";
            } else if (
              eduLevelUpper.includes("FINAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL II")
            ) {
              mappedValue = "ANOS_FINAIS";
            } else if (
              eduLevelUpper.includes("MÉDIO") ||
              eduLevelUpper.includes("MEDIO")
            ) {
              mappedValue = "ENSINO_MEDIO";
                    }
                    
                    if (mappedValue) {
                        for (let i = 0; i < educationLevelSelect.options.length; i++) {
                            if (educationLevelSelect.options[i].value === mappedValue) {
                                educationLevelSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Armazenar o ID da prova que está sendo editada
            currentExamData = {
                id: exam.id,
                apiId: exam.apiId,
                name: exam.name,
          description: exam.description || "",
          questions: [...exam.questions], // Clone para não modificar o original
            };
            
            // Abrir o modal de edição
        document
          .getElementById("createExamStepOneModal")
          .classList.remove("hidden");
            
            // Atualizar o título do modal
        const modalTitle = document.querySelector("#createExamStepOneModal h3");
            if (modalTitle) {
          modalTitle.textContent = "Editar Prova";
            }
            
            // Atualizar o texto do botão
        const submitBtn = document.querySelector(
          '#createExamStepOneForm button[type="submit"]'
        );
            if (submitBtn) {
          submitBtn.textContent = "Continuar para Edição de Questões";
            }
        }
        
        // Função para atualizar uma prova existente
        async function updateExam(exam) {
            try {
          console.log("Iniciando atualização da prova ID:", exam.id);
                
                // Atualizar localmente
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
            console.log("Prova atualizada no armazenamento local");
                } else {
            throw new Error("Prova não encontrada no armazenamento local");
                }
                
                // Se tiver ID da API, atualizar remotamente
                if (exam.apiId) {
                    // Mapear o nível de ensino - usar apenas valores válidos para a API
                    let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                    if (exam.educationLevel) {
              switch (exam.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "ANOS_INICIAIS";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "ANOS_FINAIS";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "ENSINO_MEDIO";
                                break;
                            default:
                                // Caso não identifique, usar o padrão ANOS_INICIAIS
                                nivelEnsino = "ANOS_INICIAIS";
                        }
                    }
                    
                    // Converter para o formato da API
                    const apiExam = {
                        id: exam.apiId,
                        nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: exam.description || "",
                        data_aplicacao: new Date().toISOString(),
              nivel_ensino: nivelEnsino,
                    };
                    
            console.log("Dados enviados para a API:", apiExam);
                    
                    // Adicionar questões se existirem
                    if (exam.questions && exam.questions.length > 0) {
              apiExam.questoes = exam.questions.map((q) => {
                            return {
                                texto: q.text,
                                nivel_ensino: nivelEnsino,
                  serie: q.gradeLevel || "",
                  dificuldade: q.difficultyLevel || "",
                  componente_curricular: q.curriculumComponent || "",
                  codigos_bncc: q.bnccCodes || "",
                  resposta_correta: q.correctAnswer || "A",
                  alternativa_a: q.options.A || "",
                  alternativa_b: q.options.B || "",
                  alternativa_c: q.options.C || "",
                  alternativa_d: q.options.D || "",
                  alternativa_e: q.options.E || "",
                  imagem: q.image || null,
                            };
                        });
                    }
                    
            console.log(
              `Enviando atualização para a API: /api/provas/${exam.apiId}`,
              apiExam
            );

            const response = await fetch(
              `https://sag-sag.rak8a3.easypanel.host/api/provas/${exam.apiId}`,
              {
                method: "PUT",
                        headers: {
                  "Content-Type": "application/json",
                        },
                body: JSON.stringify(apiExam),
              }
            );
                    
                    if (!response.ok) {
              const errorText = await response
                .text()
                .catch(() => "Erro desconhecido");
              console.error(
                `Erro ao atualizar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
              );
              throw new Error(
                `Não foi possível atualizar a prova na API. Status: ${response.status}`
              );
                    }
                    
                    const updatedExam = await response.json().catch(() => null);
            console.log("Prova atualizada com sucesso na API:", updatedExam);
                    
                    // Se a API retornou dados atualizados, sincronizar com a cópia local
                    if (updatedExam) {
                        // Atualizar dados que possam ter sido modificados pela API
                        exam.apiId = updatedExam.id;
                        // Atualizar no armazenamento local
                        exams[index] = exam;
              localStorage.setItem("exams", JSON.stringify(exams));
                        
                        // Recarregar a lista de provas da API para garantir sincronização
              console.log("Recarregando lista de provas da API...");
                        await loadExamsFromAPI();
                    }
                    
                    // Atualizar a interface
                    renderExamsList();
            console.log("Interface atualizada com os novos dados da prova");
                    
                    return true;
                } else {
                    // Se não tem ID da API, tentar criar novo registro na API
                    try {
              console.log(
                "Prova sem ID da API. Tentando criar novo registro na API..."
              );
                        const savedExam = await saveExamToAPI(exam);
                        if (savedExam && savedExam.id) {
                            // Atualizar o ID da API na cópia local
                            exam.apiId = savedExam.id;
                            exams[index] = exam;
                localStorage.setItem("exams", JSON.stringify(exams));
                console.log("Prova criada na API com sucesso:", savedExam);
                            
                            // Recarregar a lista de provas da API
                            await loadExamsFromAPI();
                            
                            // Atualizar a interface
                            renderExamsList();
                        }
                    } catch (apiError) {
              console.error("Erro ao criar prova na API:", apiError);
                        // Continue mesmo se falhar na API, pois já temos localmente
                        
                        // Atualizar a interface de qualquer forma
                        renderExamsList();
                    }
                    return true;
                }
            } catch (error) {
          console.error("Erro ao atualizar prova:", error);
                return false;
            }
        }
        
        // Função para excluir uma avaliação
        async function deleteExam(examId) {
            // Esta função foi removida
        }
        
        // Função para obter todas as avaliações
        function getExams() {
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    return JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            return [];
        }
        
        // Função para adicionar uma nova avaliação
      function addExam(name, questions, description = "", educationLevel = "") {
            // Obter avaliações existentes
            let exams = getExams() || [];
            
            // Gerar ID único
        const newId = exams.length > 0 ? Math.max(...exams.map((e) => e.id)) + 1 : 1;
            
            // Processar as questões para garantir formato correto
            const processedQuestions = questions.map(question => {
                console.log("Processando questão para addExam:", question);
                
                // Garantir que options está no formato correto
                const options = {};
                
                // Caso 1: Se já tem um objeto options com formato {A: "texto", B: "texto"}
                if (question.options && typeof question.options === 'object' && !Array.isArray(question.options)) {
                    options.A = question.options.A || '';
                    options.B = question.options.B || '';
                    options.C = question.options.C || '';
                    options.D = question.options.D || '';
                    options.E = question.options.E || '';
                }
                // Caso 2: Se tem um array de alternativas
                else if (question.alternativas && Array.isArray(question.alternativas)) {
                    const letters = ['A', 'B', 'C', 'D', 'E'];
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letra = letters[index];
                            options[letra] = alt.texto || alt.text || '';
                        }
                    });
                }
                
                console.log("Opções processadas:", options);
                
                // Retornar questão processada
                return {
                    ...question,
                    options: options
                };
            });
            
            // Criar objeto de avaliação
            const newExam = {
                id: newId,
                name: name,
                description: description,
                educationLevel: educationLevel,
                questions: processedQuestions,
                createdAt: new Date().toISOString(),
                links: [],
            };
            
            // Adicionar à lista
            exams.push(newExam);
            
            // Salvar no localStorage
            localStorage.setItem("exams", JSON.stringify(exams));
            
            console.log("Nova avaliação adicionada:", newExam);
            
            return newExam;
        }
        
        // Função para popular o seletor de avaliações
        async function populateExamSelector() {
        const examSelect = document.getElementById("examSelect");
            if (!examSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          examSelect.innerHTML =
            '<option value="">Carregando provas...</option>';
                examSelect.disabled = true;
                
                // Buscar provas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/provas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const exams = await response.json();
          console.log("Provas carregadas da API:", exams);
                
                // Limpar seletor
          examSelect.innerHTML =
            '<option value="">Selecione uma prova</option>';
                
                // Verificar se a resposta é um array
                if (Array.isArray(exams) && exams.length > 0) {
                    // Adicionar cada prova ao seletor
            exams.forEach((exam) => {
              const option = document.createElement("option");
                        option.value = exam.id;
                        
                        // Dar preferência ao campo 'nome'
                        if (exam.nome !== undefined) {
                            option.textContent = exam.nome;
                        } else if (exam.titulo !== undefined) {
                            option.textContent = exam.titulo;
                        } else {
                option.textContent = "Prova sem título";
                        }
                        
                        examSelect.appendChild(option);
                    });
                } else {
                    // Se não houver provas, mostrar mensagem
            examSelect.innerHTML =
              '<option value="">Nenhuma prova disponível</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar provas:", error);
          examSelect.innerHTML =
            '<option value="">Erro ao carregar provas</option>';
            } finally {
                examSelect.disabled = false;
            }
            
            return examSelect;
        }
        
        // Função para popular o seletor de escolas
        async function populateSchoolSelector() {
        const schoolSelect = document.getElementById("linkSchool");
            if (!schoolSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          schoolSelect.innerHTML =
            '<option value="">Carregando escolas...</option>';
                schoolSelect.disabled = true;
                
                // Buscar escolas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/escolas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar escolas. Status: ${response.status}`
            );
                }
                
                const schools = await response.json();
                
                // Limpar seletor
          schoolSelect.innerHTML =
            '<option value="">Selecione uma escola</option>';
                
                // Adicionar cada escola ao seletor
          schools.forEach((school) => {
            const option = document.createElement("option");
                    option.value = school.id;
            option.textContent = school.nome || "Escola sem nome";
                    schoolSelect.appendChild(option);
                });
            } catch (error) {
          console.error("Erro ao buscar escolas:", error);
          schoolSelect.innerHTML =
            '<option value="">Erro ao carregar escolas</option>';
            } finally {
                schoolSelect.disabled = false;
            }
        }
        
        // Função para popular o seletor de turmas
        async function populateClassSelector(schoolId) {
        const classSelect = document.getElementById("linkClass");
            if (!classSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          classSelect.innerHTML =
            '<option value="">Carregando turmas...</option>';
                classSelect.disabled = true;
                
                if (!schoolId) {
            classSelect.innerHTML =
              '<option value="">Selecione uma escola primeiro</option>';
                    classSelect.disabled = true;
                    return;
                }
                
                // Buscar turmas da API
          const response = await fetch(
            `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar turmas. Status: ${response.status}`
            );
                }
                
                const classes = await response.json();
                
                // Limpar seletor
          classSelect.innerHTML =
            '<option value="">Selecione uma turma</option>';
                
                // Adicionar cada turma ao seletor
          classes.forEach((cls) => {
            const option = document.createElement("option");
                    option.value = cls.id;
                    option.textContent = cls.nome || `Turma ${cls.id}`;
                    classSelect.appendChild(option);
                });
                
                // Se não há turmas, mostrar mensagem
                if (classes.length === 0) {
            classSelect.innerHTML =
              '<option value="">Nenhuma turma encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar turmas:", error);
          classSelect.innerHTML =
            '<option value="">Erro ao carregar turmas</option>';
            } finally {
                classSelect.disabled = false;
            }
        }
        
        // Atualizar o formulário de vincular prova
        function updateLinkExamForm() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        // Função para vincular uma avaliação a uma turma
        async function linkExamToClass(examId, schoolId, grade, classId, shift) {
            try {
                const payload = {
                    prova_id: examId,
            turma_id: classId,
                };
                
          console.log("Enviando dados para vincular prova:", payload);
                
                // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao vincular prova. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
          console.log("Prova vinculada com sucesso:", result);
                
                return true;
            } catch (error) {
          console.error("Erro ao vincular prova:", error);
                throw error;
            }
        }
        
        // Função para exportar uma avaliação para PDF
        function exportExamToDocx(exam) {
    // Verificar se o objeto exam é válido
    if (!exam || !exam.name) {
        alert('Prova inválida para exportação!');
        return;
    }

    // Log detalhado de depuração para mostrar as alternativas
    console.log("INICIANDO EXPORTAÇÃO DA PROVA:", exam.name);
    if (exam.questions && exam.questions.length > 0) {
        exam.questions.forEach((q, index) => {
            console.log(`Questão ${index + 1}:`, q.text);
            console.log(`  Alternativas para questão ${index + 1}:`, q.options);
            
            // Verificar se as alternativas estão vazias
            const hasNonEmptyOptions = q.options && Object.values(q.options).some(opt => opt && opt.trim() !== '');
            console.log(`  Tem alternativas não vazias? ${hasNonEmptyOptions}`);
            
            if (!hasNonEmptyOptions) {
                console.warn("⚠️ ALTERNATIVAS VAZIAS DETECTADAS! Verificando alternativas originais no localStorage...");
                
                // Buscar dados originais do localStorage
                try {
                    const exams = JSON.parse(localStorage.getItem("exams")) || [];
                    const localExam = exams.find(e => e.id === exam.id);
                    if (localExam && localExam.questions) {
                        const localQuestion = localExam.questions.find(lq => lq.id === q.id || lq.apiId === q.apiId);
                        if (localQuestion && localQuestion.options) {
                            console.log("  Alternativas no localStorage:", localQuestion.options);
                            
                            // Atualizar as alternativas da questão atual com as do localStorage
                            if (Object.values(localQuestion.options).some(opt => opt && opt.trim() !== '')) {
                                console.log("  ✅ Usando alternativas do localStorage");
                                q.options = localQuestion.options;
                            }
                        }
                    }
                } catch (error) {
                    console.error("Erro ao buscar alternativas do localStorage:", error);
                }
            }
        });
    }

    // Indicar que estamos processando
    const processingMessage = document.createElement('div');
    processingMessage.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    processingMessage.innerHTML = `
        <div class="bg-white p-4 rounded-lg shadow-lg text-center">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mb-4"></div>
            <p class="text-gray-800">Gerando PDF...</p>
        </div>
    `;
    document.body.appendChild(processingMessage);

    // Função para carregar as bibliotecas necessárias (jsPDF e html2canvas)
    function loadPdfLibraries() {
        return new Promise((resolve, reject) => {
            // Verificar se as bibliotecas já estão carregadas
            if (typeof jspdf !== 'undefined' && typeof html2canvas !== 'undefined') {
                resolve({ jspdf, html2canvas });
                return;
            }

            // Contador para controlar o carregamento das duas bibliotecas
            let loaded = 0;
            
            // Carregar jsPDF
            const jspdfScript = document.createElement('script');
            jspdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            jspdfScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            jspdfScript.onerror = () => reject(new Error('Falha ao carregar jsPDF'));
            document.head.appendChild(jspdfScript);
            
            // Carregar html2canvas
            const html2canvasScript = document.createElement('script');
            html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            html2canvasScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            html2canvasScript.onerror = () => reject(new Error('Falha ao carregar html2canvas'));
            document.head.appendChild(html2canvasScript);
        });
    }

    // Função para remover a mensagem de processamento
    function removeProcessingMessage() {
        if (processingMessage && processingMessage.parentNode) {
            processingMessage.parentNode.removeChild(processingMessage);
        }
    }

    // Função para criar o conteúdo HTML que será convertido em PDF
    function createExamContent() {
        // Criar um contêiner para o conteúdo do PDF
        const container = document.createElement('div');
        container.style.width = '210mm'; // Largura A4
        container.style.padding = '20mm';
        container.style.backgroundColor = 'white';
        container.style.color = 'black';
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.top = '0';
        
        // Cabeçalho da avaliação
        container.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">AVALIAÇÃO</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">${exam.name.toUpperCase()}</h2>
                <p style="margin-bottom: 10px; font-size: 16px;">Nome do Aluno: _____________________________________________</p>
                <p style="margin-bottom: 30px; font-size: 16px;">Data: ___/___/______</p>
            </div>
            
            <!-- Instruções -->
            <div style="border: 1px solid #999; padding: 15px; margin-bottom: 30px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #666;">INSTRUÇÕES:</p>
                <p style="margin-bottom: 8px; color: #666;">1. Leia atentamente cada questão antes de respondê-la</p>
                <p style="margin-bottom: 8px; color: #666;">2. Use caneta azul ou preta para marcar suas respostas</p>
                <p style="margin-bottom: 8px; color: #666;">3. Não é permitido o uso de corretivo</p>
                <p style="color: #666;">4. Questões rasuradas serão anuladas</p>
            </div>
        `;
        
        // Adicionar questões
        if (exam.questions && exam.questions.length > 0) {
            const questionsDiv = document.createElement('div');
            
            exam.questions.forEach((question, index) => {
                const questionText = question.text || question.enunciado || "";
                if (!questionText) {
                    console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                    return;
                }
                
                // Cabeçalho da questão
                const questionDiv = document.createElement('div');
                questionDiv.style.marginBottom = '30px';
                questionDiv.style.pageBreakInside = 'avoid';
                
                questionDiv.innerHTML = `
                    <div style="border-top: 1px solid #ccc; margin-top: 15px; margin-bottom: 15px;"></div>
                    <div style="display: flex; margin-bottom: 15px;">
                        <div style="background-color: #666; color: white; padding: 8px 15px; font-weight: bold; width: 30%; display: inline-block;">
                            QUESTÃO ${index + 1}
                        </div>
                        <div style="padding: 8px 15px; width: 70%; text-align: right; display: inline-block;">
                            1 ponto
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 16px; margin-left: 15px;">${questionText}</p>
                `;
                
                // Adicionar imagem se existir
                if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                    questionDiv.innerHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <img src="${question.image}" alt="Imagem da questão" style="max-width: 80%; max-height: 200px; border: 1px solid #ddd; padding: 5px;">
                            <p style="font-style: italic; color: #666; font-size: 12px; margin-top: 5px;">Figura ${index + 1}: Imagem referente à questão</p>
                        </div>
                    `;
                }
                
                // Adicionar alternativas
                const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                let alternativas = [];
                
                if (question.options && typeof question.options === 'object') {
                    // Formato {A: "texto", B: "texto"}
                    alternativasLetras.forEach(letra => {
                        let texto = '';
                        
                        // Se tem texto na alternativa, use-o
                        if (question.options[letra] && question.options[letra].trim() !== '') {
                            texto = question.options[letra];
                        } 
                        // Caso contrário, use um texto padrão
                        else {
                            texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                        }
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                } else if (question.alternativas && Array.isArray(question.alternativas)) {
                    question.alternativas.forEach((alt, index) => {
                        if (index < alternativasLetras.length) {
                            const letra = alternativasLetras[index];
                            let texto = alt.texto || alt.text || '';
                            
                            if (!texto || texto.trim() === '') {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        }
                    });
                }
                
                // Se não encontrou alternativas, criar alternativas padrão
                if (alternativas.length === 0) {
                    alternativasLetras.forEach(letra => {
                        const texto = letra === question.correctAnswer 
                            ? `Alternativa correta ${letra}`
                            : `Alternativa ${letra}`;
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                }
                
                // Ordenar alternativas por letra
                alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                
                // Adicionar cada alternativa ao HTML
                const alternativesHtml = document.createElement('div');
                alternativesHtml.style.marginLeft = '30px';
                
                alternativas.forEach(({letra, texto}) => {
                    alternativesHtml.innerHTML += `
                        <p style="margin-bottom: 10px; font-size: 16px;">
                            <span style="display: inline-block; width: 25px; height: 25px; border-radius: 50%; border: 1px solid #666; text-align: center; line-height: 23px; margin-right: 10px; font-weight: bold;">${letra}</span>
                            ${texto}
                        </p>
                    `;
                });
                
                questionDiv.appendChild(alternativesHtml);
                questionsDiv.appendChild(questionDiv);
            });
            
            container.appendChild(questionsDiv);
        } else {
            // Se não houver questões, adicionar mensagem
            container.innerHTML += `
                <p style="text-align: center; font-style: italic; margin: 30px 0;">
                    Esta avaliação não contém questões.
                </p>
            `;
        }
        
        return container;
    }

    // Função para gerar o PDF
    async function generatePdf(libraries) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
            // Criar um link temporário para download
            const link = document.createElement('a');
            link.href = docxUrl;
            link.download = `${exam.name}.docx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log('DOCX gerado com sucesso:', `${exam.name}.docx`);
        } catch (error) {
            console.error('Erro ao gerar DOCX:', error);
            alert('Ocorreu um erro ao gerar o DOCX. Verifique o console para mais detalhes.');
        }
    }

    // Função para obter os dados da imagem
    async function fetchImageData(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        return blob;
    }

    // Função para exportar a prova para PDF
    async function exportExamToPdf(exam) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Renderizar a página atual
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = canvasWidth;
                pageCanvas.height = canvasHeight;
                const pageCtx = pageCanvas.getContext('2d');
                pageCtx.drawImage(canvas, 0, -i * pdfHeight, canvasWidth, canvasHeight);
                
                const imgData = pageCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            }
            
            // Salvar o PDF
            const pdfName = `${exam.name}.pdf`;
            pdf.save(pdfName);
            
            // Remover o conteúdo do PDF do DOM
            document.body.removeChild(contentElement);
            
            console.log('PDF gerado com sucesso:', pdfName);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert('Ocorreu um erro ao gerar o PDF. Verifique o console para mais detalhes.');
        }
    }

    // Função para exportar a prova para DOCX
    async function exportExamToDocx(exam) {
        try {
            console.log('Iniciando exportação da prova para DOCX:', exam.name);
            
            // Obter referência à biblioteca
            const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle, VerticalAlign } = libraries.docx;
            
            // Criar um novo documento
            const doc = new Document();
            
            // Adicionar cabeçalho
            const header = new Paragraph({
                text: 'AVALIAÇÃO',
                heading: HeadingLevel.HEADING_1,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [header]
            });
            
            // Adicionar nome da prova
            const examName = new Paragraph({
                text: exam.name.toUpperCase(),
                heading: HeadingLevel.HEADING_2,
                alignment: AlignmentType.CENTER
            });
            doc.addSection({
                children: [examName]
            });
            
            // Adicionar instruções
            const instructions = [
                '1. Leia atentamente cada questão antes de respondê-la',
                '2. Use caneta azul ou preta para marcar suas respostas',
                '3. Não é permitido o uso de corretivo',
                '4. Questões rasuradas serão anuladas'
            ];
            
            const instructionsParagraph = new Paragraph({
                children: [
                    new TextRun({
                        text: 'INSTRUÇÕES:',
                        bold: true
                    })
                ]
            });
            doc.addSection({
                children: [instructionsParagraph]
            });
            
            instructions.forEach(instruction => {
                const instructionParagraph = new Paragraph({
                    text: instruction
                });
                doc.addSection({
                    children: [instructionParagraph]
                });
            });
            
            // Adicionar questões
            if (exam.questions && exam.questions.length > 0) {
                exam.questions.forEach((question, index) => {
                    const questionText = question.text || question.enunciado || "";
                    if (!questionText) {
                        console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                        return;
                    }
                    
                    // Adicionar cabeçalho da questão
                    const questionHeader = new Paragraph({
                        text: `QUESTÃO ${index + 1}`,
                        heading: HeadingLevel.HEADING_3,
                        alignment: AlignmentType.CENTER
                    });
                    doc.addSection({
                        children: [questionHeader]
                    });
                    
                    // Adicionar enunciado da questão
                    const questionParagraph = new Paragraph({
                        text: questionText
                    });
                    doc.addSection({
                        children: [questionParagraph]
                    });
                    
                    // Adicionar imagem se existir
                    if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                        const image = new ImageRun({
                            data: await fetchImageData(question.image),
                            transformation: {
                                width: 400,
                                height: 200
                            }
                        });
                        const imageParagraph = new Paragraph({
                            children: [image],
                            alignment: AlignmentType.CENTER
                        });
                        doc.addSection({
                            children: [imageParagraph]
                        });
                    }
                    
                    // Adicionar alternativas
                    const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                    let alternativas = [];
                    
                    if (question.options && typeof question.options === 'object') {
                        // Formato {A: "texto", B: "texto"}
                        alternativasLetras.forEach(letra => {
                            let texto = '';
                            
                            // Se tem texto na alternativa, use-o
                            if (question.options[letra] && question.options[letra].trim() !== '') {
                                texto = question.options[letra];
                            } 
                            // Caso contrário, use um texto padrão
                            else {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    } else if (question.alternativas && Array.isArray(question.alternativas)) {
                        question.alternativas.forEach((alt, index) => {
                            if (index < alternativasLetras.length) {
                                const letra = alternativasLetras[index];
                                let texto = alt.texto || alt.text || '';
                                
                                if (!texto || texto.trim() === '') {
                                    texto = letra === question.correctAnswer 
                                        ? `Alternativa correta ${letra}`
                                        : `Alternativa ${letra}`;
                                }
                                
                                alternativas.push({
                                    letra: letra,
                                    texto: texto
                                });
                            }
                        });
                    }
                    
                    // Se não encontrou alternativas, criar alternativas padrão
                    if (alternativas.length === 0) {
                        alternativasLetras.forEach(letra => {
                            const texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        });
                    }
                    
                    // Ordenar alternativas por letra
                    alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                    
                    // Adicionar cada alternativa ao documento
                    alternativas.forEach(({letra, texto}) => {
                        const alternativaParagraph = new Paragraph({
                            text: `${letra}) ${texto}`
                        });
                        doc.addSection({
                            children: [alternativaParagraph]
                        });
                    });
                });
            } else {
                // Se não houver questões, adicionar mensagem
                const noQuestionsParagraph = new Paragraph({
                    text: 'Esta avaliação não contém questões.',
                    alignment: AlignmentType.CENTER,
                    italics: true
                });
                doc.addSection({
                    children: [noQuestionsParagraph]
                });
            }
            
            // Gerar o arquivo DOCX
            const docxBlob = await Packer.toBlob(doc);
            const docxUrl = URL.createObjectURL(docxBlob);
            
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Provas - SAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
        /* Ajustes de layout */
        .container-full {
            width: 100%;
            max-width: 100%;
            padding-left: 0;
            padding-right: 0;
        }
        .modal-overflow {
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ajusta layout em dispositivos móveis */
        @media (max-width: 768px) {
            .mobile-padding {
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    
    
    <!-- Success Modal -->
    <div
      id="successModal"
      class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
    >
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4">
            <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-medium text-gray-900" id="successModalTitle">
            Operação Concluída
          </h3>
          <button
            id="closeSuccessModal"
            class="text-gray-400 hover:text-gray-500"
          >
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mb-6 text-center">
                <div class="text-green-500 text-4xl mb-4">
                    <i class="fas fa-check-circle"></i>
                </div>
          <p class="text-gray-700" id="successModalMessage">
            Operação realizada com sucesso!
          </p>
            </div>
            <div class="flex justify-center">
          <button
            id="successModalOkBtn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
                    OK
                </button>
            </div>
        </div>
    </div>
    <!-- Modal -->
<div id="modalProva" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 overflow-y-auto h-full w-full">
  <div class="relative top-20 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <!-- Cabeçalho -->
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-2xl font-bold text-gray-800">Questões da Prova</h3>
      <button onclick="fecharModal()" class="text-gray-500 hover:text-gray-700">&times;</button>
    </div>
    
    <!-- Conteúdo das questões -->
    <div id="questoesContainer" class="space-y-4 max-h-96 overflow-y-auto">
      <!-- As questões serão inseridas aqui via JavaScript -->
    </div>
    
    <!-- Loading -->
    <div id="loading" class="text-center py-4 hidden">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto"></div>
    </div>
  </div>
</div>
<script>
  function visualizarProva(provaId) {
  console.log("ID da prova visualizada:", provaId);

  const modal = document.getElementById("modalProva");
  const loading = document.getElementById("loading");
  const questoesContainer = document.getElementById("questoesContainer");

  modal.classList.remove("hidden");
  loading.classList.remove("hidden");
  questoesContainer.innerHTML = "";

  fetch(
    `https://sag-sag.rak8a3.easypanel.host/api/provas/${provaId}/questoes-detalhadas`
  )
    .then((response) => response.json())
    .then((data) => {
      if (data.questoes && data.questoes.length > 0) {
        questoesContainer.innerHTML = data.questoes
          .map(
            (questao, index) => `
            <div class="p-4 border rounded-lg">
              <h4 class="font-semibold mb-2">Questão ${index + 1}</h4>
              <p class="text-gray-600 mb-3">${questao.enunciado}</p>
              <ul class="space-y-2">
                ${questao.alternativas
                  .map(
                    (alt) => `
                  <li class="${
                    alt.correta
                      ? "bg-green-100 border-l-4 border-green-500"
                      : ""
                  } p-2 rounded">
                    ${alt.texto}
                  </li>
                `
                  )
                  .join("")}
              </ul>
            </div>
          `
          )
          .join("");
      } else {
        questoesContainer.innerHTML =
          '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
      }
    })
    .catch((error) => {
      console.error("Erro:", error);
      questoesContainer.innerHTML =
        '<p class="text-center text-red-500">Erro ao carregar questões</p>';
    })
    .finally(() => {
      loading.classList.add("hidden");
    });
}

        } else {
          questoesContainer.innerHTML = '<p class="text-center text-gray-500">Nenhuma questão encontrada</p>';
        }
      })
      .catch(error => {
        console.error('Erro:', error);
        questoesContainer.innerHTML = '<p class="text-center text-red-500">Erro ao carregar questões</p>';
      })
      .finally(() => {
        loading.classList.add('hidden');
      });
  }
  
  function fecharModal() {
    document.getElementById('modalProva').classList.add('hidden');
  }
  
  // Fechar modal ao clicar fora
  window.onclick = function(event) {
    const modal = document.getElementById('modalProva');
    if (event.target === modal) {
      fecharModal();
    }
  }
  </script>
    <script src="js/app.js"></script>
    <script src="js/alert.js"></script>
    <script>
        // Global variables para gerenciamento de habilidades BNCC
        let selectedSkills = [];
        let activeInputElement = null;

        // Base de dados de habilidades BNCC
        const bnccDatabase = {
        Português: {
          PRIMEIRO_ANO: [
            {
              code: "EF01LP01",
              description:
                "Reconhecer que textos são lidos e escritos da esquerda para a direita e de cima para baixo da página.",
            },
            {
              code: "EF01LP02",
              description:
                "Escrever, espontaneamente ou por ditado, palavras e frases de forma alfabética – usando letras/grafemas que representem fonemas.",
            },
            {
              code: "EF01LP03",
              description:
                "Observar escritas convencionais, comparando-as às suas produções escritas, percebendo semelhanças e diferenças.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02LP01",
              description:
                "Utilizar, ao produzir o texto, grafia correta de palavras conhecidas ou com estruturas silábicas já dominadas, letras maiúsculas em início de frases e em substantivos próprios, segmentação entre as palavras, ponto final, ponto de interrogação e ponto de exclamação.",
            },
            {
              code: "EF02LP02",
              description:
                "Segmentar palavras em sílabas e remover e substituir sílabas iniciais, mediais ou finais para criar novas palavras.",
            },
            {
              code: "EF02LP03",
              description:
                "Ler e escrever palavras com correspondências regulares diretas entre letras e fonemas (f, v, t, d, p, b) e correspondências regulares contextuais (c e q; e e o, em posição átona em final de palavra).",
            },
          ],
        },
        Matemática: {
          PRIMEIRO_ANO: [
            {
              code: "EF01MA01",
              description:
                "Utilizar números naturais como indicador de quantidade ou de ordem em diferentes situações cotidianas e reconhecer situações em que os números não indicam contagem nem ordem, mas sim código de identificação.",
            },
            {
              code: "EF01MA02",
              description:
                "Contar de maneira exata ou aproximada, utilizando diferentes estratégias como o pareamento e outros agrupamentos.",
            },
            {
              code: "EF01MA03",
              description:
                'Estimar e comparar quantidades de objetos de dois conjuntos (em torno de 20 elementos), por estimativa e/ou por correspondência (um a um, dois a dois) para indicar "tem mais", "tem menos" ou "tem a mesma quantidade".',
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02MA01",
              description:
                "Comparar e ordenar números naturais (até a ordem de centenas) pela compreensão de características do sistema de numeração decimal (valor posicional e função do zero).",
            },
            {
              code: "EF02MA02",
              description:
                "Fazer estimativas por meio de estratégias diversas a respeito da quantidade de objetos de coleções e registrar o resultado da contagem desses objetos (até 1000 unidades).",
            },
            {
              code: "EF02MA03",
              description:
                'Comparar quantidades de objetos de dois conjuntos, por estimativa e/ou por correspondência (um a um, dois a dois, entre outros), para indicar "tem mais", "tem menos" ou "tem a mesma quantidade", indicando, quando for o caso, quantos a mais e quantos a menos.',
            },
          ],
        },
        Ciências: {
          PRIMEIRO_ANO: [
            {
              code: "EF01CI01",
              description:
                "Comparar características de diferentes materiais presentes em objetos de uso cotidiano.",
            },
            {
              code: "EF01CI02",
              description:
                "Localizar, nomear e representar graficamente (por meio de desenhos) partes do corpo humano e explicar suas funções.",
            },
            {
              code: "EF01CI03",
              description:
                "Discutir as razões pelas quais os hábitos de higiene do corpo são necessários para a manutenção da saúde.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02CI01",
              description:
                "Identificar de que materiais (metais, madeira, vidro etc.) são feitos os objetos que fazem parte da vida cotidiana.",
            },
            {
              code: "EF02CI02",
              description:
                "Propor o uso de diferentes materiais para a construção de objetos de uso cotidiano.",
            },
            {
              code: "EF02CI03",
              description:
                "Discutir os cuidados necessários à prevenção de acidentes domésticos.",
            },
          ],
        },
      };

      document.addEventListener("DOMContentLoaded", function () {
            // Mobile menu toggle
        const mobileMenuBtn = document.getElementById("mobileMenuBtn");
        const mobileMenu = document.getElementById("mobileMenu");
            
            if (mobileMenuBtn && mobileMenu) {
          mobileMenuBtn.addEventListener("click", function () {
            mobileMenu.classList.toggle("hidden");
                });
            }
            
            // Atualizar nome do usuário
        const currentUser = JSON.parse(sessionStorage.getItem("currentUser"));
            if (currentUser) {
          document.getElementById("userName").textContent = currentUser.name;
            }
            
            // Inicializar localStorage para exams se não existir
        if (!localStorage.getItem("exams")) {
          localStorage.setItem("exams", JSON.stringify([]));
            }
            
            // Verificar se é modo de edição
            const urlParams = new URLSearchParams(window.location.search);
        const editExamId = urlParams.get("edit");
            
            if (editExamId) {
                openExamForEditing(parseInt(editExamId));
            }
            
            // Buscar provas da API
            loadExamsFromAPI();
            
            // Adicionar eventos para botões principais
            setupMainButtons();
            
            // Carregar componentes curriculares da API
            loadCurriculumComponentsFromAPI();
            
            // Configurar modal BNCC
        const closeBnccModalBtn = document.getElementById("closeBnccModal");
        const cancelBnccBtn = document.getElementById("cancelBnccBtn");
        const confirmBnccBtn = document.getElementById("confirmBnccBtn");
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const deselectAllBtn = document.getElementById("deselectAllBtn");
        const newSelectBnccBtn = document.getElementById("newSelectBnccBtn");

        if (closeBnccModalBtn)
          closeBnccModalBtn.addEventListener("click", closeBnccModal);
        if (cancelBnccBtn)
          cancelBnccBtn.addEventListener("click", closeBnccModal);
        if (confirmBnccBtn)
          confirmBnccBtn.addEventListener("click", confirmBnccSelection);
        if (bnccComponent)
          bnccComponent.addEventListener("change", updateBnccSkillsList);
        if (bnccGrade)
          bnccGrade.addEventListener("change", updateBnccSkillsList);
        if (bnccSearch) bnccSearch.addEventListener("input", filterBnccSkills);
        if (selectAllBtn)
          selectAllBtn.addEventListener("click", selectAllSkills);
        if (deselectAllBtn)
          deselectAllBtn.addEventListener("click", deselectAllSkills);
        if (newSelectBnccBtn)
          newSelectBnccBtn.addEventListener("click", openBnccSelector);
            
            // Configurar eventos para seletores BNCC em questões existentes
        document.querySelectorAll(".select-bncc-btn").forEach((btn) => {
          btn.addEventListener("click", openBnccSelector);
            });
            
            // Configurar uploads de imagem
            setupImageUploads();
            
            // Configurar botões adicionais para criar prova
        const addAnotherQuestionBtn = document.getElementById(
          "addAnotherQuestionBtn"
        );
            if (addAnotherQuestionBtn) {
          addAnotherQuestionBtn.addEventListener("click", addAnotherQuestion);
            }
            
        const finalizeExamBtnModal = document.getElementById(
          "finalizeExamBtnModal"
        );
            if (finalizeExamBtnModal) {
          finalizeExamBtnModal.addEventListener("click", finalizeExam);
            }
        });
        
        // Variáveis globais para o fluxo de criação de prova
        let currentExamData = {
        name: "",
        description: "",
        questions: [],
        };
        
        function setupMainButtons() {
            // Botão Criar Avaliação
        const createExamBtn = document.getElementById("createExamBtn");
            if (createExamBtn) {
          console.log("Adicionando evento de click ao botão Criar Avaliação");
          createExamBtn.addEventListener("click", function () {
            console.log("Botão Criar Avaliação clicado");
                    // Limpar dados da prova atual
                    currentExamData = {
              name: "",
              description: "",
              questions: [],
            };
            document
              .getElementById("createExamStepOneModal")
              .classList.remove("hidden");
                });
            }
            
            // Botão Vincular Prova
        const linkExamBtn = document.getElementById("linkExamBtn");
            if (linkExamBtn) {
          linkExamBtn.addEventListener("click", async function () {
            document.getElementById("linkExamModal").classList.remove("hidden");
                    
                    try {
                        // Configurar opções de série e turno
                        setupGradeAndShiftOptions();
                        
                        // Utilizar a função populateExamSelector para buscar provas da API
                        await populateExamSelector();
                        
                        // Utilizar a função populateSchoolSelector para buscar escolas da API
                        await populateSchoolSelector();
                    } catch (error) {
              console.error(
                "Erro ao preparar formulário de vinculação:",
                error
              );
              alert("Erro ao carregar dados para vinculação: " + error.message);
                    }
                });
            }
            
            // Botão Exportar Todas
        const exportAllExamsBtn = document.getElementById("exportAllExamsBtn");
            if (exportAllExamsBtn) {
          exportAllExamsBtn.addEventListener("click", exportAllExams);
            }
            
            // Botão Banco de Questões
        const questionBankBtn = document.getElementById("questionBankBtn");
            if (questionBankBtn) {
          questionBankBtn.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.remove("hidden");
                    loadQuestionBank();
                });
            }
            
            // Botão para adicionar questão no formulário principal
        const addQuestionBtn = document.getElementById("addQuestionBtn");
            if (addQuestionBtn) {
          addQuestionBtn.addEventListener("click", function () {
                    // Adicionar lógica para adicionar uma nova questão ao formulário
            alert(
              "Funcionalidade para adicionar questão no formulário principal"
            );
                });
            }
            
            // Botão de fechar o modal de examModal
        const closeExamModal = document.getElementById("closeExamModal");
            if (closeExamModal) {
          closeExamModal.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botão para cancelar adição de exame
        const cancelExamBtn = document.getElementById("cancelExamBtn");
            if (cancelExamBtn) {
          cancelExamBtn.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botões de fechamento de modais
            setupModalCloseButtons();
            
            // Configurar formulários
            setupFormSubmissions();
        }
        
        // Função para configurar opções de série e turno
        function setupGradeAndShiftOptions() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        function setupModalCloseButtons() {
            // Modal Criar Avaliação - Etapa 1
        document
          .getElementById("closeCreateExamStepOneModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelCreateExamStepOneBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
            });
            
            // Modal Adicionar Questão
        document
          .getElementById("closeAddQuestionModal")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
          });

        document
          .getElementById("cancelAddQuestionBtn")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
            });
            
            // Modal Opções de Questão
        document
          .getElementById("closeQuestionOptionsModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionOptionsModal")
              .classList.add("hidden");
            });
            
            // Modal Banco de Questões
        document
          .getElementById("closeQuestionBankModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelQuestionBankBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
            });
            
            // Modal Vincular Prova
        document
          .getElementById("closeLinkExamModal")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
          });

        document
          .getElementById("cancelLinkBtn")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
            });
        }
        
        function setupFormSubmissions() {
            // Formulário Etapa 1 - Informações Básicas
        const createExamStepOneForm = document.getElementById(
          "createExamStepOneForm"
        );
            if (createExamStepOneForm) {
          createExamStepOneForm.addEventListener("submit", function (e) {
                    e.preventDefault();
                    
                    // Obter dados do formulário
            const examName = document.getElementById("newExamName").value;
            const examDescription =
              document.getElementById("newExamDescription").value;
            const examEducationLevel = document.getElementById(
              "newExamEducationLevel"
            ).value;
                    
                    if (!examName) {
              alert("Por favor, insira um nome para a prova.");
                        return;
                    }
                    
                    if (!examEducationLevel) {
              alert("Por favor, selecione um nível de ensino.");
                        return;
                    }
                    
                    // Verificar se é edição ou criação
                    const isEditing = currentExamData.id !== undefined;
                    
                    // Atualizar dados da prova
                    currentExamData.name = examName;
                    currentExamData.description = examDescription;
                    currentExamData.educationLevel = examEducationLevel;
                    
            console.log(
              `${isEditing ? "Editando" : "Criando"} prova:`,
              currentExamData
            );
                    
                    // Se for edição, atualizar a prova no armazenamento
                    if (isEditing) {
              updateExam(currentExamData).then((success) => {
                            if (success) {
                                // Fechar modal
                  document
                    .getElementById("createExamStepOneModal")
                    .classList.add("hidden");
                                
                                // Atualizar lista de provas
                                loadExamsFromAPI();
                                
                                // Mostrar modal de sucesso
                  showSuccessModal(
                    "Avaliação Atualizada",
                    "A avaliação foi atualizada com sucesso!"
                  );
                            } else {
                  alert("Erro ao atualizar avaliação.");
                            }
                        });
                    } else {
                        // Processar para a próxima etapa (criação de nova prova)
              document
                .getElementById("createExamStepOneModal")
                .classList.add("hidden");
              document
                .getElementById("addQuestionModal")
                .classList.remove("hidden");
              document.getElementById("questionNumber").textContent = "1";
                        
                        // Limpar formulário de questão
              document.getElementById("addQuestionForm").reset();
                        
                        // Limpar preview de imagem se existir
              const imagePreview = document.querySelector(
                "#addQuestionModal .image-preview"
              );
                        if (imagePreview) {
                imagePreview.classList.add("hidden");
                const img = imagePreview.querySelector("img");
                if (img) img.src = "";
                        }
                    }
                });
            }
            
            // Formulário Adicionar Questão
        const addQuestionForm = document.getElementById("addQuestionForm");
            if (addQuestionForm) {
          addQuestionForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            if (!document.getElementById("questionText").value) {
              alert("Por favor, insira o texto da questão.");
                        return;
                    }
                    
            if (
              !document.querySelector('input[name="correctAnswer"]:checked')
            ) {
              alert("Por favor, selecione a alternativa correta.");
                        return;
                    }

                    try {
                        // ADICIONAR: Verificar se a prova já foi criada na API
                        if (!currentExamData.apiId) {
                console.log("Prova ainda não foi criada na API. Criando agora...");
                            
                            try {
                                // Criar a prova na API
                                const examData = {
                                    nome: currentExamData.name,
                                    descricao: currentExamData.description || "",
                                    data_aplicacao: new Date().toISOString(),
                                    nivel_ensino: currentExamData.educationLevel
                                };
                                
                                const provaResponse = await fetch(
                                    "https://sag-sag.rak8a3.easypanel.host/api/provas",
                                    {
                                        method: "POST",
                                        headers: {
                                            "Content-Type": "application/json",
                                            Accept: "application/json",
                                        },
                                        body: JSON.stringify(examData),
                                    }
                                );
                                
                                if (!provaResponse.ok) {
                                    const errorText = await provaResponse
                                        .text()
                                        .catch(() => "Erro desconhecido");
                                    throw new Error(
                                        `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
                                    );
                                }
                                
                                // Obter a prova criada
                                const savedExam = await provaResponse.json();
                                console.log("Prova criada com sucesso. ID:", savedExam.id);
                                
                                if (!savedExam.id) {
                                    throw new Error(
                                        "A prova foi criada, mas não recebeu um ID válido da API"
                                    );
                                }
                                
                                // Atualizar o ID da API no objeto currentExamData
                                currentExamData.apiId = savedExam.id;
                                
                            } catch (error) {
                                console.error("Erro ao criar prova:", error);
                                alert(`Erro ao criar prova: ${error.message}`);
                                return; // Interromper processamento
                            }
                        }
                        
                        // Obter o texto da questão
              const enunciado = document.getElementById("questionText").value;
                        
                        // Obter valor de imagem (se existir)
              const fileInput = document.querySelector("#questionImage");
              const imagePreview = document.querySelector("#addQuestionModal .image-preview");
              const imagem_url = fileInput && fileInput.files[0] ? fileInput.files[0].name : "";
            
              console.log("Caminho da imagem a ser enviada:", imagem_url);
                        
                        // Obter o nível de ensino (usar valor direto da API)
              const nivel_ensino = document.getElementById("educationLevel").value;
                        
                        // Obter série
              const serie = document.getElementById("gradeLevel").value;
                        
                        // Obter dificuldade
              const dificuldade =
                document.getElementById("difficultyLevel").value;
                        
                        // Obter componente curricular ID (deve ser um número)
              const componente_curricular_id = parseInt(
                document.getElementById("curriculumComponent").value,
                10
              );
                        
                        // Processar códigos BNCC (devem ser um array de números)
              const bnccCodesInput = document.getElementById("bnccCodes");
              let codigos_bncc = [];

              if (bnccCodesInput && bnccCodesInput.value) {
                  try {
                      codigos_bncc = JSON.parse(bnccCodesInput.value);
                  } catch (e) {
                      console.warn("Erro ao processar códigos BNCC:", e);
                  }
              }
                        
                        // Obter a resposta correta
              const correctAnswer = document.querySelector(
                'input[name="correctAnswer"]:checked'
              ).value;
                        
                        // Criar array de alternativas
                        const alternativas = [];
                        
                        // Adicionar cada alternativa ao array (apenas se tiver texto)
              const optionA = document.getElementById("optionA").value.trim();
                        if (optionA) {
                            alternativas.push({
                                texto: optionA,
                  correta: correctAnswer === "A",
                            });
                        }
                        
              const optionB = document.getElementById("optionB").value.trim();
                        if (optionB) {
                            alternativas.push({
                                texto: optionB,
                  correta: correctAnswer === "B",
                            });
                        }
                        
              const optionC = document.getElementById("optionC").value.trim();
                        if (optionC) {
                            alternativas.push({
                                texto: optionC,
                  correta: correctAnswer === "C",
                            });
                        }
                        
              const optionD = document.getElementById("optionD").value.trim();
                        if (optionD) {
                            alternativas.push({
                                texto: optionD,
                  correta: correctAnswer === "D",
                            });
                        }
                        
              const optionE = document.getElementById("optionE").value.trim();
                        if (optionE) {
                            alternativas.push({
                                texto: optionE,
                  correta: correctAnswer === "E",
                            });
                        }
                        
                        // Obter ID da prova atual
              const prova_id = parseInt(currentExamData.apiId, 10);
                        
                        // Validar que temos um ID válido antes de prosseguir
                        if (isNaN(prova_id) || prova_id <= 0) {
                throw new Error(
                    "ID da prova é inválido ou não foi criado. Salve a prova primeiro."
                );
                        }
                        
                        // Construir o objeto da questão exatamente no formato solicitado
                        const questionData = {
                            enunciado,
                            imagem_url,
                            nivel_ensino,
                            dificuldade,
                            serie,
                            pontos: 1,
                            prova_id,
                            componente_curricular_id,
                            codigos_bncc,
                            alternativas,
                        };
                        
              console.log(
                "Enviando questão para API:",
                JSON.stringify(questionData, null, 2)
              );
                        
                        // Enviar a requisição para o endpoint
              const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
              const response = await fetch(`${baseUrl}/api/questoes`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(questionData),
            });
                        
                        if (!response.ok) {
                const errorText = await response
                  .text()
                  .catch(() => "Erro desconhecido");
                throw new Error(
                  `Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`
                );
                        }
                        
                        const savedQuestion = await response.json();
              console.log("Questão salva com sucesso:", savedQuestion);
                        
                        // Capturar dados da questão para o formato local (para histórico)
                        const questionDataLocal = {
                            text: enunciado,
                            educationLevel: nivel_ensino,
                            gradeLevel: serie,
                            difficultyLevel: dificuldade,
                            curriculumComponent: componente_curricular_id.toString(),
                            bnccCodes: codigos_bncc,
                            correctAnswer: correctAnswer,
                            options: {
                                A: optionA || '',
                                B: optionB || '',
                                C: optionC || '',
                                D: optionD || '',
                                E: optionE || ''
                            },
                            alternativas: alternativas.map(alt => ({
                                letra: alt.letra || "",
                                texto: alt.texto || "",
                                correta: (alt.letra || "").toUpperCase() === correctAnswer.toUpperCase()
                            })),
                            image: imagem_url,
                            apiId: savedQuestion.id,
                        };
                        
                        // Log para debug
                        console.log("Questão adicionada com alternativas:", JSON.stringify(questionDataLocal.options, null, 2));
                        
                        // Adicionar a questão à lista de questões
                        currentExamData.questions.push(questionDataLocal);
              console.log("Questão adicionada localmente:", questionDataLocal);
              console.log(
                `Total de questões: ${currentExamData.questions.length}`
              );
              console.log(
                `IMPORTANTE: Questão salva com ID da API: ${questionDataLocal.apiId}`
              );
              console.log("Estado atual das questões:");
                        currentExamData.questions.forEach((q, idx) => {
                console.log(
                  `  Questão ${idx + 1}: "${q.text.substring(
                    0,
                    30
                  )}..." - ID API: ${q.apiId || "não tem"}`
                );
                        });
                        
                        // Processar para a próxima etapa
              document
                .getElementById("addQuestionModal")
                .classList.add("hidden");
              document
                .getElementById("questionOptionsModal")
                .classList.remove("hidden");
              document.getElementById("totalQuestionsCount").textContent =
                currentExamData.questions.length;
                    } catch (error) {
              console.error("Erro ao salvar questão:", error);
                        alert(`Erro ao salvar questão: ${error.message}`);
                    }
                });
            }
            
            // Formulário Vincular Prova
        const linkExamForm = document.getElementById("linkExamForm");
            if (linkExamForm) {
          linkExamForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            const examId = document.getElementById("examSelect").value;
            const schoolId = document.getElementById("linkSchool").value;
            const grade = document.getElementById("linkGrade").value;
            const classId = document.getElementById("linkClass").value;
            const shift = document.getElementById("linkShift").value;
                    
                    if (!examId || !schoolId || !grade || !classId || !shift) {
              alert("Por favor, preencha todos os campos.");
                        return;
                    }
                    
                    // Desabilitar botão de submit e mostrar indicador de carregamento
                    const submitBtn = this.querySelector('button[type="submit"]');
                    const originalBtnText = submitBtn.innerHTML;
            submitBtn.innerHTML =
              '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
                    submitBtn.disabled = true;
                    
                    try {
                        // Enviar dados para a API com a rota correta
                        const payload = {
                            prova_id: examId,
                turma_id: classId,
                        };
                        
              console.log("Enviando dados para vincular prova:", payload);
                        
                        // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
              const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                        
                        // Enviar para a API
                        const response = await fetch(url, {
                method: "POST",
                            headers: {
                  "Content-Type": "application/json",
                            },
                body: JSON.stringify(payload),
                        });
                        
                        if (!response.ok) {
                throw new Error(
                  `Erro ao vincular prova. Status: ${response.status}`
                );
                        }
                        
                        // Fechar modal e mostrar mensagem de sucesso
              document.getElementById("linkExamModal").classList.add("hidden");
              alert("Prova vinculada com sucesso!");
                        
                        // Recarregar provas
                        loadExamsFromAPI();
                    } catch (error) {
              console.error("Erro ao vincular prova:", error);
              alert("Erro ao vincular prova: " + error.message);
                    } finally {
                        // Restaurar botão
                        submitBtn.innerHTML = originalBtnText;
                        submitBtn.disabled = false;
                    }
                });
            }
            
            // Alteração de escola no modal de vinculação
        document
          .getElementById("linkSchool")
          ?.addEventListener("change", async function () {
                const schoolId = this.value;
                if (!schoolId) return;
                
                try {
                    // Mostrar indicador de carregamento
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Carregando turmas...</option>';
                        classSelect.disabled = true;
                    }
                    
                    // Buscar turmas da API
              const response = await fetch(
                `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
                {
                  method: "GET",
                        headers: {
                    "Content-Type": "application/json",
                  },
                        }
              );
                    
                    if (!response.ok) {
                throw new Error(
                  `Erro ao carregar turmas. Status: ${response.status}`
                );
                    }
                    
                    const classes = await response.json();
                    
                    // Limpar seletor
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Selecione uma turma</option>';
                        
                        // Adicionar cada turma ao seletor
                classes.forEach((cls) => {
                  const option = document.createElement("option");
                            option.value = cls.id;
                            option.textContent = cls.nome || `Turma ${cls.id}`;
                            classSelect.appendChild(option);
                        });
                        
                        // Se não há turmas, mostrar mensagem
                        if (classes.length === 0) {
                  classSelect.innerHTML =
                    '<option value="">Nenhuma turma encontrada</option>';
                        }
                        
                        classSelect.disabled = false;
                    }
                } catch (error) {
              console.error("Erro ao buscar turmas:", error);
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Erro ao carregar turmas</option>';
                        classSelect.disabled = false;
                    }
                }
            });
        }

        // Função para adicionar outra questão
        function addAnotherQuestion() {
        document.getElementById("questionOptionsModal").classList.add("hidden");
        document.getElementById("addQuestionModal").classList.remove("hidden");
            
            // Incrementar número da questão
        const currentNumber = parseInt(
          document.getElementById("questionNumber").textContent || "1"
        );
        document.getElementById("questionNumber").textContent =
          currentNumber + 1;
            
            // Limpar formulário
        document.getElementById("addQuestionForm")?.reset();
            
            // Limpar preview de imagem se existir
        const imagePreview = document.querySelector(
          "#addQuestionModal .image-preview"
        );
            if (imagePreview) {
          imagePreview.classList.add("hidden");
          const img = imagePreview.querySelector("img");
          if (img) img.src = "";
            }
        }
        
        // Função para finalizar a criação da prova
        async function finalizeExam() {
            if (currentExamData.questions.length === 0) {
          alert(
            "Adicione pelo menos uma questão antes de finalizar a avaliação."
          );
                return;
            }
            
            // Mostrar indicador de processamento
        const finalizeBtn = document.getElementById("finalizeExamBtnModal");
            const originalBtnText = finalizeBtn.innerHTML;
        finalizeBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
            finalizeBtn.disabled = true;
            
            try {
          console.log(
            "Iniciando processo de finalização da prova:",
            currentExamData.name
          );
          console.log(
            `Total de questões a serem salvas: ${currentExamData.questions.length}`
          );
                
                // Verificar se a prova já foi criada (tem apiId)
                if (!currentExamData.apiId) {
            console.log("Prova ainda não foi criada na API. Criando agora...");
                    
                    // Determinar o nível de ensino no formato correto para a API
                    let nivelEnsino = "FUNDAMENTAL_I"; // Valor padrão
                    if (currentExamData.educationLevel) {
              switch (currentExamData.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "FUNDAMENTAL_I";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "FUNDAMENTAL_II";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "MEDIO";
                                break;
                            default:
                                nivelEnsino = "FUNDAMENTAL_I";
                        }
                    }
                    
                    // Criar a prova com dados básicos
                    const examData = {
                        nome: currentExamData.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: currentExamData.description || "",
                        nivel_ensino: nivelEnsino,
                        data_aplicacao: new Date().toISOString(),
              arquivo_url: "", // Campo obrigatório
                    };
                    
            console.log(
              "Payload para criação da prova:",
              JSON.stringify(examData, null, 2)
            );
                    
                    // 1. Primeiro, criar a prova sem questões
            const provaResponse = await fetch(
              "https://sag-sag.rak8a3.easypanel.host/api/provas",
              {
                method: "POST",
                        headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                        },
                body: JSON.stringify(examData),
              }
            );
                    
                    if (!provaResponse.ok) {
              const errorText = await provaResponse
                .text()
                .catch(() => "Erro desconhecido");
              throw new Error(
                `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
              );
                    }
                    
                    // Obter a prova criada
                    const savedExam = await provaResponse.json();
            console.log("Prova criada com sucesso. ID:", savedExam.id);
                    
                    if (!savedExam.id) {
              throw new Error(
                "A prova foi criada, mas não recebeu um ID válido da API"
              );
                    }
                    
                    // Atualizar o ID da API no exame atual
                    currentExamData.apiId = savedExam.id;
                } else {
            console.log(
              "Prova já existe na API com ID:",
              currentExamData.apiId
            );
                }
                
                // 2. Adicionar a prova ao armazenamento local
          const newExam = addExam(
            currentExamData.name,
            [],
            currentExamData.description,
            currentExamData.educationLevel
          );
                newExam.apiId = currentExamData.apiId;
                updateLocalExam(newExam);
          console.log(
            "Prova adicionada ao armazenamento local com ID da API:",
            newExam.apiId
          );
                
                // 3. Adicionar cada questão individualmente usando o endpoint /api/questoes
                const savedQuestions = [];
                const failedQuestions = [];
                
          console.log(
            `Começando a adicionar ${currentExamData.questions.length} questões...`
          );
                for (let i = 0; i < currentExamData.questions.length; i++) {
                    try {
                        const question = currentExamData.questions[i];
                        
                        // CORREÇÃO: Verificar se a questão já tem um ID da API (já foi salva)
                        if (question.apiId) {
                console.log(
                  `Questão ${i + 1}/${
                    currentExamData.questions.length
                  } já foi salva anteriormente com ID: ${question.apiId}`
                );
                            savedQuestions.push(question);
                            continue; // Pular para a próxima questão
                        }
                        
              console.log(
                `Adicionando questão ${i + 1}/${
                  currentExamData.questions.length
                }: "${question.text.substring(0, 30)}..."`
              );
                        
                        // Tentar salvar a questão usando saveQuestionToAPI
              const savedQuestion = await saveQuestionToAPI(
                question,
                currentExamData.apiId
              );
                        
                        if (savedQuestion && savedQuestion.apiId) {
                console.log(
                  `Questão ${i + 1} salva com sucesso, ID API: ${
                    savedQuestion.apiId
                  }`
                );
                            savedQuestions.push(savedQuestion);
                        } else {
                console.warn(
                  `Questão ${i + 1} foi processada, mas não retornou ID da API`
                );
                            // Ainda adicionar ao array para manter a consistência
                            savedQuestions.push(question);
                failedQuestions.push(i + 1);
                        }
                    } catch (error) {
              console.error(`Erro ao salvar questão ${i + 1}:`, error);
              failedQuestions.push(i + 1);
                    }
                }
                
                // 4. Atualizar as questões no exame local
                if (savedQuestions.length > 0) {
                    newExam.questions = savedQuestions;
                    updateLocalExam(newExam);
            console.log(
              `Exame local atualizado com ${savedQuestions.length} questões`
            );
                }
                
                // 5. Esconder modal e mostrar mensagem de sucesso
          document
            .getElementById("questionOptionsModal")
            .classList.add("hidden");
                
                // Ajustar mensagem com base no resultado
          let message = "";
                if (failedQuestions.length === 0) {
                    message = `Avaliação criada com sucesso! Todas as ${savedQuestions.length} questões foram adicionadas.`;
                } else {
                    message = `Avaliação criada com sucesso, mas ${failedQuestions.length} questões não puderam ser salvas. ${savedQuestions.length} questões foram adicionadas.`;
                }
                
          showSuccessModal("Avaliação Criada", message, () => {
                        // Limpar dados atuais
                        currentExamData = {
              name: "",
              description: "",
              questions: [],
                        };
                        
                        // Atualizar lista de provas
                        loadExamsFromAPI();
          });
                
                // 6. Atualizar a lista de provas
                await loadExamsFromAPI();
                renderExamsList();
                
          console.log("Processo de criação de prova finalizado com sucesso.");
            } catch (error) {
          console.error("Erro ao finalizar exame:", error);
          alert("Ocorreu um erro ao salvar a avaliação: " + error.message);
            } finally {
                // Restaurar botão
                finalizeBtn.innerHTML = originalBtnText;
                finalizeBtn.disabled = false;
            }
        }
        
        // Função auxiliar para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
          console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }
        
        // Script para atualizar os textos dos selects para mostrar valores dos enums
        function updateSelectOptionsToShowEnumValues() {
            // Garantir que os selects de nível de ensino tenham os valores de enum corretos
        const educationLevelSelects = document.querySelectorAll(
          ".education-level, #educationLevel, #bankEducationLevel, #newExamEducationLevel"
        );
            
            // Para cada select de nível de ensino, verificar se as opções têm os valores corretos
        educationLevelSelects.forEach((select) => {
                if (!select) return;
                
                // Verificar se já possui as opções corretas
                let hasCorrectOptions = false;
                for (let i = 0; i < select.options.length; i++) {
            if (
              select.options[i].value === "ANOS_INICIAIS" &&
              select.options[i].textContent === "Anos Iniciais"
            ) {
                        hasCorrectOptions = true;
                        break;
                    }
                }
                
                // Se já tem as opções corretas, apenas garantir que o texto seja igual ao valor
                if (hasCorrectOptions) {
            Array.from(select.options).forEach((option) => {
                        if (option.value) {
                            switch(option.value) {
                                case "ANOS_INICIAIS":
                                    option.textContent = "Anos Iniciais";
                                    break;
                                case "ANOS_FINAIS":
                                    option.textContent = "Anos Finais";
                                    break;
                                case "ENSINO_MEDIO":
                                    option.textContent = "Ensino Médio";
                                    break;
                            }
                        }
                    });
                } 
                // Caso contrário, recriar as opções com os valores corretos
                else {
                    // Salvar a opção vazia/placeholder
                    let placeholderOption = null;
                    for (let i = 0; i < select.options.length; i++) {
                        if (!select.options[i].value) {
                            placeholderOption = select.options[i].cloneNode(true);
                            break;
                        }
                    }
                    
                    // Limpar e adicionar a opção vazia se existir
            select.innerHTML = "";
                    if (placeholderOption) {
                        select.appendChild(placeholderOption);
                    }
                    
                    // Adicionar as opções com valores corretos
                    const correctValues = [
                        { value: "ANOS_INICIAIS", text: "Anos Iniciais" },
                        { value: "ANOS_FINAIS", text: "Anos Finais" },
                        { value: "ENSINO_MEDIO", text: "Ensino Médio" },
                    ];
                    
            correctValues.forEach((item) => {
              const option = document.createElement("option");
                        option.value = item.value;
                        option.textContent = item.text;
                        select.appendChild(option);
                    });
                }
            });

            // Atualizar os selects de série
            const gradeSelects = document.querySelectorAll(
                ".grade-level, #gradeLevel, #bankGrade, #linkGrade, #bnccGrade"
            );

            gradeSelects.forEach((select) => {
                if (!select) return;

                Array.from(select.options).forEach((option) => {
                    if (option.value) {
                        option.textContent = getFormattedGradeText(option.value);
                    }
                });
            });
        }
        
        // Chamar a função quando o DOM estiver carregado
      document.addEventListener("DOMContentLoaded", function () {
            // Chamar após carregar todos os outros scripts
            setTimeout(updateSelectOptionsToShowEnumValues, 500);
        });
        
        // Função para abrir o seletor de habilidades BNCC
        function openBnccSelector() {
            // Salvar referência ao elemento que receberá os códigos
        const questionItem =
          this.closest(".question-item") || this.closest("form");
        activeInputElement = questionItem
          ? questionItem.querySelector(".bncc-codes-input")
          : null;
            
            // Limpar seleções anteriores
            selectedSkills = [];
            
            // Carregar habilidades selecionadas atuais, se existirem
            if (activeInputElement && activeInputElement.value) {
          const codes = activeInputElement.value.split(",");
          codes.forEach((code) => {
                    const trimmedCode = code.trim();
                    if (trimmedCode) {
                        selectedSkills.push(trimmedCode);
                    }
                });
            }
            
            // Limpar filtros
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
            
            if (bnccComponent) bnccComponent.selectedIndex = 0;
            if (bnccGrade) bnccGrade.selectedIndex = 0;
        if (bnccSearch) bnccSearch.value = "";
            
            // Atualizar contagem de selecionados
        const selectedSkillsCount = document.getElementById(
          "selectedSkillsCount"
        );
        if (selectedSkillsCount)
          selectedSkillsCount.textContent = selectedSkills.length.toString();
            
            // Mostrar mensagem inicial
        const bnccSkillsList = document.getElementById("bnccSkillsList");
            if (bnccSkillsList) {
                bnccSkillsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        Carregando todas as habilidades... Você pode usar os filtros para restringir a lista.
                    </div>
                `;
            }
            
            // Abrir modal
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.remove("hidden");
            
            // Carregar todas as habilidades da API imediatamente
            updateBnccSkillsList();
        }
        
        // Função para fechar o modal BNCC
        function closeBnccModal() {
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.add("hidden");
        }
        
        // Função para confirmar a seleção de habilidades BNCC
        function confirmBnccSelection() {
            if (activeInputElement) {
          // Salvar códigos no input (apenas os códigos, não transformar em números)
          activeInputElement.value = selectedSkills.join(", ");
                
                // Atualizar UI
          const container =
            activeInputElement.closest(".question-item") ||
            activeInputElement.closest("form");
                if (container) {
            const countElement = container.querySelector(
              ".selected-skills-count"
            );
            const listElement = container.querySelector(
              ".selected-skills-list"
            );
                    
                    if (countElement) {
              countElement.textContent =
                selectedSkills.length > 0 ? `(${selectedSkills.length})` : "";
                    }
                    
                    if (listElement) {
              listElement.innerHTML = "";

              selectedSkills.forEach((code) => {
                const div = document.createElement("div");
                div.className =
                  "px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded flex justify-between items-center mb-1";
                            div.innerHTML = `
                                <span>${code}</span>
                                <button type="button" class="remove-skill text-blue-500 hover:text-blue-700" data-code="${code}">
                                    <i class="fas fa-times-circle"></i>
                                </button>
                            `;
                            
                            listElement.appendChild(div);
                            
                            // Adicionar evento para remover habilidade
                const removeBtn = div.querySelector(".remove-skill");
                            if (removeBtn) {
                  removeBtn.addEventListener("click", function () {
                    const codeToRemove = this.getAttribute("data-code");
                                    
                                    // Remover do array
                                    const index = selectedSkills.indexOf(codeToRemove);
                                    if (index !== -1) {
                                        selectedSkills.splice(index, 1);
                                    }
                                    
                    // Atualizar input (apenas os códigos, não transformar em números)
                    activeInputElement.value = selectedSkills.join(", ");
                                    
                                    // Remover elemento visual
                    this.closest("div").remove();
                                    
                                    // Atualizar contagem
                                    if (countElement) {
                      countElement.textContent =
                        selectedSkills.length > 0
                          ? `(${selectedSkills.length})`
                          : "";
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Fechar modal
            closeBnccModal();
        }
        
        // Função para atualizar a lista de habilidades BNCC
        function updateBnccSkillsList() {
        const component = document.getElementById("bnccComponent")?.value;
        const grade = document.getElementById("bnccGrade")?.value;
        const skillsList = document.getElementById("bnccSkillsList");
            
            if (!skillsList) return;
            
            skillsList.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-gray-500">Carregando habilidades...</p>
                </div>
            `;
            
            // Mesmo se componente e série não forem selecionados, vamos carregar todas as habilidades
        loadBnccSkillsFromAPI(grade, component)
          .then((apiSkills) => {
                // Limpar a lista
            skillsList.innerHTML = "";
                
                // Se não houver habilidades, mostrar mensagem
                if (!apiSkills || apiSkills.length === 0) {
                    skillsList.innerHTML = `
                        <div class="text-center text-gray-500 py-4">
                            Nenhuma habilidade encontrada para esta combinação
                        </div>
                    `;
                    return;
                }
                
                // Adicionar cada habilidade à lista
            apiSkills.forEach((skill) => {
              const code = skill.codigo || "";
              const description = skill.descricao || "";
                    
                    const isSelected = selectedSkills.includes(code);
              const div = document.createElement("div");
              div.className =
                "p-2 border-b border-gray-100 last:border-b-0 skill-item";
              div.setAttribute("data-code", code);
              div.setAttribute("data-visible", "true");
                    
                    div.innerHTML = `
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                              isSelected ? "checked" : ""
                            }>
                            <span class="ml-2">
                                <span class="block text-sm font-medium">${code}</span>
                                <span class="block text-xs text-gray-500">${description}</span>
                            </span>
                        </label>
                    `;
                    
                    // Adicionar evento ao checkbox
                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                checkbox.addEventListener("change", function () {
                            if (this.checked) {
                                // Adicionar à seleção
                                if (!selectedSkills.includes(code)) {
                                    selectedSkills.push(code);
                                }
                            } else {
                                // Remover da seleção
                                const index = selectedSkills.indexOf(code);
                                if (index !== -1) {
                                    selectedSkills.splice(index, 1);
                                }
                            }
                            
                            // Atualizar contagem
                  const count = document.getElementById("selectedSkillsCount");
                  if (count)
                    count.textContent = selectedSkills.length.toString();
                        });
                    }
                    
                    skillsList.appendChild(div);
                });
          })
          .catch((error) => {
            console.error("Erro ao carregar habilidades:", error);
                
                skillsList.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        Erro ao carregar habilidades. Tentando usar dados locais...
                    </div>
                `;
                
                // Tentar usar dados locais como fallback
                setTimeout(() => {
                    // Verificar se existem habilidades no banco de dados local para o componente e série
              const localComponent = Object.keys(bnccDatabase).find(
                (key) => key.toLowerCase() === component?.toLowerCase()
              );

              if (
                localComponent &&
                grade &&
                bnccDatabase[localComponent][grade]
              ) {
                        const skills = bnccDatabase[localComponent][grade];
                        
                        // Limpar a lista
                skillsList.innerHTML = "";
                        
                        // Adicionar cada habilidade local à lista
                skills.forEach((skill) => {
                            const isSelected = selectedSkills.includes(skill.code);
                  const div = document.createElement("div");
                  div.className =
                    "p-2 border-b border-gray-100 last:border-b-0 skill-item";
                  div.setAttribute("data-code", skill.code);
                  div.setAttribute("data-visible", "true");
                            
                            div.innerHTML = `
                                <label class="flex items-start cursor-pointer">
                                    <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                                      isSelected ? "checked" : ""
                                    }>
                                    <span class="ml-2">
                                        <span class="block text-sm font-medium">${
                                          skill.code
                                        }</span>
                                        <span class="block text-xs text-gray-500">${
                                          skill.description
                                        }</span>
                                    </span>
                                </label>
                            `;
                            
                            // Adicionar evento ao checkbox
                            const checkbox = div.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                    checkbox.addEventListener("change", function () {
                                    if (this.checked) {
                                        // Adicionar à seleção
                                        if (!selectedSkills.includes(skill.code)) {
                                            selectedSkills.push(skill.code);
                                        }
                                    } else {
                                        // Remover da seleção
                                        const index = selectedSkills.indexOf(skill.code);
                                        if (index !== -1) {
                                            selectedSkills.splice(index, 1);
                                        }
                                    }
                                    
                                    // Atualizar contagem
                      const count = document.getElementById(
                        "selectedSkillsCount"
                      );
                      if (count)
                        count.textContent = selectedSkills.length.toString();
                                });
                            }
                            
                            skillsList.appendChild(div);
                        });
                    } else {
                        skillsList.innerHTML = `
                            <div class="text-center text-gray-500 py-4">
                                Nenhuma habilidade encontrada ${
                                  component ? "para " + component : ""
                                } ${grade ? " - " + grade : ""}
                            </div>
                        `;
                    }
                }, 500);
            });
        }
        
        // Função para filtrar habilidades BNCC
        function filterBnccSkills() {
        const searchText =
          document.getElementById("bnccSearch")?.value.toLowerCase() || "";
        const skillItems = document.querySelectorAll(
          "#bnccSkillsList .skill-item"
        );

        skillItems.forEach((item) => {
          const code = item.getAttribute("data-code") || "";
          const description =
            item.querySelector(".text-gray-500")?.textContent.toLowerCase() ||
            "";
                
                // Verificar se o texto de busca está no código ou na descrição
          if (
            code.toLowerCase().includes(searchText) ||
            description.includes(searchText)
          ) {
            item.style.display = "";
            item.setAttribute("data-visible", "true");
                } else {
            item.style.display = "none";
            item.setAttribute("data-visible", "false");
                }
            });
        }
        
        // Função para selecionar todas as habilidades visíveis
        function selectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && !checkbox.checked && code) {
                    checkbox.checked = true;
                    
                    // Adicionar à seleção
                    if (!selectedSkills.includes(code)) {
                        selectedSkills.push(code);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para desmarcar todas as habilidades visíveis
        function deselectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && checkbox.checked && code) {
                    checkbox.checked = false;
                    
                    // Remover da seleção
                    const index = selectedSkills.indexOf(code);
                    if (index !== -1) {
                        selectedSkills.splice(index, 1);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para configurar uploads de imagem
        function setupImageUploads() {
        document.querySelectorAll(".question-image").forEach((input) => {
          input.addEventListener("change", handleImageUpload);
            });
            
        document.querySelectorAll(".remove-image").forEach((button) => {
          button.addEventListener("click", handleImageRemove);
            });
        }
        
        // Função para tratar upload de imagem
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Pegar o caminho completo do arquivo
            const filePath = file.name;
            
            const reader = new FileReader();
            const container = this.closest(".question-item") || this.closest("form");
            const previewContainer = container?.querySelector(".image-preview");
            const previewImg = previewContainer?.querySelector("img");
            const fileInput = container?.querySelector(".question-image") || container?.querySelector("#questionImage");
            
            if (!previewContainer || !previewImg || !fileInput) return;
            
            reader.onload = function (event) {
                // Mostrar preview da imagem
                previewImg.src = event.target.result;
                previewContainer.classList.remove("hidden");
                
                // Armazenar o caminho do arquivo
                fileInput.dataset.imagePath = filePath;
                
                console.log('Imagem carregada. Caminho:', filePath);
            };
            
            reader.readAsDataURL(file);
        }
        
        
        // Função para remover imagem
        function handleImageRemove() {
        const container =
          this.closest(".question-item") || this.closest("form");
        const previewContainer = container?.querySelector(".image-preview");
        const fileInput =
          container?.querySelector(".question-image") ||
          container?.querySelector("#questionImage");
            
            if (previewContainer) {
          previewContainer.classList.add("hidden");
          const img = previewContainer.querySelector("img");
          if (img) img.src = "";
            }
            
            if (fileInput) {
          fileInput.value = "";
            }
        }
        
        // Função para renderizar lista de avaliações
        function renderExamsList() {
        const examsList = document.getElementById("examsList");
            if (!examsList) return;
            
            // Obter avaliações do localStorage
            let exams = [];
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    exams = JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            
        console.log("Avaliações encontradas:", exams.length, exams);
            
            // Filtrar provas vazias - remover provas com 0 questões e que não existem no banco de dados
            // Remover também as provas simuladas específicas que foram mencionadas
            const namesToRemove = [
          "Avaliação Diagnóstica - Português",
          "Avaliação Diagnóstica - Matemática",
          "Avaliação Bimestral - Português",
          "Avaliação Bimestral - Matemática",
          "Avaliação Final - Ciências",
        ];

        exams = exams.filter((exam) => {
                // Verificar se a prova tem questões
                const questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Incluir a prova apenas se não está na lista de nomes a remover OU tem questões OU tem um ID da API
          return (
            !namesToRemove.includes(exam.name) ||
            questionsCount > 0 ||
            exam.apiId
          );
            });
            
            // Salvar a lista filtrada de volta no localStorage
        localStorage.setItem("exams", JSON.stringify(exams));
            
            // Se não há avaliações, mostrar mensagem
            if (!exams || exams.length === 0) {
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        Nenhuma prova cadastrada
                    </li>
                `;
                return;
            }
            
            // Limpar lista
        examsList.innerHTML = "";
            
            // Adicionar cada avaliação à lista
        exams.forEach((exam) => {
          const li = document.createElement("li");
          li.className = "block hover:bg-gray-50";
                
                // Verificar se a prova tem questões
                let questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Se tiver ID da API mas nenhuma questão local, tentar atualizar o contador com uma mensagem
                let questionCountText = `Questões: ${questionsCount}`;
                if (questionsCount === 0 && exam.apiId) {
                    // Tentar carregar os detalhes da prova da API para mostrar o número correto
                    loadExamDetails(exam.apiId, exams.indexOf(exam), exams)
              .then((success) => {
                            if (success) {
                                // Atualizar a visualização após carregar os detalhes
                                const updatedExams = getExams();
                  const updatedExam = updatedExams.find(
                    (e) => e.id === exam.id
                  );
                                if (updatedExam && updatedExam.questions.length > 0) {
                    const questionCountElement =
                      li.querySelector(".question-count");
                                    if (questionCountElement) {
                                        questionCountElement.textContent = `Questões: ${updatedExam.questions.length}`;
                                    }
                                }
                            }
                        })
              .catch((err) =>
                console.error("Erro ao carregar detalhes da prova:", err)
              );
                        
                    questionCountText = `<span class="question-count">Questões: ${questionsCount} <i class="fas fa-sync-alt fa-spin text-xs ml-1" title="Atualizando contador de questões..."></i></span>`;
                } else {
                    questionCountText = `<span class="question-count">Questões: ${questionsCount}</span>`;
                }
                
                // Formatar data de criação
          let createdAt = "";
                try {
                    if (exam.createdAt) {
                        const date = new Date(exam.createdAt);
              createdAt = date.toLocaleDateString("pt-BR");
                    }
                } catch (e) {
            console.error("Erro ao formatar data:", e);
                }
                
                // Badge para nível de ensino
          const educationLevelBadge = exam.educationLevel
            ? `<span class="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-800 rounded">${exam.educationLevel}</span>`
            : "";
                
          console.log(
            `Renderizando prova: ${exam.name}, API ID: ${exam.apiId}, Questões: ${questionsCount}`
          );
                
                li.innerHTML = `
                    <div class="flex items-center px-4 py-4 sm:px-6">
                        <div class="min-w-0 flex-1 flex items-center">
                            <div class="flex-shrink-0">
                                <span class="h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center">
                                    <i class="fas fa-file-alt text-yellow-600 text-lg"></i>
                                </span>
                            </div>
                            <div class="min-w-0 flex-1 px-4">
                                <div>
                                    <p class="text-sm font-medium text-blue-600 truncate">
                                        ${exam.name} ${educationLevelBadge}
                                    </p>
                                    <p class="mt-1 text-sm text-gray-500">
                                        ${questionCountText} | Criada em: ${createdAt}
                                    </p>
                                    ${
                                      exam.description
                                        ? `<p class="mt-1 text-xs text-gray-400 truncate">${exam.description}</p>`
                                        : ""
                                    }
                                </div>
                            </div>
                        </div>
                        <div class="flex space-x-2">
                            
                            <button class="text-blue-600 hover:text-blue-900 editExam" data-id="${
                              exam.id
                            }" title="Editar">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="text-indigo-600 hover:text-indigo-900 editQuestionsExam" data-id="${
                              exam.id
                            }" data-api-id="${exam.apiId || ''}" title="Editar Questões">
                                <i class="fas fa-list-check"></i>
                            </button>
                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${
                              exam.id
                            }" title="Baixar PDF">
                                <i class="fas fa-file-pdf"></i>
                            </button>
                                                        <!-- Botão de exclusão removido -->
                        </div>
                    </div>
                `;
                
                examsList.appendChild(li);
            });
            
            // Adicionar eventos aos botões
            setupExamListButtons();
        }
        
        // Função para configurar botões na lista de avaliações
        function setupExamListButtons() {
            // Visualizar avaliação
            document.querySelectorAll(".viewExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    viewExam(examId);
                });
            });
            
            // Editar avaliação
            document.querySelectorAll(".editExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    openExamForEditing(examId);
                });
            });
            
            // Editar questões da avaliação
            document.querySelectorAll(".editQuestionsExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const apiId = this.getAttribute("data-api-id");
                    if (!apiId) {
                        alert("Esta prova não possui ID da API e não pode ter suas questões editadas.");
                        return;
                    }
                    openEditQuestionsModal(examId, apiId);
                });
            });
            
            // Baixar avaliação
            document.querySelectorAll(".downloadExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    if (exam) {
                        // Adicionar debug para ver a estrutura da prova
                        console.log("ESTRUTURA DA PROVA:", JSON.stringify(exam, null, 2));
                        console.log("QUESTÕES:", JSON.stringify(exam.questions, null, 2));
                        if (exam.questions && exam.questions.length > 0) {
                            console.log("PRIMEIRA QUESTÃO:", JSON.stringify(exam.questions[0], null, 2));
                            console.log("ALTERNATIVAS:", JSON.stringify(exam.questions[0].options || exam.questions[0].alternativas, null, 2));
                        }
                        exportExamToDocx(exam);
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
            
            // Funcionalidade de exclusão removida
        }
        
        // Função para visualizar uma avaliação
        function viewExam(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Aqui você pode implementar a visualização completa da avaliação
            // Por enquanto, mostraremos algumas informações básicas
        alert(
          `Visualizando: ${exam.name}\nTotal de questões: ${exam.questions.length}`
        );
            
            // Em um caso real, você abriria um modal ou navegaria para uma página de detalhes
        }
        
        // Função para abrir uma avaliação para edição
        function openExamForEditing(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Preencher dados no modal de edição
        document.getElementById("newExamName").value = exam.name;
        document.getElementById("newExamDescription").value =
          exam.description || "";
            
            // Definir o nível de ensino
        const educationLevelSelect = document.getElementById(
          "newExamEducationLevel"
        );
            if (educationLevelSelect) {
                // Tentar encontrar o option com o valor igual ao do exame
          const eduLevel = exam.educationLevel || "";
                let optionExists = false;
                
                // Procurar pelo valor exato primeiro
                for (let i = 0; i < educationLevelSelect.options.length; i++) {
                    if (educationLevelSelect.options[i].value === eduLevel) {
                        educationLevelSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }
                
                // Se não encontrou, tentar mapear para um valor válido da API
                if (!optionExists) {
            let mappedValue = "";
                    const eduLevelUpper = eduLevel.toUpperCase();
                    
            if (
              eduLevelUpper.includes("INICIAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL I")
            ) {
              mappedValue = "ANOS_INICIAIS";
            } else if (
              eduLevelUpper.includes("FINAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL II")
            ) {
              mappedValue = "ANOS_FINAIS";
            } else if (
              eduLevelUpper.includes("MÉDIO") ||
              eduLevelUpper.includes("MEDIO")
            ) {
              mappedValue = "ENSINO_MEDIO";
                    }
                    
                    if (mappedValue) {
                        for (let i = 0; i < educationLevelSelect.options.length; i++) {
                            if (educationLevelSelect.options[i].value === mappedValue) {
                                educationLevelSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Armazenar o ID da prova que está sendo editada
            currentExamData = {
                id: exam.id,
                apiId: exam.apiId,
                name: exam.name,
          description: exam.description || "",
          questions: [...exam.questions], // Clone para não modificar o original
            };
            
            // Abrir o modal de edição
        document
          .getElementById("createExamStepOneModal")
          .classList.remove("hidden");
            
            // Atualizar o título do modal
        const modalTitle = document.querySelector("#createExamStepOneModal h3");
            if (modalTitle) {
          modalTitle.textContent = "Editar Prova";
            }
            
            // Atualizar o texto do botão
        const submitBtn = document.querySelector(
          '#createExamStepOneForm button[type="submit"]'
        );
            if (submitBtn) {
          submitBtn.textContent = "Continuar para Edição de Questões";
            }
        }
        
        // Função para atualizar uma prova existente
        async function updateExam(exam) {
            try {
          console.log("Iniciando atualização da prova ID:", exam.id);
                
                // Atualizar localmente
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
            console.log("Prova atualizada no armazenamento local");
                } else {
            throw new Error("Prova não encontrada no armazenamento local");
                }
                
                // Se tiver ID da API, atualizar remotamente
                if (exam.apiId) {
                    // Mapear o nível de ensino - usar apenas valores válidos para a API
                    let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                    if (exam.educationLevel) {
              switch (exam.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "ANOS_INICIAIS";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "ANOS_FINAIS";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "ENSINO_MEDIO";
                                break;
                            default:
                                // Caso não identifique, usar o padrão ANOS_INICIAIS
                                nivelEnsino = "ANOS_INICIAIS";
                        }
                    }
                    
                    // Converter para o formato da API
                    const apiExam = {
                        id: exam.apiId,
                        nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: exam.description || "",
                        data_aplicacao: new Date().toISOString(),
              nivel_ensino: nivelEnsino,
                    };
                    
            console.log("Dados enviados para a API:", apiExam);
                    
                    // Adicionar questões se existirem
                    if (exam.questions && exam.questions.length > 0) {
              apiExam.questoes = exam.questions.map((q) => {
                            return {
                                texto: q.text,
                                nivel_ensino: nivelEnsino,
                  serie: q.gradeLevel || "",
                  dificuldade: q.difficultyLevel || "",
                  componente_curricular: q.curriculumComponent || "",
                  codigos_bncc: q.bnccCodes || "",
                  resposta_correta: q.correctAnswer || "A",
                  alternativa_a: q.options.A || "",
                  alternativa_b: q.options.B || "",
                  alternativa_c: q.options.C || "",
                  alternativa_d: q.options.D || "",
                  alternativa_e: q.options.E || "",
                  imagem: q.image || null,
                            };
                        });
                    }
                    
            console.log(
              `Enviando atualização para a API: /api/provas/${exam.apiId}`,
              apiExam
            );

            const response = await fetch(
              `https://sag-sag.rak8a3.easypanel.host/api/provas/${exam.apiId}`,
              {
                method: "PUT",
                        headers: {
                  "Content-Type": "application/json",
                        },
                body: JSON.stringify(apiExam),
              }
            );
                    
                    if (!response.ok) {
              const errorText = await response
                .text()
                .catch(() => "Erro desconhecido");
              console.error(
                `Erro ao atualizar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
              );
              throw new Error(
                `Não foi possível atualizar a prova na API. Status: ${response.status}`
              );
                    }
                    
                    const updatedExam = await response.json().catch(() => null);
            console.log("Prova atualizada com sucesso na API:", updatedExam);
                    
                    // Se a API retornou dados atualizados, sincronizar com a cópia local
                    if (updatedExam) {
                        // Atualizar dados que possam ter sido modificados pela API
                        exam.apiId = updatedExam.id;
                        // Atualizar no armazenamento local
                        exams[index] = exam;
              localStorage.setItem("exams", JSON.stringify(exams));
                        
                        // Recarregar a lista de provas da API para garantir sincronização
              console.log("Recarregando lista de provas da API...");
                        await loadExamsFromAPI();
                    }
                    
                    // Atualizar a interface
                    renderExamsList();
            console.log("Interface atualizada com os novos dados da prova");
                    
                    return true;
                } else {
                    // Se não tem ID da API, tentar criar novo registro na API
                    try {
              console.log(
                "Prova sem ID da API. Tentando criar novo registro na API..."
              );
                        const savedExam = await saveExamToAPI(exam);
                        if (savedExam && savedExam.id) {
                            // Atualizar o ID da API na cópia local
                            exam.apiId = savedExam.id;
                            exams[index] = exam;
                localStorage.setItem("exams", JSON.stringify(exams));
                console.log("Prova criada na API com sucesso:", savedExam);
                            
                            // Recarregar a lista de provas da API
                            await loadExamsFromAPI();
                            
                            // Atualizar a interface
                            renderExamsList();
                        }
                    } catch (apiError) {
              console.error("Erro ao criar prova na API:", apiError);
                        // Continue mesmo se falhar na API, pois já temos localmente
                        
                        // Atualizar a interface de qualquer forma
                        renderExamsList();
                    }
                    return true;
                }
            } catch (error) {
          console.error("Erro ao atualizar prova:", error);
                return false;
            }
        }
        
        // Função para excluir uma avaliação - removida        async function deleteExam(examId) {            // Esta função foi removida            console.log("Função de exclusão de prova foi desativada");            return false;        }
        
        // Função para obter todas as avaliações
        function getExams() {
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    return JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            return [];
        }
        
        // Função para adicionar uma nova avaliação
      function addExam(name, questions, description = "", educationLevel = "") {
            // Obter avaliações existentes
            let exams = getExams() || [];
            
            // Gerar ID único
        const newId = exams.length > 0 ? Math.max(...exams.map((e) => e.id)) + 1 : 1;
            
            // Processar as questões para garantir formato correto
            const processedQuestions = questions.map(question => {
                console.log("Processando questão para addExam:", question);
                
                // Garantir que options está no formato correto
                const options = {};
                
                // Caso 1: Se já tem um objeto options com formato {A: "texto", B: "texto"}
                if (question.options && typeof question.options === 'object' && !Array.isArray(question.options)) {
                    options.A = question.options.A || '';
                    options.B = question.options.B || '';
                    options.C = question.options.C || '';
                    options.D = question.options.D || '';
                    options.E = question.options.E || '';
                }
                // Caso 2: Se tem um array de alternativas
                else if (question.alternativas && Array.isArray(question.alternativas)) {
                    const letters = ['A', 'B', 'C', 'D', 'E'];
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letra = letters[index];
                            options[letra] = alt.texto || alt.text || '';
                        }
                    });
                }
                
                console.log("Opções processadas:", options);
                
                // Retornar questão processada
                return {
                    ...question,
                    options: options
                };
            });
            
            // Criar objeto de avaliação
            const newExam = {
                id: newId,
                name: name,
                description: description,
                educationLevel: educationLevel,
                questions: processedQuestions,
                createdAt: new Date().toISOString(),
                links: [],
            };
            
            // Adicionar à lista
            exams.push(newExam);
            
            // Salvar no localStorage
            localStorage.setItem("exams", JSON.stringify(exams));
            
            console.log("Nova avaliação adicionada:", newExam);
            
            return newExam;
        }
        
        // Função para popular o seletor de avaliações
        async function populateExamSelector() {
        const examSelect = document.getElementById("examSelect");
            if (!examSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          examSelect.innerHTML =
            '<option value="">Carregando provas...</option>';
                examSelect.disabled = true;
                
                // Buscar provas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/provas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const exams = await response.json();
          console.log("Provas carregadas da API:", exams);
                
                // Limpar seletor
          examSelect.innerHTML =
            '<option value="">Selecione uma prova</option>';
                
                // Verificar se a resposta é um array
                if (Array.isArray(exams) && exams.length > 0) {
                    // Adicionar cada prova ao seletor
            exams.forEach((exam) => {
              const option = document.createElement("option");
                        option.value = exam.id;
                        
                        // Dar preferência ao campo 'nome'
                        if (exam.nome !== undefined) {
                            option.textContent = exam.nome;
                        } else if (exam.titulo !== undefined) {
                            option.textContent = exam.titulo;
                        } else {
                option.textContent = "Prova sem título";
                        }
                        
                        examSelect.appendChild(option);
                    });
                } else {
                    // Se não houver provas, mostrar mensagem
            examSelect.innerHTML =
              '<option value="">Nenhuma prova disponível</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar provas:", error);
          examSelect.innerHTML =
            '<option value="">Erro ao carregar provas</option>';
            } finally {
                examSelect.disabled = false;
            }
            
            return examSelect;
        }
        
        // Função para popular o seletor de escolas
        async function populateSchoolSelector() {
        const schoolSelect = document.getElementById("linkSchool");
            if (!schoolSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          schoolSelect.innerHTML =
            '<option value="">Carregando escolas...</option>';
                schoolSelect.disabled = true;
                
                // Buscar escolas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/escolas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar escolas. Status: ${response.status}`
            );
                }
                
                const schools = await response.json();
                
                // Limpar seletor
          schoolSelect.innerHTML =
            '<option value="">Selecione uma escola</option>';
                
                // Adicionar cada escola ao seletor
          schools.forEach((school) => {
            const option = document.createElement("option");
                    option.value = school.id;
            option.textContent = school.nome || "Escola sem nome";
                    schoolSelect.appendChild(option);
                });
            } catch (error) {
          console.error("Erro ao buscar escolas:", error);
          schoolSelect.innerHTML =
            '<option value="">Erro ao carregar escolas</option>';
            } finally {
                schoolSelect.disabled = false;
            }
        }
        
        // Função para popular o seletor de turmas
        async function populateClassSelector(schoolId) {
        const classSelect = document.getElementById("linkClass");
            if (!classSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          classSelect.innerHTML =
            '<option value="">Carregando turmas...</option>';
                classSelect.disabled = true;
                
                if (!schoolId) {
            classSelect.innerHTML =
              '<option value="">Selecione uma escola primeiro</option>';
                    classSelect.disabled = true;
                    return;
                }
                
                // Buscar turmas da API
          const response = await fetch(
            `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar turmas. Status: ${response.status}`
            );
                }
                
                const classes = await response.json();
                
                // Limpar seletor
          classSelect.innerHTML =
            '<option value="">Selecione uma turma</option>';
                
                // Adicionar cada turma ao seletor
          classes.forEach((cls) => {
            const option = document.createElement("option");
                    option.value = cls.id;
                    option.textContent = cls.nome || `Turma ${cls.id}`;
                    classSelect.appendChild(option);
                });
                
                // Se não há turmas, mostrar mensagem
                if (classes.length === 0) {
            classSelect.innerHTML =
              '<option value="">Nenhuma turma encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar turmas:", error);
          classSelect.innerHTML =
            '<option value="">Erro ao carregar turmas</option>';
            } finally {
                classSelect.disabled = false;
            }
        }
        
        // Atualizar o formulário de vincular prova
        function updateLinkExamForm() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        // Função para vincular uma avaliação a uma turma
        async function linkExamToClass(examId, schoolId, grade, classId, shift) {
            try {
                const payload = {
                    prova_id: examId,
            turma_id: classId,
                };
                
          console.log("Enviando dados para vincular prova:", payload);
                
                // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao vincular prova. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
          console.log("Prova vinculada com sucesso:", result);
                
                return true;
            } catch (error) {
          console.error("Erro ao vincular prova:", error);
                throw error;
            }
        }
        
        // Função para exportar uma avaliação para PDF
        function exportExamToDocx(exam) {
    // Verificar se o objeto exam é válido
    if (!exam || !exam.name) {
        alert('Prova inválida para exportação!');
        return;
    }

    // Log detalhado de depuração para mostrar as alternativas
    console.log("INICIANDO EXPORTAÇÃO DA PROVA:", exam.name);
    if (exam.questions && exam.questions.length > 0) {
        exam.questions.forEach((q, index) => {
            console.log(`Questão ${index + 1}:`, q.text);
            console.log(`  Alternativas para questão ${index + 1}:`, q.options);
            
            // Verificar se as alternativas estão vazias
            const hasNonEmptyOptions = q.options && Object.values(q.options).some(opt => opt && opt.trim() !== '');
            console.log(`  Tem alternativas não vazias? ${hasNonEmptyOptions}`);
            
            if (!hasNonEmptyOptions) {
                console.warn("⚠️ ALTERNATIVAS VAZIAS DETECTADAS! Verificando alternativas originais no localStorage...");
                
                // Buscar dados originais do localStorage
                try {
                    const exams = JSON.parse(localStorage.getItem("exams")) || [];
                    const localExam = exams.find(e => e.id === exam.id);
                    if (localExam && localExam.questions) {
                        const localQuestion = localExam.questions.find(lq => lq.id === q.id || lq.apiId === q.apiId);
                        if (localQuestion && localQuestion.options) {
                            console.log("  Alternativas no localStorage:", localQuestion.options);
                            
                            // Atualizar as alternativas da questão atual com as do localStorage
                            if (Object.values(localQuestion.options).some(opt => opt && opt.trim() !== '')) {
                                console.log("  ✅ Usando alternativas do localStorage");
                                q.options = localQuestion.options;
                            }
                        }
                    }
                } catch (error) {
                    console.error("Erro ao buscar alternativas do localStorage:", error);
                }
            }
        });
    }

    // Indicar que estamos processando
    const processingMessage = document.createElement('div');
    processingMessage.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    processingMessage.innerHTML = `
        <div class="bg-white p-4 rounded-lg shadow-lg text-center">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mb-4"></div>
            <p class="text-gray-800">Gerando PDF...</p>
        </div>
    `;
    document.body.appendChild(processingMessage);

    // Função para carregar as bibliotecas necessárias (jsPDF e html2canvas)
    function loadPdfLibraries() {
        return new Promise((resolve, reject) => {
            // Verificar se as bibliotecas já estão carregadas
            if (typeof jspdf !== 'undefined' && typeof html2canvas !== 'undefined') {
                resolve({ jspdf, html2canvas });
                return;
            }

            // Contador para controlar o carregamento das duas bibliotecas
            let loaded = 0;
            
            // Carregar jsPDF
            const jspdfScript = document.createElement('script');
            jspdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            jspdfScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            jspdfScript.onerror = () => reject(new Error('Falha ao carregar jsPDF'));
            document.head.appendChild(jspdfScript);
            
            // Carregar html2canvas
            const html2canvasScript = document.createElement('script');
            html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            html2canvasScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            html2canvasScript.onerror = () => reject(new Error('Falha ao carregar html2canvas'));
            document.head.appendChild(html2canvasScript);
        });
    }

    // Função para remover a mensagem de processamento
    function removeProcessingMessage() {
        if (processingMessage && processingMessage.parentNode) {
            processingMessage.parentNode.removeChild(processingMessage);
        }
    }

    // Função para criar o conteúdo HTML que será convertido em PDF
    function createExamContent() {
        // Criar um contêiner para o conteúdo do PDF
        const container = document.createElement('div');
        container.style.width = '210mm'; // Largura A4
        container.style.padding = '20mm';
        container.style.backgroundColor = 'white';
        container.style.color = 'black';
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.top = '0';
        
        // Cabeçalho da avaliação
        container.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">AVALIAÇÃO</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">${exam.name.toUpperCase()}</h2>
                <p style="margin-bottom: 10px; font-size: 16px;">Nome do Aluno: _____________________________________________</p>
                <p style="margin-bottom: 30px; font-size: 16px;">Data: ___/___/______</p>
            </div>
            
            <!-- Instruções -->
            <div style="border: 1px solid #999; padding: 15px; margin-bottom: 30px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #666;">INSTRUÇÕES:</p>
                <p style="margin-bottom: 8px; color: #666;">1. Leia atentamente cada questão antes de respondê-la</p>
                <p style="margin-bottom: 8px; color: #666;">2. Use caneta azul ou preta para marcar suas respostas</p>
                <p style="margin-bottom: 8px; color: #666;">3. Não é permitido o uso de corretivo</p>
                <p style="color: #666;">4. Questões rasuradas serão anuladas</p>
            </div>
        `;
        
        // Adicionar questões
        if (exam.questions && exam.questions.length > 0) {
            const questionsDiv = document.createElement('div');
            
            exam.questions.forEach((question, index) => {
                const questionText = question.text || question.enunciado || "";
                if (!questionText) {
                    console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                    return;
                }
                
                // Cabeçalho da questão
                const questionDiv = document.createElement('div');
                questionDiv.style.marginBottom = '30px';
                questionDiv.style.pageBreakInside = 'avoid';
                
                questionDiv.innerHTML = `
                    <div style="border-top: 1px solid #ccc; margin-top: 15px; margin-bottom: 15px;"></div>
                    <div style="display: flex; margin-bottom: 15px;">
                        <div style="background-color: #666; color: white; padding: 8px 15px; font-weight: bold; width: 30%; display: inline-block;">
                            QUESTÃO ${index + 1}
                        </div>
                        <div style="padding: 8px 15px; width: 70%; text-align: right; display: inline-block;">
                            1 ponto
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 16px; margin-left: 15px;">${questionText}</p>
                `;
                
                // Adicionar imagem se existir
                if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                    questionDiv.innerHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <img src="${question.image}" alt="Imagem da questão" style="max-width: 80%; max-height: 200px; border: 1px solid #ddd; padding: 5px;">
                            <p style="font-style: italic; color: #666; font-size: 12px; margin-top: 5px;">Figura ${index + 1}: Imagem referente à questão</p>
                        </div>
                    `;
                }
                
                // Adicionar alternativas
                const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                let alternativas = [];
                
                if (question.options && typeof question.options === 'object') {
                    // Formato {A: "texto", B: "texto"}
                    alternativasLetras.forEach(letra => {
                        let texto = '';
                        
                        // Se tem texto na alternativa, use-o
                        if (question.options[letra] && question.options[letra].trim() !== '') {
                            texto = question.options[letra];
                        } 
                        // Caso contrário, use um texto padrão
                        else {
                            texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                        }
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                } else if (question.alternativas && Array.isArray(question.alternativas)) {
                    question.alternativas.forEach((alt, index) => {
                        if (index < alternativasLetras.length) {
                            const letra = alternativasLetras[index];
                            let texto = alt.texto || alt.text || '';
                            
                            if (!texto || texto.trim() === '') {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        }
                    });
                }
                
                // Se não encontrou alternativas, criar alternativas padrão
                if (alternativas.length === 0) {
                    alternativasLetras.forEach(letra => {
                        const texto = letra === question.correctAnswer 
                            ? `Alternativa correta ${letra}`
                            : `Alternativa ${letra}`;
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                }
                
                // Ordenar alternativas por letra
                alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                
                // Adicionar cada alternativa ao HTML
                const alternativesHtml = document.createElement('div');
                alternativesHtml.style.marginLeft = '30px';
                
                alternativas.forEach(({letra, texto}) => {
                    alternativesHtml.innerHTML += `
                        <p style="margin-bottom: 10px; font-size: 16px;">
                            <span style="display: inline-block; width: 25px; height: 25px; border-radius: 50%; border: 1px solid #666; text-align: center; line-height: 23px; margin-right: 10px; font-weight: bold;">${letra}</span>
                            ${texto}
                        </p>
                    `;
                });
                
                questionDiv.appendChild(alternativesHtml);
                questionsDiv.appendChild(questionDiv);
            });
            
            container.appendChild(questionsDiv);
        } else {
            // Se não houver questões, adicionar mensagem
            container.innerHTML += `
                <p style="text-align: center; font-style: italic; margin: 30px 0;">
                    Esta avaliação não contém questões.
                </p>
            `;
        }
        
        return container;
    }

    // Função para gerar o PDF
    async function generatePdf(libraries) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            
            // Definir uma largura fixa para o contêiner para evitar problemas de layout
            contentElement.style.width = '210mm';
            
            document.body.appendChild(contentElement);
            
            // Dar tempo para o DOM renderizar completamente
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Configurações do PDF (A4: 210mm x 297mm)
            const pdfOptions = {
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            };
            
            // Criar o documento PDF
            const pdf = new jsPDF(pdfOptions);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Configurações do html2canvas
            const canvasOptions = {
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: false,
                letterRendering: true,
                scrollX: 0,
                scrollY: 0
            };
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, canvasOptions);
            
            // Obter as dimensões originais do canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular proporção para ajustar à largura da página sem distorção
            const scaleFactor = pdfWidth / canvasWidth;
            const scaledHeight = canvasHeight * scaleFactor;
            
            console.log(`Canvas dimensions: ${canvasWidth}x${canvasHeight}`);
            console.log(`PDF dimensions: ${pdfWidth}x${pdfHeight}`);
            console.log(`Scale factor: ${scaleFactor}, Scaled height: ${scaledHeight}`);
            
            // Determinar quantas páginas serão necessárias
            const totalPages = Math.ceil(scaledHeight / pdfHeight);
            console.log(`Total pages: ${totalPages}`);
            
            // Processar cada página
            for (let i = 0; i < totalPages; i++) {
                // Adicionar nova página, exceto para a primeira
                if (i > 0) {
                    pdf.addPage();
                }
                
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Provas - SAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
        /* Ajustes de layout */
        .container-full {
            width: 100%;
            max-width: 100%;
            padding-left: 0;
            padding-right: 0;
        }
        .modal-overflow {
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ajusta layout em dispositivos móveis */
        @media (max-width: 768px) {
            .mobile-padding {
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
 
    
    <!-- Success Modal -->
    <div
      id="successModal"
      class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto"
    >
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-md mx-auto my-4">
            <div class="flex justify-between items-center mb-6">
          <h3 class="text-lg font-medium text-gray-900" id="successModalTitle">
            Operação Concluída
          </h3>
          <button
            id="closeSuccessModal"
            class="text-gray-400 hover:text-gray-500"
          >
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mb-6 text-center">
                <div class="text-green-500 text-4xl mb-4">
                    <i class="fas fa-check-circle"></i>
                </div>
          <p class="text-gray-700" id="successModalMessage">
            Operação realizada com sucesso!
          </p>
            </div>
            <div class="flex justify-center">
          <button
            id="successModalOkBtn"
            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
                    OK
                </button>
            </div>
        </div>
    </div>
    
    <script src="js/app.js"></script>
    <script src="js/alert.js"></script>
    <script>
        // Global variables para gerenciamento de habilidades BNCC
        let selectedSkills = [];
        let activeInputElement = null;

        // Base de dados de habilidades BNCC
        const bnccDatabase = {
        Português: {
          PRIMEIRO_ANO: [
            {
              code: "EF01LP01",
              description:
                "Reconhecer que textos são lidos e escritos da esquerda para a direita e de cima para baixo da página.",
            },
            {
              code: "EF01LP02",
              description:
                "Escrever, espontaneamente ou por ditado, palavras e frases de forma alfabética – usando letras/grafemas que representem fonemas.",
            },
            {
              code: "EF01LP03",
              description:
                "Observar escritas convencionais, comparando-as às suas produções escritas, percebendo semelhanças e diferenças.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02LP01",
              description:
                "Utilizar, ao produzir o texto, grafia correta de palavras conhecidas ou com estruturas silábicas já dominadas, letras maiúsculas em início de frases e em substantivos próprios, segmentação entre as palavras, ponto final, ponto de interrogação e ponto de exclamação.",
            },
            {
              code: "EF02LP02",
              description:
                "Segmentar palavras em sílabas e remover e substituir sílabas iniciais, mediais ou finais para criar novas palavras.",
            },
            {
              code: "EF02LP03",
              description:
                "Ler e escrever palavras com correspondências regulares diretas entre letras e fonemas (f, v, t, d, p, b) e correspondências regulares contextuais (c e q; e e o, em posição átona em final de palavra).",
            },
          ],
        },
        Matemática: {
          PRIMEIRO_ANO: [
            {
              code: "EF01MA01",
              description:
                "Utilizar números naturais como indicador de quantidade ou de ordem em diferentes situações cotidianas e reconhecer situações em que os números não indicam contagem nem ordem, mas sim código de identificação.",
            },
            {
              code: "EF01MA02",
              description:
                "Contar de maneira exata ou aproximada, utilizando diferentes estratégias como o pareamento e outros agrupamentos.",
            },
            {
              code: "EF01MA03",
              description:
                'Estimar e comparar quantidades de objetos de dois conjuntos (em torno de 20 elementos), por estimativa e/ou por correspondência (um a um, dois a dois) para indicar "tem mais", "tem menos" ou "tem a mesma quantidade".',
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02MA01",
              description:
                "Comparar e ordenar números naturais (até a ordem de centenas) pela compreensão de características do sistema de numeração decimal (valor posicional e função do zero).",
            },
            {
              code: "EF02MA02",
              description:
                "Fazer estimativas por meio de estratégias diversas a respeito da quantidade de objetos de coleções e registrar o resultado da contagem desses objetos (até 1000 unidades).",
            },
            {
              code: "EF02MA03",
              description:
                'Comparar quantidades de objetos de dois conjuntos, por estimativa e/ou por correspondência (um a um, dois a dois, entre outros), para indicar "tem mais", "tem menos" ou "tem a mesma quantidade", indicando, quando for o caso, quantos a mais e quantos a menos.',
            },
          ],
        },
        Ciências: {
          PRIMEIRO_ANO: [
            {
              code: "EF01CI01",
              description:
                "Comparar características de diferentes materiais presentes em objetos de uso cotidiano.",
            },
            {
              code: "EF01CI02",
              description:
                "Localizar, nomear e representar graficamente (por meio de desenhos) partes do corpo humano e explicar suas funções.",
            },
            {
              code: "EF01CI03",
              description:
                "Discutir as razões pelas quais os hábitos de higiene do corpo são necessários para a manutenção da saúde.",
            },
          ],
          SEGUNDO_ANO: [
            {
              code: "EF02CI01",
              description:
                "Identificar de que materiais (metais, madeira, vidro etc.) são feitos os objetos que fazem parte da vida cotidiana.",
            },
            {
              code: "EF02CI02",
              description:
                "Propor o uso de diferentes materiais para a construção de objetos de uso cotidiano.",
            },
            {
              code: "EF02CI03",
              description:
                "Discutir os cuidados necessários à prevenção de acidentes domésticos.",
            },
          ],
        },
      };

      document.addEventListener("DOMContentLoaded", function () {
            // Mobile menu toggle
        const mobileMenuBtn = document.getElementById("mobileMenuBtn");
        const mobileMenu = document.getElementById("mobileMenu");
            
            if (mobileMenuBtn && mobileMenu) {
          mobileMenuBtn.addEventListener("click", function () {
            mobileMenu.classList.toggle("hidden");
                });
            }
            
            // Atualizar nome do usuário
        const currentUser = JSON.parse(sessionStorage.getItem("currentUser"));
            if (currentUser) {
          document.getElementById("userName").textContent = currentUser.name;
            }
            
            // Inicializar localStorage para exams se não existir
        if (!localStorage.getItem("exams")) {
          localStorage.setItem("exams", JSON.stringify([]));
            }
            
            // Verificar se é modo de edição
            const urlParams = new URLSearchParams(window.location.search);
        const editExamId = urlParams.get("edit");
            
            if (editExamId) {
                openExamForEditing(parseInt(editExamId));
            }
            
            // Buscar provas da API
            loadExamsFromAPI();
            
            // Adicionar eventos para botões principais
            setupMainButtons();
            
            // Carregar componentes curriculares da API
            loadCurriculumComponentsFromAPI();
            
            // Configurar modal BNCC
        const closeBnccModalBtn = document.getElementById("closeBnccModal");
        const cancelBnccBtn = document.getElementById("cancelBnccBtn");
        const confirmBnccBtn = document.getElementById("confirmBnccBtn");
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const deselectAllBtn = document.getElementById("deselectAllBtn");
        const newSelectBnccBtn = document.getElementById("newSelectBnccBtn");

        if (closeBnccModalBtn)
          closeBnccModalBtn.addEventListener("click", closeBnccModal);
        if (cancelBnccBtn)
          cancelBnccBtn.addEventListener("click", closeBnccModal);
        if (confirmBnccBtn)
          confirmBnccBtn.addEventListener("click", confirmBnccSelection);
        if (bnccComponent)
          bnccComponent.addEventListener("change", updateBnccSkillsList);
        if (bnccGrade)
          bnccGrade.addEventListener("change", updateBnccSkillsList);
        if (bnccSearch) bnccSearch.addEventListener("input", filterBnccSkills);
        if (selectAllBtn)
          selectAllBtn.addEventListener("click", selectAllSkills);
        if (deselectAllBtn)
          deselectAllBtn.addEventListener("click", deselectAllSkills);
        if (newSelectBnccBtn)
          newSelectBnccBtn.addEventListener("click", openBnccSelector);
            
            // Configurar eventos para seletores BNCC em questões existentes
        document.querySelectorAll(".select-bncc-btn").forEach((btn) => {
          btn.addEventListener("click", openBnccSelector);
            });
            
            // Configurar uploads de imagem
            setupImageUploads();
            
            // Configurar botões adicionais para criar prova
        const addAnotherQuestionBtn = document.getElementById(
          "addAnotherQuestionBtn"
        );
            if (addAnotherQuestionBtn) {
          addAnotherQuestionBtn.addEventListener("click", addAnotherQuestion);
            }
            
        const finalizeExamBtnModal = document.getElementById(
          "finalizeExamBtnModal"
        );
            if (finalizeExamBtnModal) {
          finalizeExamBtnModal.addEventListener("click", finalizeExam);
            }
        });
        
        // Variáveis globais para o fluxo de criação de prova
        let currentExamData = {
        name: "",
        description: "",
        questions: [],
        };
        
        function setupMainButtons() {
            // Botão Criar Avaliação
        const createExamBtn = document.getElementById("createExamBtn");
            if (createExamBtn) {
          console.log("Adicionando evento de click ao botão Criar Avaliação");
          createExamBtn.addEventListener("click", function () {
            console.log("Botão Criar Avaliação clicado");
                    // Limpar dados da prova atual
                    currentExamData = {
              name: "",
              description: "",
              questions: [],
            };
            document
              .getElementById("createExamStepOneModal")
              .classList.remove("hidden");
                });
            }
            
            // Botão Vincular Prova
        const linkExamBtn = document.getElementById("linkExamBtn");
            if (linkExamBtn) {
          linkExamBtn.addEventListener("click", async function () {
            document.getElementById("linkExamModal").classList.remove("hidden");
                    
                    try {
                        // Configurar opções de série e turno
                        setupGradeAndShiftOptions();
                        
                        // Utilizar a função populateExamSelector para buscar provas da API
                        await populateExamSelector();
                        
                        // Utilizar a função populateSchoolSelector para buscar escolas da API
                        await populateSchoolSelector();
                    } catch (error) {
              console.error(
                "Erro ao preparar formulário de vinculação:",
                error
              );
              alert("Erro ao carregar dados para vinculação: " + error.message);
                    }
                });
            }
            
            // Botão Exportar Todas
        const exportAllExamsBtn = document.getElementById("exportAllExamsBtn");
            if (exportAllExamsBtn) {
          exportAllExamsBtn.addEventListener("click", exportAllExams);
            }
            
            // Botão Banco de Questões
        const questionBankBtn = document.getElementById("questionBankBtn");
            if (questionBankBtn) {
          questionBankBtn.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.remove("hidden");
                    loadQuestionBank();
                });
            }
            
            // Botão para adicionar questão no formulário principal
        const addQuestionBtn = document.getElementById("addQuestionBtn");
            if (addQuestionBtn) {
          addQuestionBtn.addEventListener("click", function () {
                    // Adicionar lógica para adicionar uma nova questão ao formulário
            alert(
              "Funcionalidade para adicionar questão no formulário principal"
            );
                });
            }
            
            // Botão de fechar o modal de examModal
        const closeExamModal = document.getElementById("closeExamModal");
            if (closeExamModal) {
          closeExamModal.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botão para cancelar adição de exame
        const cancelExamBtn = document.getElementById("cancelExamBtn");
            if (cancelExamBtn) {
          cancelExamBtn.addEventListener("click", function () {
            document.getElementById("addExamModal").classList.add("hidden");
                });
            }
            
            // Botões de fechamento de modais
            setupModalCloseButtons();
            
            // Configurar formulários
            setupFormSubmissions();
        }
        
        // Função para configurar opções de série e turno
        function setupGradeAndShiftOptions() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        function setupModalCloseButtons() {
            // Modal Criar Avaliação - Etapa 1
        document
          .getElementById("closeCreateExamStepOneModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelCreateExamStepOneBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("createExamStepOneModal")
              .classList.add("hidden");
            });
            
            // Modal Adicionar Questão
        document
          .getElementById("closeAddQuestionModal")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
          });

        document
          .getElementById("cancelAddQuestionBtn")
          ?.addEventListener("click", function () {
            document.getElementById("addQuestionModal").classList.add("hidden");
            });
            
            // Modal Opções de Questão
        document
          .getElementById("closeQuestionOptionsModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionOptionsModal")
              .classList.add("hidden");
            });
            
            // Modal Banco de Questões
        document
          .getElementById("closeQuestionBankModal")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
          });

        document
          .getElementById("cancelQuestionBankBtn")
          ?.addEventListener("click", function () {
            document
              .getElementById("questionBankModal")
              .classList.add("hidden");
            });
            
            // Modal Vincular Prova
        document
          .getElementById("closeLinkExamModal")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
          });

        document
          .getElementById("cancelLinkBtn")
          ?.addEventListener("click", function () {
            document.getElementById("linkExamModal").classList.add("hidden");
            });
        }
        
        function setupFormSubmissions() {
            // Formulário Etapa 1 - Informações Básicas
        const createExamStepOneForm = document.getElementById(
          "createExamStepOneForm"
        );
            if (createExamStepOneForm) {
          createExamStepOneForm.addEventListener("submit", function (e) {
                    e.preventDefault();
                    
                    // Obter dados do formulário
            const examName = document.getElementById("newExamName").value;
            const examDescription =
              document.getElementById("newExamDescription").value;
            const examEducationLevel = document.getElementById(
              "newExamEducationLevel"
            ).value;
                    
                    if (!examName) {
              alert("Por favor, insira um nome para a prova.");
                        return;
                    }
                    
                    if (!examEducationLevel) {
              alert("Por favor, selecione um nível de ensino.");
                        return;
                    }
                    
                    // Verificar se é edição ou criação
                    const isEditing = currentExamData.id !== undefined;
                    
                    // Atualizar dados da prova
                    currentExamData.name = examName;
                    currentExamData.description = examDescription;
                    currentExamData.educationLevel = examEducationLevel;
                    
            console.log(
              `${isEditing ? "Editando" : "Criando"} prova:`,
              currentExamData
            );
                    
                    // Se for edição, atualizar a prova no armazenamento
                    if (isEditing) {
              updateExam(currentExamData).then((success) => {
                            if (success) {
                                // Fechar modal
                  document
                    .getElementById("createExamStepOneModal")
                    .classList.add("hidden");
                                
                                // Atualizar lista de provas
                                loadExamsFromAPI();
                                
                                // Mostrar modal de sucesso
                  showSuccessModal(
                    "Avaliação Atualizada",
                    "A avaliação foi atualizada com sucesso!"
                  );
                            } else {
                  alert("Erro ao atualizar avaliação.");
                            }
                        });
                    } else {
                        // Processar para a próxima etapa (criação de nova prova)
              document
                .getElementById("createExamStepOneModal")
                .classList.add("hidden");
              document
                .getElementById("addQuestionModal")
                .classList.remove("hidden");
              document.getElementById("questionNumber").textContent = "1";
                        
                        // Limpar formulário de questão
              document.getElementById("addQuestionForm").reset();
                        
                        // Limpar preview de imagem se existir
              const imagePreview = document.querySelector(
                "#addQuestionModal .image-preview"
              );
                        if (imagePreview) {
                imagePreview.classList.add("hidden");
                const img = imagePreview.querySelector("img");
                if (img) img.src = "";
                        }
                    }
                });
            }
            
            // Formulário Adicionar Questão
        const addQuestionForm = document.getElementById("addQuestionForm");
            if (addQuestionForm) {
          addQuestionForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            if (!document.getElementById("questionText").value) {
              alert("Por favor, insira o texto da questão.");
                        return;
                    }
                    
            if (
              !document.querySelector('input[name="correctAnswer"]:checked')
            ) {
              alert("Por favor, selecione a alternativa correta.");
                        return;
                    }

                    try {
                        // ADICIONAR: Verificar se a prova já foi criada na API
                        if (!currentExamData.apiId) {
                console.log("Prova ainda não foi criada na API. Criando agora...");
                            
                            try {
                                // Criar a prova na API
                                const examData = {
                                    nome: currentExamData.name,
                                    descricao: currentExamData.description || "",
                                    data_aplicacao: new Date().toISOString(),
                                    nivel_ensino: currentExamData.educationLevel
                                };
                                
                                const provaResponse = await fetch(
                                    "https://sag-sag.rak8a3.easypanel.host/api/provas",
                                    {
                                        method: "POST",
                                        headers: {
                                            "Content-Type": "application/json",
                                            Accept: "application/json",
                                        },
                                        body: JSON.stringify(examData),
                                    }
                                );
                                
                                if (!provaResponse.ok) {
                                    const errorText = await provaResponse
                                        .text()
                                        .catch(() => "Erro desconhecido");
                                    throw new Error(
                                        `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
                                    );
                                }
                                
                                // Obter a prova criada
                                const savedExam = await provaResponse.json();
                                console.log("Prova criada com sucesso. ID:", savedExam.id);
                                
                                if (!savedExam.id) {
                                    throw new Error(
                                        "A prova foi criada, mas não recebeu um ID válido da API"
                                    );
                                }
                                
                                // Atualizar o ID da API no objeto currentExamData
                                currentExamData.apiId = savedExam.id;
                                
                            } catch (error) {
                                console.error("Erro ao criar prova:", error);
                                alert(`Erro ao criar prova: ${error.message}`);
                                return; // Interromper processamento
                            }
                        }
                        
                        // Obter o texto da questão
              const enunciado = document.getElementById("questionText").value;
                        
                        // Obter valor de imagem (se existir)
              const fileInput = document.querySelector("#questionImage");
              const imagePreview = document.querySelector("#addQuestionModal .image-preview");
              const imagem_url = fileInput && fileInput.files[0] ? fileInput.files[0].name : "";
            
              console.log("Caminho da imagem a ser enviada:", imagem_url);
                        
                        // Obter o nível de ensino (usar valor direto da API)
              const nivel_ensino = document.getElementById("educationLevel").value;
                        
                        // Obter série
              const serie = document.getElementById("gradeLevel").value;
                        
                        // Obter dificuldade
              const dificuldade =
                document.getElementById("difficultyLevel").value;
                        
                        // Obter componente curricular ID (deve ser um número)
              const componente_curricular_id = parseInt(
                document.getElementById("curriculumComponent").value,
                10
              );
                        
                        // Processar códigos BNCC (devem ser um array de números)
              const bnccCodesInput = document.getElementById("bnccCodes");
              let codigos_bncc = [];

              if (bnccCodesInput && bnccCodesInput.value) {
                  try {
                      codigos_bncc = JSON.parse(bnccCodesInput.value);
                  } catch (e) {
                      console.warn("Erro ao processar códigos BNCC:", e);
                  }
              }
                        
                        // Obter a resposta correta
              const correctAnswer = document.querySelector(
                'input[name="correctAnswer"]:checked'
              ).value;
                        
                        // Criar array de alternativas
                        const alternativas = [];
                        
                        // Adicionar cada alternativa ao array (apenas se tiver texto)
              const optionA = document.getElementById("optionA").value.trim();
                        if (optionA) {
                            alternativas.push({
                                texto: optionA,
                  correta: correctAnswer === "A",
                            });
                        }
                        
              const optionB = document.getElementById("optionB").value.trim();
                        if (optionB) {
                            alternativas.push({
                                texto: optionB,
                  correta: correctAnswer === "B",
                            });
                        }
                        
              const optionC = document.getElementById("optionC").value.trim();
                        if (optionC) {
                            alternativas.push({
                                texto: optionC,
                  correta: correctAnswer === "C",
                            });
                        }
                        
              const optionD = document.getElementById("optionD").value.trim();
                        if (optionD) {
                            alternativas.push({
                                texto: optionD,
                  correta: correctAnswer === "D",
                            });
                        }
                        
              const optionE = document.getElementById("optionE").value.trim();
                        if (optionE) {
                            alternativas.push({
                                texto: optionE,
                  correta: correctAnswer === "E",
                            });
                        }
                        
                        // Obter ID da prova atual
              const prova_id = parseInt(currentExamData.apiId, 10);
                        
                        // Validar que temos um ID válido antes de prosseguir
                        if (isNaN(prova_id) || prova_id <= 0) {
                throw new Error(
                    "ID da prova é inválido ou não foi criado. Salve a prova primeiro."
                );
                        }
                        
                        // Construir o objeto da questão exatamente no formato solicitado
                        const questionData = {
                            enunciado,
                            imagem_url,
                            nivel_ensino,
                            dificuldade,
                            serie,
                            pontos: 1,
                            prova_id,
                            componente_curricular_id,
                            codigos_bncc,
                            alternativas,
                        };
                        
              console.log(
                "Enviando questão para API:",
                JSON.stringify(questionData, null, 2)
              );
                        
                        // Enviar a requisição para o endpoint
              const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
              const response = await fetch(`${baseUrl}/api/questoes`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Accept: "application/json",
                },
                body: JSON.stringify(questionData),
            });
                        
                        if (!response.ok) {
                const errorText = await response
                  .text()
                  .catch(() => "Erro desconhecido");
                throw new Error(
                  `Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`
                );
                        }
                        
                        const savedQuestion = await response.json();
              console.log("Questão salva com sucesso:", savedQuestion);
                        
                        // Capturar dados da questão para o formato local (para histórico)
                        const questionDataLocal = {
                            text: enunciado,
                            educationLevel: nivel_ensino,
                            gradeLevel: serie,
                            difficultyLevel: dificuldade,
                            curriculumComponent: componente_curricular_id.toString(),
                            bnccCodes: codigos_bncc,
                            correctAnswer: correctAnswer,
                            options: {
                                A: optionA || '',
                                B: optionB || '',
                                C: optionC || '',
                                D: optionD || '',
                                E: optionE || ''
                            },
                            alternativas: alternativas.map(alt => ({
                                letra: alt.letra || "",
                                texto: alt.texto || "",
                                correta: (alt.letra || "").toUpperCase() === correctAnswer.toUpperCase()
                            })),
                            image: imagem_url,
                            apiId: savedQuestion.id,
                        };
                        
                        // Log para debug
                        console.log("Questão adicionada com alternativas:", JSON.stringify(questionDataLocal.options, null, 2));
                        
                        // Adicionar a questão à lista de questões
                        currentExamData.questions.push(questionDataLocal);
              console.log("Questão adicionada localmente:", questionDataLocal);
              console.log(
                `Total de questões: ${currentExamData.questions.length}`
              );
              console.log(
                `IMPORTANTE: Questão salva com ID da API: ${questionDataLocal.apiId}`
              );
              console.log("Estado atual das questões:");
                        currentExamData.questions.forEach((q, idx) => {
                console.log(
                  `  Questão ${idx + 1}: "${q.text.substring(
                    0,
                    30
                  )}..." - ID API: ${q.apiId || "não tem"}`
                );
                        });
                        
                        // Processar para a próxima etapa
              document
                .getElementById("addQuestionModal")
                .classList.add("hidden");
              document
                .getElementById("questionOptionsModal")
                .classList.remove("hidden");
              document.getElementById("totalQuestionsCount").textContent =
                currentExamData.questions.length;
                    } catch (error) {
              console.error("Erro ao salvar questão:", error);
                        alert(`Erro ao salvar questão: ${error.message}`);
                    }
                });
            }
            
            // Formulário Vincular Prova
        const linkExamForm = document.getElementById("linkExamForm");
            if (linkExamForm) {
          linkExamForm.addEventListener("submit", async function (e) {
                    e.preventDefault();
                    
                    // Validação básica
            const examId = document.getElementById("examSelect").value;
            const schoolId = document.getElementById("linkSchool").value;
            const grade = document.getElementById("linkGrade").value;
            const classId = document.getElementById("linkClass").value;
            const shift = document.getElementById("linkShift").value;
                    
                    if (!examId || !schoolId || !grade || !classId || !shift) {
              alert("Por favor, preencha todos os campos.");
                        return;
                    }
                    
                    // Desabilitar botão de submit e mostrar indicador de carregamento
                    const submitBtn = this.querySelector('button[type="submit"]');
                    const originalBtnText = submitBtn.innerHTML;
            submitBtn.innerHTML =
              '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
                    submitBtn.disabled = true;
                    
                    try {
                        // Enviar dados para a API com a rota correta
                        const payload = {
                            prova_id: examId,
                turma_id: classId,
                        };
                        
              console.log("Enviando dados para vincular prova:", payload);
                        
                        // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
              const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                        
                        // Enviar para a API
                        const response = await fetch(url, {
                method: "POST",
                            headers: {
                  "Content-Type": "application/json",
                            },
                body: JSON.stringify(payload),
                        });
                        
                        if (!response.ok) {
                throw new Error(
                  `Erro ao vincular prova. Status: ${response.status}`
                );
                        }
                        
                        // Fechar modal e mostrar mensagem de sucesso
              document.getElementById("linkExamModal").classList.add("hidden");
              alert("Prova vinculada com sucesso!");
                        
                        // Recarregar provas
                        loadExamsFromAPI();
                    } catch (error) {
              console.error("Erro ao vincular prova:", error);
              alert("Erro ao vincular prova: " + error.message);
                    } finally {
                        // Restaurar botão
                        submitBtn.innerHTML = originalBtnText;
                        submitBtn.disabled = false;
                    }
                });
            }
            
            // Alteração de escola no modal de vinculação
        document
          .getElementById("linkSchool")
          ?.addEventListener("change", async function () {
                const schoolId = this.value;
                if (!schoolId) return;
                
                try {
                    // Mostrar indicador de carregamento
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Carregando turmas...</option>';
                        classSelect.disabled = true;
                    }
                    
                    // Buscar turmas da API
              const response = await fetch(
                `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
                {
                  method: "GET",
                        headers: {
                    "Content-Type": "application/json",
                  },
                        }
              );
                    
                    if (!response.ok) {
                throw new Error(
                  `Erro ao carregar turmas. Status: ${response.status}`
                );
                    }
                    
                    const classes = await response.json();
                    
                    // Limpar seletor
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Selecione uma turma</option>';
                        
                        // Adicionar cada turma ao seletor
                classes.forEach((cls) => {
                  const option = document.createElement("option");
                            option.value = cls.id;
                            option.textContent = cls.nome || `Turma ${cls.id}`;
                            classSelect.appendChild(option);
                        });
                        
                        // Se não há turmas, mostrar mensagem
                        if (classes.length === 0) {
                  classSelect.innerHTML =
                    '<option value="">Nenhuma turma encontrada</option>';
                        }
                        
                        classSelect.disabled = false;
                    }
                } catch (error) {
              console.error("Erro ao buscar turmas:", error);
              const classSelect = document.getElementById("linkClass");
                    if (classSelect) {
                classSelect.innerHTML =
                  '<option value="">Erro ao carregar turmas</option>';
                        classSelect.disabled = false;
                    }
                }
            });
        }

        // Função para adicionar outra questão
        function addAnotherQuestion() {
        document.getElementById("questionOptionsModal").classList.add("hidden");
        document.getElementById("addQuestionModal").classList.remove("hidden");
            
            // Incrementar número da questão
        const currentNumber = parseInt(
          document.getElementById("questionNumber").textContent || "1"
        );
        document.getElementById("questionNumber").textContent =
          currentNumber + 1;
            
            // Limpar formulário
        document.getElementById("addQuestionForm")?.reset();
            
            // Limpar preview de imagem se existir
        const imagePreview = document.querySelector(
          "#addQuestionModal .image-preview"
        );
            if (imagePreview) {
          imagePreview.classList.add("hidden");
          const img = imagePreview.querySelector("img");
          if (img) img.src = "";
            }
        }
        
        // Função para finalizar a criação da prova
        async function finalizeExam() {
            if (currentExamData.questions.length === 0) {
          alert(
            "Adicione pelo menos uma questão antes de finalizar a avaliação."
          );
                return;
            }
            
            // Mostrar indicador de processamento
        const finalizeBtn = document.getElementById("finalizeExamBtnModal");
            const originalBtnText = finalizeBtn.innerHTML;
        finalizeBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i> Processando...';
            finalizeBtn.disabled = true;
            
            try {
          console.log(
            "Iniciando processo de finalização da prova:",
            currentExamData.name
          );
          console.log(
            `Total de questões a serem salvas: ${currentExamData.questions.length}`
          );
                
                // Verificar se a prova já foi criada (tem apiId)
                if (!currentExamData.apiId) {
            console.log("Prova ainda não foi criada na API. Criando agora...");
                    
                    // Determinar o nível de ensino no formato correto para a API
                    let nivelEnsino = "FUNDAMENTAL_I"; // Valor padrão
                    if (currentExamData.educationLevel) {
              switch (currentExamData.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "FUNDAMENTAL_I";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "FUNDAMENTAL_II";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "MEDIO";
                                break;
                            default:
                                nivelEnsino = "FUNDAMENTAL_I";
                        }
                    }
                    
                    // Criar a prova com dados básicos
                    const examData = {
                        nome: currentExamData.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: currentExamData.description || "",
                        nivel_ensino: nivelEnsino,
                        data_aplicacao: new Date().toISOString(),
              arquivo_url: "", // Campo obrigatório
                    };
                    
            console.log(
              "Payload para criação da prova:",
              JSON.stringify(examData, null, 2)
            );
                    
                    // 1. Primeiro, criar a prova sem questões
            const provaResponse = await fetch(
              "https://sag-sag.rak8a3.easypanel.host/api/provas",
              {
                method: "POST",
                        headers: {
                  "Content-Type": "application/json",
                  Accept: "application/json",
                        },
                body: JSON.stringify(examData),
              }
            );
                    
                    if (!provaResponse.ok) {
              const errorText = await provaResponse
                .text()
                .catch(() => "Erro desconhecido");
              throw new Error(
                `Falha ao criar prova. Status: ${provaResponse.status}. Detalhes: ${errorText}`
              );
                    }
                    
                    // Obter a prova criada
                    const savedExam = await provaResponse.json();
            console.log("Prova criada com sucesso. ID:", savedExam.id);
                    
                    if (!savedExam.id) {
              throw new Error(
                "A prova foi criada, mas não recebeu um ID válido da API"
              );
                    }
                    
                    // Atualizar o ID da API no exame atual
                    currentExamData.apiId = savedExam.id;
                } else {
            console.log(
              "Prova já existe na API com ID:",
              currentExamData.apiId
            );
                }
                
                // 2. Adicionar a prova ao armazenamento local
          const newExam = addExam(
            currentExamData.name,
            [],
            currentExamData.description,
            currentExamData.educationLevel
          );
                newExam.apiId = currentExamData.apiId;
                updateLocalExam(newExam);
          console.log(
            "Prova adicionada ao armazenamento local com ID da API:",
            newExam.apiId
          );
                
                // 3. Adicionar cada questão individualmente usando o endpoint /api/questoes
                const savedQuestions = [];
                const failedQuestions = [];
                
          console.log(
            `Começando a adicionar ${currentExamData.questions.length} questões...`
          );
                for (let i = 0; i < currentExamData.questions.length; i++) {
                    try {
                        const question = currentExamData.questions[i];
                        
                        // CORREÇÃO: Verificar se a questão já tem um ID da API (já foi salva)
                        if (question.apiId) {
                console.log(
                  `Questão ${i + 1}/${
                    currentExamData.questions.length
                  } já foi salva anteriormente com ID: ${question.apiId}`
                );
                            savedQuestions.push(question);
                            continue; // Pular para a próxima questão
                        }
                        
              console.log(
                `Adicionando questão ${i + 1}/${
                  currentExamData.questions.length
                }: "${question.text.substring(0, 30)}..."`
              );
                        
                        // Tentar salvar a questão usando saveQuestionToAPI
              const savedQuestion = await saveQuestionToAPI(
                question,
                currentExamData.apiId
              );
                        
                        if (savedQuestion && savedQuestion.apiId) {
                console.log(
                  `Questão ${i + 1} salva com sucesso, ID API: ${
                    savedQuestion.apiId
                  }`
                );
                            savedQuestions.push(savedQuestion);
                        } else {
                console.warn(
                  `Questão ${i + 1} foi processada, mas não retornou ID da API`
                );
                            // Ainda adicionar ao array para manter a consistência
                            savedQuestions.push(question);
                failedQuestions.push(i + 1);
                        }
                    } catch (error) {
              console.error(`Erro ao salvar questão ${i + 1}:`, error);
              failedQuestions.push(i + 1);
                    }
                }
                
                // 4. Atualizar as questões no exame local
                if (savedQuestions.length > 0) {
                    newExam.questions = savedQuestions;
                    updateLocalExam(newExam);
            console.log(
              `Exame local atualizado com ${savedQuestions.length} questões`
            );
                }
                
                // 5. Esconder modal e mostrar mensagem de sucesso
          document
            .getElementById("questionOptionsModal")
            .classList.add("hidden");
                
                // Ajustar mensagem com base no resultado
          let message = "";
                if (failedQuestions.length === 0) {
                    message = `Avaliação criada com sucesso! Todas as ${savedQuestions.length} questões foram adicionadas.`;
                } else {
                    message = `Avaliação criada com sucesso, mas ${failedQuestions.length} questões não puderam ser salvas. ${savedQuestions.length} questões foram adicionadas.`;
                }
                
          showSuccessModal("Avaliação Criada", message, () => {
                        // Limpar dados atuais
                        currentExamData = {
              name: "",
              description: "",
              questions: [],
                        };
                        
                        // Atualizar lista de provas
                        loadExamsFromAPI();
          });
                
                // 6. Atualizar a lista de provas
                await loadExamsFromAPI();
                renderExamsList();
                
          console.log("Processo de criação de prova finalizado com sucesso.");
            } catch (error) {
          console.error("Erro ao finalizar exame:", error);
          alert("Ocorreu um erro ao salvar a avaliação: " + error.message);
            } finally {
                // Restaurar botão
                finalizeBtn.innerHTML = originalBtnText;
                finalizeBtn.disabled = false;
            }
        }
        
        // Função auxiliar para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
          console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }
        
        // Script para atualizar os textos dos selects para mostrar valores dos enums
        function updateSelectOptionsToShowEnumValues() {
            // Garantir que os selects de nível de ensino tenham os valores de enum corretos
        const educationLevelSelects = document.querySelectorAll(
          ".education-level, #educationLevel, #bankEducationLevel, #newExamEducationLevel"
        );
            
            // Para cada select de nível de ensino, verificar se as opções têm os valores corretos
        educationLevelSelects.forEach((select) => {
                if (!select) return;
                
                // Verificar se já possui as opções corretas
                let hasCorrectOptions = false;
                for (let i = 0; i < select.options.length; i++) {
            if (
              select.options[i].value === "ANOS_INICIAIS" &&
              select.options[i].textContent === "Anos Iniciais"
            ) {
                        hasCorrectOptions = true;
                        break;
                    }
                }
                
                // Se já tem as opções corretas, apenas garantir que o texto seja igual ao valor
                if (hasCorrectOptions) {
            Array.from(select.options).forEach((option) => {
                        if (option.value) {
                            switch(option.value) {
                                case "ANOS_INICIAIS":
                                    option.textContent = "Anos Iniciais";
                                    break;
                                case "ANOS_FINAIS":
                                    option.textContent = "Anos Finais";
                                    break;
                                case "ENSINO_MEDIO":
                                    option.textContent = "Ensino Médio";
                                    break;
                            }
                        }
                    });
                } 
                // Caso contrário, recriar as opções com os valores corretos
                else {
                    // Salvar a opção vazia/placeholder
                    let placeholderOption = null;
                    for (let i = 0; i < select.options.length; i++) {
                        if (!select.options[i].value) {
                            placeholderOption = select.options[i].cloneNode(true);
                            break;
                        }
                    }
                    
                    // Limpar e adicionar a opção vazia se existir
            select.innerHTML = "";
                    if (placeholderOption) {
                        select.appendChild(placeholderOption);
                    }
                    
                    // Adicionar as opções com valores corretos
                    const correctValues = [
                        { value: "ANOS_INICIAIS", text: "Anos Iniciais" },
                        { value: "ANOS_FINAIS", text: "Anos Finais" },
                        { value: "ENSINO_MEDIO", text: "Ensino Médio" },
                    ];
                    
            correctValues.forEach((item) => {
              const option = document.createElement("option");
                        option.value = item.value;
                        option.textContent = item.text;
                        select.appendChild(option);
                    });
                }
            });

            // Atualizar os selects de série
            const gradeSelects = document.querySelectorAll(
                ".grade-level, #gradeLevel, #bankGrade, #linkGrade, #bnccGrade"
            );

            gradeSelects.forEach((select) => {
                if (!select) return;

                Array.from(select.options).forEach((option) => {
                    if (option.value) {
                        option.textContent = getFormattedGradeText(option.value);
                    }
                });
            });
        }
        
        // Chamar a função quando o DOM estiver carregado
      document.addEventListener("DOMContentLoaded", function () {
            // Chamar após carregar todos os outros scripts
            setTimeout(updateSelectOptionsToShowEnumValues, 500);
        });
        
        // Função para abrir o seletor de habilidades BNCC
        function openBnccSelector() {
            // Salvar referência ao elemento que receberá os códigos
        const questionItem =
          this.closest(".question-item") || this.closest("form");
        activeInputElement = questionItem
          ? questionItem.querySelector(".bncc-codes-input")
          : null;
            
            // Limpar seleções anteriores
            selectedSkills = [];
            
            // Carregar habilidades selecionadas atuais, se existirem
            if (activeInputElement && activeInputElement.value) {
          const codes = activeInputElement.value.split(",");
          codes.forEach((code) => {
                    const trimmedCode = code.trim();
                    if (trimmedCode) {
                        selectedSkills.push(trimmedCode);
                    }
                });
            }
            
            // Limpar filtros
        const bnccComponent = document.getElementById("bnccComponent");
        const bnccGrade = document.getElementById("bnccGrade");
        const bnccSearch = document.getElementById("bnccSearch");
            
            if (bnccComponent) bnccComponent.selectedIndex = 0;
            if (bnccGrade) bnccGrade.selectedIndex = 0;
        if (bnccSearch) bnccSearch.value = "";
            
            // Atualizar contagem de selecionados
        const selectedSkillsCount = document.getElementById(
          "selectedSkillsCount"
        );
        if (selectedSkillsCount)
          selectedSkillsCount.textContent = selectedSkills.length.toString();
            
            // Mostrar mensagem inicial
        const bnccSkillsList = document.getElementById("bnccSkillsList");
            if (bnccSkillsList) {
                bnccSkillsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        Carregando todas as habilidades... Você pode usar os filtros para restringir a lista.
                    </div>
                `;
            }
            
            // Abrir modal
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.remove("hidden");
            
            // Carregar todas as habilidades da API imediatamente
            updateBnccSkillsList();
        }
        
        // Função para fechar o modal BNCC
        function closeBnccModal() {
        const bnccModal = document.getElementById("bnccModal");
        if (bnccModal) bnccModal.classList.add("hidden");
        }
        
        // Função para confirmar a seleção de habilidades BNCC
        function confirmBnccSelection() {
            if (activeInputElement) {
          // Salvar códigos no input (apenas os códigos, não transformar em números)
          activeInputElement.value = selectedSkills.join(", ");
                
                // Atualizar UI
          const container =
            activeInputElement.closest(".question-item") ||
            activeInputElement.closest("form");
                if (container) {
            const countElement = container.querySelector(
              ".selected-skills-count"
            );
            const listElement = container.querySelector(
              ".selected-skills-list"
            );
                    
                    if (countElement) {
              countElement.textContent =
                selectedSkills.length > 0 ? `(${selectedSkills.length})` : "";
                    }
                    
                    if (listElement) {
              listElement.innerHTML = "";

              selectedSkills.forEach((code) => {
                const div = document.createElement("div");
                div.className =
                  "px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded flex justify-between items-center mb-1";
                            div.innerHTML = `
                                <span>${code}</span>
                                <button type="button" class="remove-skill text-blue-500 hover:text-blue-700" data-code="${code}">
                                    <i class="fas fa-times-circle"></i>
                                </button>
                            `;
                            
                            listElement.appendChild(div);
                            
                            // Adicionar evento para remover habilidade
                const removeBtn = div.querySelector(".remove-skill");
                            if (removeBtn) {
                  removeBtn.addEventListener("click", function () {
                    const codeToRemove = this.getAttribute("data-code");
                                    
                                    // Remover do array
                                    const index = selectedSkills.indexOf(codeToRemove);
                                    if (index !== -1) {
                                        selectedSkills.splice(index, 1);
                                    }
                                    
                    // Atualizar input (apenas os códigos, não transformar em números)
                    activeInputElement.value = selectedSkills.join(", ");
                                    
                                    // Remover elemento visual
                    this.closest("div").remove();
                                    
                                    // Atualizar contagem
                                    if (countElement) {
                      countElement.textContent =
                        selectedSkills.length > 0
                          ? `(${selectedSkills.length})`
                          : "";
                                    }
                                });
                            }
                        });
                    }
                }
            }
            
            // Fechar modal
            closeBnccModal();
        }
        
        // Função para atualizar a lista de habilidades BNCC
        function updateBnccSkillsList() {
        const component = document.getElementById("bnccComponent")?.value;
        const grade = document.getElementById("bnccGrade")?.value;
        const skillsList = document.getElementById("bnccSkillsList");
            
            if (!skillsList) return;
            
            skillsList.innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="mt-2 text-gray-500">Carregando habilidades...</p>
                </div>
            `;
            
            // Mesmo se componente e série não forem selecionados, vamos carregar todas as habilidades
        loadBnccSkillsFromAPI(grade, component)
          .then((apiSkills) => {
                // Limpar a lista
            skillsList.innerHTML = "";
                
                // Se não houver habilidades, mostrar mensagem
                if (!apiSkills || apiSkills.length === 0) {
                    skillsList.innerHTML = `
                        <div class="text-center text-gray-500 py-4">
                            Nenhuma habilidade encontrada para esta combinação
                        </div>
                    `;
                    return;
                }
                
                // Adicionar cada habilidade à lista
            apiSkills.forEach((skill) => {
              const code = skill.codigo || "";
              const description = skill.descricao || "";
                    
                    const isSelected = selectedSkills.includes(code);
              const div = document.createElement("div");
              div.className =
                "p-2 border-b border-gray-100 last:border-b-0 skill-item";
              div.setAttribute("data-code", code);
              div.setAttribute("data-visible", "true");
                    
                    div.innerHTML = `
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                              isSelected ? "checked" : ""
                            }>
                            <span class="ml-2">
                                <span class="block text-sm font-medium">${code}</span>
                                <span class="block text-xs text-gray-500">${description}</span>
                            </span>
                        </label>
                    `;
                    
                    // Adicionar evento ao checkbox
                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                checkbox.addEventListener("change", function () {
                            if (this.checked) {
                                // Adicionar à seleção
                                if (!selectedSkills.includes(code)) {
                                    selectedSkills.push(code);
                                }
                            } else {
                                // Remover da seleção
                                const index = selectedSkills.indexOf(code);
                                if (index !== -1) {
                                    selectedSkills.splice(index, 1);
                                }
                            }
                            
                            // Atualizar contagem
                  const count = document.getElementById("selectedSkillsCount");
                  if (count)
                    count.textContent = selectedSkills.length.toString();
                        });
                    }
                    
                    skillsList.appendChild(div);
                });
          })
          .catch((error) => {
            console.error("Erro ao carregar habilidades:", error);
                
                skillsList.innerHTML = `
                    <div class="text-center text-red-500 py-4">
                        Erro ao carregar habilidades. Tentando usar dados locais...
                    </div>
                `;
                
                // Tentar usar dados locais como fallback
                setTimeout(() => {
                    // Verificar se existem habilidades no banco de dados local para o componente e série
              const localComponent = Object.keys(bnccDatabase).find(
                (key) => key.toLowerCase() === component?.toLowerCase()
              );

              if (
                localComponent &&
                grade &&
                bnccDatabase[localComponent][grade]
              ) {
                        const skills = bnccDatabase[localComponent][grade];
                        
                        // Limpar a lista
                skillsList.innerHTML = "";
                        
                        // Adicionar cada habilidade local à lista
                skills.forEach((skill) => {
                            const isSelected = selectedSkills.includes(skill.code);
                  const div = document.createElement("div");
                  div.className =
                    "p-2 border-b border-gray-100 last:border-b-0 skill-item";
                  div.setAttribute("data-code", skill.code);
                  div.setAttribute("data-visible", "true");
                            
                            div.innerHTML = `
                                <label class="flex items-start cursor-pointer">
                                    <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600" ${
                                      isSelected ? "checked" : ""
                                    }>
                                    <span class="ml-2">
                                        <span class="block text-sm font-medium">${
                                          skill.code
                                        }</span>
                                        <span class="block text-xs text-gray-500">${
                                          skill.description
                                        }</span>
                                    </span>
                                </label>
                            `;
                            
                            // Adicionar evento ao checkbox
                            const checkbox = div.querySelector('input[type="checkbox"]');
                            if (checkbox) {
                    checkbox.addEventListener("change", function () {
                                    if (this.checked) {
                                        // Adicionar à seleção
                                        if (!selectedSkills.includes(skill.code)) {
                                            selectedSkills.push(skill.code);
                                        }
                                    } else {
                                        // Remover da seleção
                                        const index = selectedSkills.indexOf(skill.code);
                                        if (index !== -1) {
                                            selectedSkills.splice(index, 1);
                                        }
                                    }
                                    
                                    // Atualizar contagem
                      const count = document.getElementById(
                        "selectedSkillsCount"
                      );
                      if (count)
                        count.textContent = selectedSkills.length.toString();
                                });
                            }
                            
                            skillsList.appendChild(div);
                        });
                    } else {
                        skillsList.innerHTML = `
                            <div class="text-center text-gray-500 py-4">
                                Nenhuma habilidade encontrada ${
                                  component ? "para " + component : ""
                                } ${grade ? " - " + grade : ""}
                            </div>
                        `;
                    }
                }, 500);
            });
        }
        
        // Função para filtrar habilidades BNCC
        function filterBnccSkills() {
        const searchText =
          document.getElementById("bnccSearch")?.value.toLowerCase() || "";
        const skillItems = document.querySelectorAll(
          "#bnccSkillsList .skill-item"
        );

        skillItems.forEach((item) => {
          const code = item.getAttribute("data-code") || "";
          const description =
            item.querySelector(".text-gray-500")?.textContent.toLowerCase() ||
            "";
                
                // Verificar se o texto de busca está no código ou na descrição
          if (
            code.toLowerCase().includes(searchText) ||
            description.includes(searchText)
          ) {
            item.style.display = "";
            item.setAttribute("data-visible", "true");
                } else {
            item.style.display = "none";
            item.setAttribute("data-visible", "false");
                }
            });
        }
        
        // Função para selecionar todas as habilidades visíveis
        function selectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && !checkbox.checked && code) {
                    checkbox.checked = true;
                    
                    // Adicionar à seleção
                    if (!selectedSkills.includes(code)) {
                        selectedSkills.push(code);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para desmarcar todas as habilidades visíveis
        function deselectAllSkills() {
        const visibleItems = document.querySelectorAll(
          '#bnccSkillsList .skill-item[data-visible="true"]'
        );
            
        visibleItems.forEach((item) => {
                const checkbox = item.querySelector('input[type="checkbox"]');
          const code = item.getAttribute("data-code") || "";
                
                if (checkbox && checkbox.checked && code) {
                    checkbox.checked = false;
                    
                    // Remover da seleção
                    const index = selectedSkills.indexOf(code);
                    if (index !== -1) {
                        selectedSkills.splice(index, 1);
                    }
                }
            });
            
            // Atualizar contagem
        const count = document.getElementById("selectedSkillsCount");
            if (count) count.textContent = selectedSkills.length.toString();
        }
        
        // Função para configurar uploads de imagem
        function setupImageUploads() {
        document.querySelectorAll(".question-image").forEach((input) => {
          input.addEventListener("change", handleImageUpload);
            });
            
        document.querySelectorAll(".remove-image").forEach((button) => {
          button.addEventListener("click", handleImageRemove);
            });
        }
        
        // Função para tratar upload de imagem
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Pegar o caminho completo do arquivo
            const filePath = file.name;
            
            const reader = new FileReader();
            const container = this.closest(".question-item") || this.closest("form");
            const previewContainer = container?.querySelector(".image-preview");
            const previewImg = previewContainer?.querySelector("img");
            const fileInput = container?.querySelector(".question-image") || container?.querySelector("#questionImage");
            
            if (!previewContainer || !previewImg || !fileInput) return;
            
            reader.onload = function (event) {
                // Mostrar preview da imagem
                previewImg.src = event.target.result;
                previewContainer.classList.remove("hidden");
                
                // Armazenar o caminho do arquivo
                fileInput.dataset.imagePath = filePath;
                
                console.log('Imagem carregada. Caminho:', filePath);
            };
            
            reader.readAsDataURL(file);
        }
        
        
        // Função para remover imagem
        function handleImageRemove() {
        const container =
          this.closest(".question-item") || this.closest("form");
        const previewContainer = container?.querySelector(".image-preview");
        const fileInput =
          container?.querySelector(".question-image") ||
          container?.querySelector("#questionImage");
            
            if (previewContainer) {
          previewContainer.classList.add("hidden");
          const img = previewContainer.querySelector("img");
          if (img) img.src = "";
            }
            
            if (fileInput) {
          fileInput.value = "";
            }
        }
        
        // Função para renderizar lista de avaliações
        function renderExamsList() {
        const examsList = document.getElementById("examsList");
            if (!examsList) return;
            
            // Obter avaliações do localStorage
            let exams = [];
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    exams = JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            
        console.log("Avaliações encontradas:", exams.length, exams);
            
            // Filtrar provas vazias - remover provas com 0 questões e que não existem no banco de dados
            // Remover também as provas simuladas específicas que foram mencionadas
            const namesToRemove = [
          "Avaliação Diagnóstica - Português",
          "Avaliação Diagnóstica - Matemática",
          "Avaliação Bimestral - Português",
          "Avaliação Bimestral - Matemática",
          "Avaliação Final - Ciências",
        ];

        exams = exams.filter((exam) => {
                // Verificar se a prova tem questões
                const questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Incluir a prova apenas se não está na lista de nomes a remover OU tem questões OU tem um ID da API
          return (
            !namesToRemove.includes(exam.name) ||
            questionsCount > 0 ||
            exam.apiId
          );
            });
            
            // Salvar a lista filtrada de volta no localStorage
        localStorage.setItem("exams", JSON.stringify(exams));
            
            // Se não há avaliações, mostrar mensagem
            if (!exams || exams.length === 0) {
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        Nenhuma prova cadastrada
                    </li>
                `;
                return;
            }
            
            // Limpar lista
        examsList.innerHTML = "";
            
            // Adicionar cada avaliação à lista
        exams.forEach((exam) => {
          const li = document.createElement("li");
          li.className = "block hover:bg-gray-50";
                
                // Verificar se a prova tem questões
                let questionsCount = exam.questions ? exam.questions.length : 0;
                
                // Se tiver ID da API mas nenhuma questão local, tentar atualizar o contador com uma mensagem
                let questionCountText = `Questões: ${questionsCount}`;
                if (questionsCount === 0 && exam.apiId) {
                    // Tentar carregar os detalhes da prova da API para mostrar o número correto
                    loadExamDetails(exam.apiId, exams.indexOf(exam), exams)
              .then((success) => {
                            if (success) {
                                // Atualizar a visualização após carregar os detalhes
                                const updatedExams = getExams();
                  const updatedExam = updatedExams.find(
                    (e) => e.id === exam.id
                  );
                                if (updatedExam && updatedExam.questions.length > 0) {
                    const questionCountElement =
                      li.querySelector(".question-count");
                                    if (questionCountElement) {
                                        questionCountElement.textContent = `Questões: ${updatedExam.questions.length}`;
                                    }
                                }
                            }
                        })
              .catch((err) =>
                console.error("Erro ao carregar detalhes da prova:", err)
              );
                        
                    questionCountText = `<span class="question-count">Questões: ${questionsCount} <i class="fas fa-sync-alt fa-spin text-xs ml-1" title="Atualizando contador de questões..."></i></span>`;
                } else {
                    questionCountText = `<span class="question-count">Questões: ${questionsCount}</span>`;
                }
                
                // Formatar data de criação
          let createdAt = "";
                try {
                    if (exam.createdAt) {
                        const date = new Date(exam.createdAt);
              createdAt = date.toLocaleDateString("pt-BR");
                    }
                } catch (e) {
            console.error("Erro ao formatar data:", e);
                }
                
                // Badge para nível de ensino
          const educationLevelBadge = exam.educationLevel
            ? `<span class="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-800 rounded">${exam.educationLevel}</span>`
            : "";
                
          console.log(
            `Renderizando prova: ${exam.name}, API ID: ${exam.apiId}, Questões: ${questionsCount}`
          );
                
                li.innerHTML = `
                    <div class="flex items-center px-4 py-4 sm:px-6">
                        <div class="min-w-0 flex-1 flex items-center">
                            <div class="flex-shrink-0">
                                <span class="h-12 w-12 rounded-full bg-yellow-100 flex items-center justify-center">
                                    <i class="fas fa-file-alt text-yellow-600 text-lg"></i>
                                </span>
                            </div>
                            <div class="min-w-0 flex-1 px-4">
                                <div>
                                    <p class="text-sm font-medium text-blue-600 truncate">
                                        ${exam.name} ${educationLevelBadge}
                                    </p>
                                    <p class="mt-1 text-sm text-gray-500">
                                        ${questionCountText} | Criada em: ${createdAt}
                                    </p>
                                    ${
                                      exam.description
                                        ? `<p class="mt-1 text-xs text-gray-400 truncate">${exam.description}</p>`
                                        : ""
                                    }
                                </div>
                            </div>
                        </div>
                                                <div class="flex space-x-2">                            <button onclick="visualizarProva(${exam.apiId || exam.id})" class="bg-white text-blue-500 p-2 rounded-full hover:bg-blue-100 border border-gray-200" data-id="${exam.id}" title="Visualizar Prova"><i class="fas fa-eye"></i></button>                            <button class="text-blue-600 hover:text-blue-900 editExam" data-id="${                              exam.id                            }" title="Editar">                                <i class="fas fa-edit"></i>                            </button>                            <button class="text-indigo-600 hover:text-indigo-900 editQuestionsExam" data-id="${                              exam.id                            }" data-api-id="${exam.apiId || ''}" title="Editar Questões">                                <i class="fas fa-list-check"></i>                            </button>                            <button class="text-purple-600 hover:text-purple-900 downloadExam" data-id="${                              exam.id                            }" title="Baixar PDF">                                <i class="fas fa-file-pdf"></i>                            </button>                        
                                                  <button class="text-red-600 hover:text-red-900" 
        onclick="handleDeleteExam('${exam.id}')" 
        data-id="${exam.id}" 
        title="Excluir prova">
    <i class="fas fa-trash"></i>
</button>
                            </div>
                    </div>
                `;
                
                examsList.appendChild(li);
            });
            
            // Adicionar eventos aos botões
            setupExamListButtons();
        }
        
        // Função para configurar botões na lista de avaliações
        function setupExamListButtons() {
            // Visualizar avaliação
            document.querySelectorAll(".viewExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    viewExam(examId);
                });
            });
            
            // Editar avaliação
            document.querySelectorAll(".editExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    openExamForEditing(examId);
                });
            });
            
            // Editar questões da avaliação
            document.querySelectorAll(".editQuestionsExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const apiId = this.getAttribute("data-api-id");
                    if (!apiId) {
                        alert("Esta prova não possui ID da API e não pode ter suas questões editadas.");
                        return;
                    }
                    openEditQuestionsModal(examId, apiId);
                });
            });
            
            // Baixar avaliação
            document.querySelectorAll(".downloadExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    if (exam) {
                        // Adicionar debug para ver a estrutura da prova
                        console.log("ESTRUTURA DA PROVA:", JSON.stringify(exam, null, 2));
                        console.log("QUESTÕES:", JSON.stringify(exam.questions, null, 2));
                        if (exam.questions && exam.questions.length > 0) {
                            console.log("PRIMEIRA QUESTÃO:", JSON.stringify(exam.questions[0], null, 2));
                            console.log("ALTERNATIVAS:", JSON.stringify(exam.questions[0].options || exam.questions[0].alternativas, null, 2));
                        }
                        exportExamToDocx(exam);
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
            
            // Excluir avaliação
            document.querySelectorAll(".deleteExam").forEach((button) => {
                button.addEventListener("click", function () {
                    const examId = parseInt(this.getAttribute("data-id"));
                    const exams = getExams();
                    const exam = exams.find((e) => e.id === examId);
                    
                    if (exam) {
                        // Confirmar exclusão
                        if (confirm(`Tem certeza que deseja excluir a prova "${exam.name}"?`)) {
                            // Verificar se tem apiId para excluir na API
                            if (exam.apiId) {
                                deleteExamAPI(exam.apiId, examId);
                            } else {
                                // Se não tiver apiId, apenas excluir localmente
                                removeExamLocally(examId);
                                alert('Prova excluída com sucesso!');
                                renderExamsList(); // Atualizar a lista após exclusão
                            }
                        }
                    } else {
                        alert("Avaliação não encontrada!");
                    }
                });
            });
        }
        
        // Função para visualizar uma avaliação
        function viewExam(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Aqui você pode implementar a visualização completa da avaliação
            // Por enquanto, mostraremos algumas informações básicas
        alert(
          `Visualizando: ${exam.name}\nTotal de questões: ${exam.questions.length}`
        );
            
            // Em um caso real, você abriria um modal ou navegaria para uma página de detalhes
        }
        
        // Função para abrir uma avaliação para edição
        function openExamForEditing(examId) {
            const exams = getExams();
        const exam = exams.find((e) => e.id === examId);
            
            if (!exam) {
          alert("Avaliação não encontrada!");
                return;
            }
            
            // Preencher dados no modal de edição
        document.getElementById("newExamName").value = exam.name;
        document.getElementById("newExamDescription").value =
          exam.description || "";
            
            // Definir o nível de ensino
        const educationLevelSelect = document.getElementById(
          "newExamEducationLevel"
        );
            if (educationLevelSelect) {
                // Tentar encontrar o option com o valor igual ao do exame
          const eduLevel = exam.educationLevel || "";
                let optionExists = false;
                
                // Procurar pelo valor exato primeiro
                for (let i = 0; i < educationLevelSelect.options.length; i++) {
                    if (educationLevelSelect.options[i].value === eduLevel) {
                        educationLevelSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }
                
                // Se não encontrou, tentar mapear para um valor válido da API
                if (!optionExists) {
            let mappedValue = "";
                    const eduLevelUpper = eduLevel.toUpperCase();
                    
            if (
              eduLevelUpper.includes("INICIAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL I")
            ) {
              mappedValue = "ANOS_INICIAIS";
            } else if (
              eduLevelUpper.includes("FINAIS") ||
              eduLevelUpper.includes("FUNDAMENTAL II")
            ) {
              mappedValue = "ANOS_FINAIS";
            } else if (
              eduLevelUpper.includes("MÉDIO") ||
              eduLevelUpper.includes("MEDIO")
            ) {
              mappedValue = "ENSINO_MEDIO";
                    }
                    
                    if (mappedValue) {
                        for (let i = 0; i < educationLevelSelect.options.length; i++) {
                            if (educationLevelSelect.options[i].value === mappedValue) {
                                educationLevelSelect.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Armazenar o ID da prova que está sendo editada
            currentExamData = {
                id: exam.id,
                apiId: exam.apiId,
                name: exam.name,
          description: exam.description || "",
          questions: [...exam.questions], // Clone para não modificar o original
            };
            
            // Abrir o modal de edição
        document
          .getElementById("createExamStepOneModal")
          .classList.remove("hidden");
            
            // Atualizar o título do modal
        const modalTitle = document.querySelector("#createExamStepOneModal h3");
            if (modalTitle) {
          modalTitle.textContent = "Editar Prova";
            }
            
            // Atualizar o texto do botão
        const submitBtn = document.querySelector(
          '#createExamStepOneForm button[type="submit"]'
        );
            if (submitBtn) {
          submitBtn.textContent = "Continuar para Edição de Questões";
            }
        }
        
        // Função para atualizar uma prova existente
        async function updateExam(exam) {
            try {
          console.log("Iniciando atualização da prova ID:", exam.id);
                
                // Atualizar localmente
                let exams = getExams();
          const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
            localStorage.setItem("exams", JSON.stringify(exams));
            console.log("Prova atualizada no armazenamento local");
                } else {
            throw new Error("Prova não encontrada no armazenamento local");
                }
                
                // Se tiver ID da API, atualizar remotamente
                if (exam.apiId) {
                    // Mapear o nível de ensino - usar apenas valores válidos para a API
                    let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                    if (exam.educationLevel) {
              switch (exam.educationLevel.toUpperCase()) {
                            case "FUNDAMENTAL ANOS INICIAIS":
                            case "FUNDAMENTAL I":
                            case "ANOS_INICIAIS":
                                nivelEnsino = "ANOS_INICIAIS";
                                break;
                            case "FUNDAMENTAL ANOS FINAIS":
                            case "FUNDAMENTAL II":
                            case "ANOS_FINAIS":
                                nivelEnsino = "ANOS_FINAIS";
                                break;
                            case "ENSINO MÉDIO":
                            case "MÉDIO":
                            case "ENSINO_MEDIO":
                                nivelEnsino = "ENSINO_MEDIO";
                                break;
                            default:
                                // Caso não identifique, usar o padrão ANOS_INICIAIS
                                nivelEnsino = "ANOS_INICIAIS";
                        }
                    }
                    
                    // Converter para o formato da API
                    const apiExam = {
                        id: exam.apiId,
                        nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
              descricao: exam.description || "",
                        data_aplicacao: new Date().toISOString(),
              nivel_ensino: nivelEnsino,
                    };
                    
            console.log("Dados enviados para a API:", apiExam);
                    
                    // Adicionar questões se existirem
                    if (exam.questions && exam.questions.length > 0) {
              apiExam.questoes = exam.questions.map((q) => {
                            return {
                                texto: q.text,
                                nivel_ensino: nivelEnsino,
                  serie: q.gradeLevel || "",
                  dificuldade: q.difficultyLevel || "",
                  componente_curricular: q.curriculumComponent || "",
                  codigos_bncc: q.bnccCodes || "",
                  resposta_correta: q.correctAnswer || "A",
                  alternativa_a: q.options.A || "",
                  alternativa_b: q.options.B || "",
                  alternativa_c: q.options.C || "",
                  alternativa_d: q.options.D || "",
                  alternativa_e: q.options.E || "",
                  imagem: q.image || null,
                            };
                        });
                    }
                    
            console.log(
              `Enviando atualização para a API: /api/provas/${exam.apiId}`,
              apiExam
            );

            const response = await fetch(
              `https://sag-sag.rak8a3.easypanel.host/api/provas/${exam.apiId}`,
              {
                method: "PUT",
                        headers: {
                  "Content-Type": "application/json",
                        },
                body: JSON.stringify(apiExam),
              }
            );
                    
                    if (!response.ok) {
              const errorText = await response
                .text()
                .catch(() => "Erro desconhecido");
              console.error(
                `Erro ao atualizar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
              );
              throw new Error(
                `Não foi possível atualizar a prova na API. Status: ${response.status}`
              );
                    }
                    
                    const updatedExam = await response.json().catch(() => null);
            console.log("Prova atualizada com sucesso na API:", updatedExam);
                    
                    // Se a API retornou dados atualizados, sincronizar com a cópia local
                    if (updatedExam) {
                        // Atualizar dados que possam ter sido modificados pela API
                        exam.apiId = updatedExam.id;
                        // Atualizar no armazenamento local
                        exams[index] = exam;
              localStorage.setItem("exams", JSON.stringify(exams));
                        
                        // Recarregar a lista de provas da API para garantir sincronização
              console.log("Recarregando lista de provas da API...");
                        await loadExamsFromAPI();
                    }
                    
                    // Atualizar a interface
                    renderExamsList();
            console.log("Interface atualizada com os novos dados da prova");
                    
                    return true;
                } else {
                    // Se não tem ID da API, tentar criar novo registro na API
                    try {
              console.log(
                "Prova sem ID da API. Tentando criar novo registro na API..."
              );
                        const savedExam = await saveExamToAPI(exam);
                        if (savedExam && savedExam.id) {
                            // Atualizar o ID da API na cópia local
                            exam.apiId = savedExam.id;
                            exams[index] = exam;
                localStorage.setItem("exams", JSON.stringify(exams));
                console.log("Prova criada na API com sucesso:", savedExam);
                            
                            // Recarregar a lista de provas da API
                            await loadExamsFromAPI();
                            
                            // Atualizar a interface
                            renderExamsList();
                        }
                    } catch (apiError) {
              console.error("Erro ao criar prova na API:", apiError);
                        // Continue mesmo se falhar na API, pois já temos localmente
                        
                        // Atualizar a interface de qualquer forma
                        renderExamsList();
                    }
                    return true;
                }
            } catch (error) {
          console.error("Erro ao atualizar prova:", error);
                return false;
            }
        }
        
        // Função para excluir uma avaliação
        async function handleDeleteExam(examId) {
    // Confirmação antes de excluir
    const confirmed = confirm("Tem certeza que deseja excluir esta prova? Esta ação não pode ser desfeita.");
    
    if (confirmed) {
        await deleteExam(examId);
    }
}

// Função para excluir uma avaliação (corrigida)
async function deleteExam(examId) {
    try {
        // Validação do ID
        if (!examId || examId === 'undefined' || examId === 'null') {
            throw new Error("ID da prova não fornecido ou inválido");
        }

        console.log(`Tentando excluir prova com ID: ${examId}`);

        // URL da API para exclusão de provas
        const deleteUrl = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}`;
        console.log(`Enviando requisição DELETE para: ${deleteUrl}`);
        
        const response = await fetch(deleteUrl, {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        });
        
        // Verificar resultado da requisição
        if (response.ok) {
            console.log(`Prova ID ${examId} excluída com sucesso da API`);
            
            // Atualizar a lista local de provas
            let exams = getExams() || [];
            exams = exams.filter(e => e.id != examId); // Usando != para comparar string e number
            localStorage.setItem("exams", JSON.stringify(exams));
            
            // Atualizar a interface
            if (typeof renderExamsList === 'function') {
                renderExamsList();
            }
            
            // Mostrar mensagem de sucesso
            if (typeof showSuccessModal === 'function') {
                showSuccessModal("Prova Excluída", "A prova foi excluída com sucesso!");
            } else {
                alert("Prova excluída com sucesso!");
            }
            
            return true;
        } else {
            const errorText = await response.text().catch(() => "Erro desconhecido");
            const statusText = response.status === 404 ? "Prova não encontrada" : `Erro ${response.status}`;
            console.error(`Erro ao excluir prova na API. Status: ${response.status}, Detalhes: ${errorText}`);
            alert(`Erro ao excluir prova: ${statusText}`);
            return false;
        }
    } catch (error) {
        console.error("Erro ao excluir prova:", error);
        alert(`Erro ao excluir prova: ${error.message}`);
        return false;
    }
}

// Alternativa usando event delegation (mais eficiente se você tem muitos botões)
// Adicione este código uma vez quando a página carregar:
document.addEventListener('click', function(event) {
    // Verifica se o clique foi em um botão de excluir ou em seu ícone
    const deleteButton = event.target.closest('button[data-id]');
    
    if (deleteButton && deleteButton.title === 'Excluir prova') {
        event.preventDefault();
        
        const examId = deleteButton.getAttribute('data-id');
        
        if (examId) {
            handleDeleteExam(examId);
        } else {
            console.error('ID da prova não encontrado no botão');
            alert('Erro: ID da prova não encontrado');
        }
    }
});
        
        // Função para obter todas as avaliações
        function getExams() {
            try {
          const storedExams = localStorage.getItem("exams");
                if (storedExams) {
                    return JSON.parse(storedExams);
                }
            } catch (e) {
          console.error("Erro ao obter avaliações:", e);
            }
            return [];
        }
        
        // Função para adicionar uma nova avaliação
      function addExam(name, questions, description = "", educationLevel = "") {
            // Obter avaliações existentes
            let exams = getExams() || [];
            
            // Gerar ID único
        const newId = exams.length > 0 ? Math.max(...exams.map((e) => e.id)) + 1 : 1;
            
            // Processar as questões para garantir formato correto
            const processedQuestions = questions.map(question => {
                console.log("Processando questão para addExam:", question);
                
                // Garantir que options está no formato correto
                const options = {};
                
                // Caso 1: Se já tem um objeto options com formato {A: "texto", B: "texto"}
                if (question.options && typeof question.options === 'object' && !Array.isArray(question.options)) {
                    options.A = question.options.A || '';
                    options.B = question.options.B || '';
                    options.C = question.options.C || '';
                    options.D = question.options.D || '';
                    options.E = question.options.E || '';
                }
                // Caso 2: Se tem um array de alternativas
                else if (question.alternativas && Array.isArray(question.alternativas)) {
                    const letters = ['A', 'B', 'C', 'D', 'E'];
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letra = letters[index];
                            options[letra] = alt.texto || alt.text || '';
                        }
                    });
                }
                
                console.log("Opções processadas:", options);
                
                // Retornar questão processada
                return {
                    ...question,
                    options: options
                };
            });
            
            // Criar objeto de avaliação
            const newExam = {
                id: newId,
                name: name,
                description: description,
                educationLevel: educationLevel,
                questions: processedQuestions,
                createdAt: new Date().toISOString(),
                links: [],
            };
            
            // Adicionar à lista
            exams.push(newExam);
            
            // Salvar no localStorage
            localStorage.setItem("exams", JSON.stringify(exams));
            
            console.log("Nova avaliação adicionada:", newExam);
            
            return newExam;
        }
        
        // Função para popular o seletor de avaliações
        async function populateExamSelector() {
        const examSelect = document.getElementById("examSelect");
            if (!examSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          examSelect.innerHTML =
            '<option value="">Carregando provas...</option>';
                examSelect.disabled = true;
                
                // Buscar provas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/provas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const exams = await response.json();
          console.log("Provas carregadas da API:", exams);
                
                // Limpar seletor
          examSelect.innerHTML =
            '<option value="">Selecione uma prova</option>';
                
                // Verificar se a resposta é um array
                if (Array.isArray(exams) && exams.length > 0) {
                    // Adicionar cada prova ao seletor
            exams.forEach((exam) => {
              const option = document.createElement("option");
                        option.value = exam.id;
                        
                        // Dar preferência ao campo 'nome'
                        if (exam.nome !== undefined) {
                            option.textContent = exam.nome;
                        } else if (exam.titulo !== undefined) {
                            option.textContent = exam.titulo;
                        } else {
                option.textContent = "Prova sem título";
                        }
                        
                        examSelect.appendChild(option);
                    });
                } else {
                    // Se não houver provas, mostrar mensagem
            examSelect.innerHTML =
              '<option value="">Nenhuma prova disponível</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar provas:", error);
          examSelect.innerHTML =
            '<option value="">Erro ao carregar provas</option>';
            } finally {
                examSelect.disabled = false;
            }
            
            return examSelect;
        }
        
        // Função para popular o seletor de escolas
        async function populateSchoolSelector() {
        const schoolSelect = document.getElementById("linkSchool");
            if (!schoolSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          schoolSelect.innerHTML =
            '<option value="">Carregando escolas...</option>';
                schoolSelect.disabled = true;
                
                // Buscar escolas da API
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/escolas",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar escolas. Status: ${response.status}`
            );
                }
                
                const schools = await response.json();
                
                // Limpar seletor
          schoolSelect.innerHTML =
            '<option value="">Selecione uma escola</option>';
                
                // Adicionar cada escola ao seletor
          schools.forEach((school) => {
            const option = document.createElement("option");
                    option.value = school.id;
            option.textContent = school.nome || "Escola sem nome";
                    schoolSelect.appendChild(option);
                });
            } catch (error) {
          console.error("Erro ao buscar escolas:", error);
          schoolSelect.innerHTML =
            '<option value="">Erro ao carregar escolas</option>';
            } finally {
                schoolSelect.disabled = false;
            }
        }
        
        // Função para popular o seletor de turmas
        async function populateClassSelector(schoolId) {
        const classSelect = document.getElementById("linkClass");
            if (!classSelect) return;
            
            try {
                // Mostrar indicador de carregamento
          classSelect.innerHTML =
            '<option value="">Carregando turmas...</option>';
                classSelect.disabled = true;
                
                if (!schoolId) {
            classSelect.innerHTML =
              '<option value="">Selecione uma escola primeiro</option>';
                    classSelect.disabled = true;
                    return;
                }
                
                // Buscar turmas da API
          const response = await fetch(
            `https://sag-sag.rak8a3.easypanel.host/api/turmas?escolaId=${schoolId}`,
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar turmas. Status: ${response.status}`
            );
                }
                
                const classes = await response.json();
                
                // Limpar seletor
          classSelect.innerHTML =
            '<option value="">Selecione uma turma</option>';
                
                // Adicionar cada turma ao seletor
          classes.forEach((cls) => {
            const option = document.createElement("option");
                    option.value = cls.id;
                    option.textContent = cls.nome || `Turma ${cls.id}`;
                    classSelect.appendChild(option);
                });
                
                // Se não há turmas, mostrar mensagem
                if (classes.length === 0) {
            classSelect.innerHTML =
              '<option value="">Nenhuma turma encontrada</option>';
                }
            } catch (error) {
          console.error("Erro ao buscar turmas:", error);
          classSelect.innerHTML =
            '<option value="">Erro ao carregar turmas</option>';
            } finally {
                classSelect.disabled = false;
            }
        }
        
        // Atualizar o formulário de vincular prova
        function updateLinkExamForm() {
            // Atualizar série (ano)
        const gradeSelect = document.getElementById("linkGrade");
            if (gradeSelect) {
                gradeSelect.innerHTML = '<option value="">Selecione a série</option>';
                
                const grades = [
            { value: "PRIMEIRO_ANO", label: "1º Ano" },
            { value: "SEGUNDO_ANO", label: "2º Ano" },
            { value: "TERCEIRO_ANO", label: "3º Ano" },
            { value: "QUARTO_ANO", label: "4º Ano" },
            { value: "QUINTO_ANO", label: "5º Ano" },
            { value: "SEXTO_ANO", label: "6º Ano" },
            { value: "SETIMO_ANO", label: "7º Ano" },
            { value: "OITAVO_ANO", label: "8º Ano" },
            { value: "NONO_ANO", label: "9º Ano" },
            { value: "PRIMEIRA_SERIE", label: "1ª Série" },
            { value: "SEGUNDA_SERIE", label: "2ª Série" },
            { value: "TERCEIRA_SERIE", label: "3ª Série" }
        ];

        grades.forEach((grade) => {
            const option = document.createElement("option");
            option.value = grade.value;
            option.textContent = grade.label;
            gradeSelect.appendChild(option);
        });
            }
            
            // Atualizar turno
        const shiftSelect = document.getElementById("linkShift");
            if (shiftSelect) {
                shiftSelect.innerHTML = '<option value="">Selecione o turno</option>';
                
                const shifts = [
            { value: "MANHA", label: "Matutino" },
            { value: "TARDE", label: "Vespertino" },
            { value: "NOITE", label: "Noturno" },
            // { value: "INTEGRAL", label: "INTEGRAL" },
          ];

          shifts.forEach((shift) => {
            const option = document.createElement("option");
                    option.value = shift.value;
                    option.textContent = shift.label;
                    shiftSelect.appendChild(option);
                });
            }
        }
        
        // Função para vincular uma avaliação a uma turma
        async function linkExamToClass(examId, schoolId, grade, classId, shift) {
            try {
                const payload = {
                    prova_id: examId,
            turma_id: classId,
                };
                
          console.log("Enviando dados para vincular prova:", payload);
                
                // Construir a URL no formato /api/provas/{provaId}/turmas/{turmaId}
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/turmas/${classId}`;
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao vincular prova. Status: ${response.status}`
            );
                }
                
                const result = await response.json();
          console.log("Prova vinculada com sucesso:", result);
                
                return true;
            } catch (error) {
          console.error("Erro ao vincular prova:", error);
                throw error;
            }
        }
        
        // Função para exportar uma avaliação para PDF
        function exportExamToDocx(exam) {
    // Verificar se o objeto exam é válido
    if (!exam || !exam.name) {
        alert('Prova inválida para exportação!');
        return;
    }

    // Log detalhado de depuração para mostrar as alternativas
    console.log("INICIANDO EXPORTAÇÃO DA PROVA:", exam.name);
    if (exam.questions && exam.questions.length > 0) {
        exam.questions.forEach((q, index) => {
            console.log(`Questão ${index + 1}:`, q.text);
            console.log(`  Alternativas para questão ${index + 1}:`, q.options);
            
            // Verificar se as alternativas estão vazias
            const hasNonEmptyOptions = q.options && Object.values(q.options).some(opt => opt && opt.trim() !== '');
            console.log(`  Tem alternativas não vazias? ${hasNonEmptyOptions}`);
            
            if (!hasNonEmptyOptions) {
                console.warn("⚠️ ALTERNATIVAS VAZIAS DETECTADAS! Verificando alternativas originais no localStorage...");
                
                // Buscar dados originais do localStorage
                try {
                    const exams = JSON.parse(localStorage.getItem("exams")) || [];
                    const localExam = exams.find(e => e.id === exam.id);
                    if (localExam && localExam.questions) {
                        const localQuestion = localExam.questions.find(lq => lq.id === q.id || lq.apiId === q.apiId);
                        if (localQuestion && localQuestion.options) {
                            console.log("  Alternativas no localStorage:", localQuestion.options);
                            
                            // Atualizar as alternativas da questão atual com as do localStorage
                            if (Object.values(localQuestion.options).some(opt => opt && opt.trim() !== '')) {
                                console.log("  ✅ Usando alternativas do localStorage");
                                q.options = localQuestion.options;
                            }
                        }
                    }
                } catch (error) {
                    console.error("Erro ao buscar alternativas do localStorage:", error);
                }
            }
        });
    }

    // Indicar que estamos processando
    const processingMessage = document.createElement('div');
    processingMessage.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    processingMessage.innerHTML = `
        <div class="bg-white p-4 rounded-lg shadow-lg text-center">
            <div class="animate-spin inline-block w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full mb-4"></div>
            <p class="text-gray-800">Gerando PDF...</p>
        </div>
    `;
    document.body.appendChild(processingMessage);

    // Função para carregar as bibliotecas necessárias (jsPDF e html2canvas)
    function loadPdfLibraries() {
        return new Promise((resolve, reject) => {
            // Verificar se as bibliotecas já estão carregadas
            if (typeof jspdf !== 'undefined' && typeof html2canvas !== 'undefined') {
                resolve({ jspdf, html2canvas });
                return;
            }

            // Contador para controlar o carregamento das duas bibliotecas
            let loaded = 0;
            
            // Carregar jsPDF
            const jspdfScript = document.createElement('script');
            jspdfScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            jspdfScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            jspdfScript.onerror = () => reject(new Error('Falha ao carregar jsPDF'));
            document.head.appendChild(jspdfScript);
            
            // Carregar html2canvas
            const html2canvasScript = document.createElement('script');
            html2canvasScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            html2canvasScript.onload = function() {
                loaded++;
                if (loaded === 2) {
                    resolve({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                }
            };
            html2canvasScript.onerror = () => reject(new Error('Falha ao carregar html2canvas'));
            document.head.appendChild(html2canvasScript);
        });
    }

    // Função para remover a mensagem de processamento
    function removeProcessingMessage() {
        if (processingMessage && processingMessage.parentNode) {
            processingMessage.parentNode.removeChild(processingMessage);
        }
    }

    // Função para criar o conteúdo HTML que será convertido em PDF
    function createExamContent() {
        // Criar um contêiner para o conteúdo do PDF
        const container = document.createElement('div');
        container.style.width = '210mm'; // Largura A4
        container.style.padding = '20mm';
        container.style.backgroundColor = 'white';
        container.style.color = 'black';
        container.style.fontFamily = 'Arial, sans-serif';
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.top = '0';
        
        // Cabeçalho da avaliação
        container.innerHTML = `
            <div style="margin-bottom: 20px;">
                <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">AVALIAÇÃO</h1>
                <h2 style="font-size: 20px; font-weight: bold; margin-bottom: 20px;">${exam.name.toUpperCase()}</h2>
                <p style="margin-bottom: 10px; font-size: 16px;">Nome do Aluno: _____________________________________________</p>
                <p style="margin-bottom: 30px; font-size: 16px;">Data: ___/___/______</p>
            </div>
            
            <!-- Instruções -->
            <div style="border: 1px solid #999; padding: 15px; margin-bottom: 30px;">
                <p style="font-weight: bold; margin-bottom: 10px; color: #666;">INSTRUÇÕES:</p>
                <p style="margin-bottom: 8px; color: #666;">1. Leia atentamente cada questão antes de respondê-la</p>
                <p style="margin-bottom: 8px; color: #666;">2. Use caneta azul ou preta para marcar suas respostas</p>
                <p style="margin-bottom: 8px; color: #666;">3. Não é permitido o uso de corretivo</p>
                <p style="color: #666;">4. Questões rasuradas serão anuladas</p>
            </div>
        `;
        
        // Adicionar questões
        if (exam.questions && exam.questions.length > 0) {
            const questionsDiv = document.createElement('div');
            
            exam.questions.forEach((question, index) => {
                const questionText = question.text || question.enunciado || "";
                if (!questionText) {
                    console.warn(`Questão ${index + 1} não tem texto definido, pulando...`);
                    return;
                }
                
                // Cabeçalho da questão
                const questionDiv = document.createElement('div');
                questionDiv.style.marginBottom = '30px';
                questionDiv.style.pageBreakInside = 'avoid';
                
                questionDiv.innerHTML = `
                    <div style="border-top: 1px solid #ccc; margin-top: 15px; margin-bottom: 15px;"></div>
                    <div style="display: flex; margin-bottom: 15px;">
                        <div style="background-color: #666; color: white; padding: 8px 15px; font-weight: bold; width: 30%; display: inline-block;">
                            QUESTÃO ${index + 1}
                        </div>
                        <div style="padding: 8px 15px; width: 70%; text-align: right; display: inline-block;">
                            1 ponto
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 16px; margin-left: 15px;">${questionText}</p>
                `;
                
                // Adicionar imagem se existir
                if (question.image && question.image !== 'null' && question.image !== 'undefined' && question.image.trim() !== '') {
                    questionDiv.innerHTML += `
                        <div style="text-align: center; margin: 15px 0;">
                            <img src="${question.image}" alt="Imagem da questão" style="max-width: 80%; max-height: 200px; border: 1px solid #ddd; padding: 5px;">
                            <p style="font-style: italic; color: #666; font-size: 12px; margin-top: 5px;">Figura ${index + 1}: Imagem referente à questão</p>
                        </div>
                    `;
                }
                
                // Adicionar alternativas
                const alternativasLetras = ['A', 'B', 'C', 'D', 'E'];
                let alternativas = [];
                
                if (question.options && typeof question.options === 'object') {
                    // Formato {A: "texto", B: "texto"}
                    alternativasLetras.forEach(letra => {
                        let texto = '';
                        
                        // Se tem texto na alternativa, use-o
                        if (question.options[letra] && question.options[letra].trim() !== '') {
                            texto = question.options[letra];
                        } 
                        // Caso contrário, use um texto padrão
                        else {
                            texto = letra === question.correctAnswer 
                                ? `Alternativa correta ${letra}`
                                : `Alternativa ${letra}`;
                        }
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                } else if (question.alternativas && Array.isArray(question.alternativas)) {
                    question.alternativas.forEach((alt, index) => {
                        if (index < alternativasLetras.length) {
                            const letra = alternativasLetras[index];
                            let texto = alt.texto || alt.text || '';
                            
                            if (!texto || texto.trim() === '') {
                                texto = letra === question.correctAnswer 
                                    ? `Alternativa correta ${letra}`
                                    : `Alternativa ${letra}`;
                            }
                            
                            alternativas.push({
                                letra: letra,
                                texto: texto
                            });
                        }
                    });
                }
                
                // Se não encontrou alternativas, criar alternativas padrão
                if (alternativas.length === 0) {
                    alternativasLetras.forEach(letra => {
                        const texto = letra === question.correctAnswer 
                            ? `Alternativa correta ${letra}`
                            : `Alternativa ${letra}`;
                        
                        alternativas.push({
                            letra: letra,
                            texto: texto
                        });
                    });
                }
                
                // Ordenar alternativas por letra
                alternativas.sort((a, b) => a.letra.localeCompare(b.letra));
                
                // Adicionar cada alternativa ao HTML
                const alternativesHtml = document.createElement('div');
                alternativesHtml.style.marginLeft = '30px';
                
                alternativas.forEach(({letra, texto}) => {
                    alternativesHtml.innerHTML += `
                        <p style="margin-bottom: 10px; font-size: 16px;">
                            <span style="display: inline-block; width: 25px; height: 25px; border-radius: 50%; border: 1px solid #666; text-align: center; line-height: 23px; margin-right: 10px; font-weight: bold;">${letra}</span>
                            ${texto}
                        </p>
                    `;
                });
                
                questionDiv.appendChild(alternativesHtml);
                questionsDiv.appendChild(questionDiv);
            });
            
            container.appendChild(questionsDiv);
        } else {
            // Se não houver questões, adicionar mensagem
            container.innerHTML += `
                <p style="text-align: center; font-style: italic; margin: 30px 0;">
                    Esta avaliação não contém questões.
                </p>
            `;
        }
        
        return container;
    }

    // Função para gerar o PDF
    async function generatePdf(libraries) {
        try {
            console.log('Iniciando exportação da prova para PDF:', exam.name);
            
            // Obter referências às bibliotecas
            const { jspdf, html2canvas } = libraries;
            const { jsPDF } = jspdf;
            
            // Criar conteúdo HTML
            const contentElement = createExamContent();
            document.body.appendChild(contentElement);
            
            // Criar documento PDF (A4: 210mm x 297mm)
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4'
            });
            
            // Definir configurações do PDF
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            
            // Renderizar HTML para canvas
            const canvas = await html2canvas(contentElement, {
                scale: 2, // Escala maior para melhor qualidade
                useCORS: true, // Para carregar imagens corretamente
                allowTaint: true,
                logging: false,
                windowWidth: contentElement.offsetWidth || 794 // Aproximadamente 210mm em pixels
            });
            
            // Manter a proporção original sem esticar
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calcular a proporção de aspecto do conteúdo
            const contentRatio = canvasHeight / canvasWidth;
            
            // Calcular altura do PDF baseado na largura e proporção de aspecto original
            const contentWidth = pdfWidth; // Usar toda a largura disponível
            const contentHeight = contentWidth * contentRatio;
            
            // Processar páginas separadamente para evitar distorção
            const pageCount = Math.ceil(contentHeight / pdfHeight);
            
            // Para cada página
            for (let i = 0; i < pageCount; i++) {
                if (i > 0) {
                    pdf.addPage();
                }
                
                // Calcular que parte do canvas mostrar em cada página
                const sourceY = i * pdfHeight / contentHeight * canvasHeight;
                const sourceHeight = Math.min(canvasHeight - sourceY, pdfHeight / contentHeight * canvasHeight);
                
                pdf.addImage(
                    canvas.toDataURL('image/jpeg', 1.0),
                    'JPEG',
                    0, // x position
                    0, // y position
                    pdfWidth,
                    pdfHeight,
                    null,
                    'FAST',
                    0,
                    i * pdfHeight / contentHeight * canvasHeight // sourceY
                );
            }
            
            // Remover o elemento HTML
            document.body.removeChild(contentElement);
            
            // Salvar o arquivo PDF
            pdf.save(`${exam.name.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`);
            
            alert(`Prova "${exam.name}" exportada para PDF com sucesso!`);
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            alert(`Erro ao exportar para PDF: ${error.message}`);
        } finally {
            removeProcessingMessage();
        }
    }

    // Tentar uma abordagem alternativa com div2pdf.js
    function tryUsingJsPdfHtml2Canvas() {
        // Criar conteúdo HTML para o PDF
        const container = createExamContent();
        document.body.appendChild(container);
        
        // Carregar bibliotecas necessárias
        loadPdfLibraries()
            .then(libraries => {
                setTimeout(() => {
                    generatePdf(libraries);
                }, 500); // Pequeno atraso para renderizar o HTML
            })
            .catch(error => {
                console.error('Erro ao carregar bibliotecas para PDF:', error);
                
                // Tentar carregar versões alternativas das bibliotecas
                const jspdfAlt = document.createElement('script');
                jspdfAlt.src = 'https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js';
                
                const html2canvasAlt = document.createElement('script');
                html2canvasAlt.src = 'https://unpkg.com/html2canvas@latest/dist/html2canvas.min.js';
                
                document.head.appendChild(jspdfAlt);
                document.head.appendChild(html2canvasAlt);
                
                setTimeout(() => {
                    if (typeof window.jspdf !== 'undefined' && typeof window.html2canvas !== 'undefined') {
                        generatePdf({ jspdf: window.jspdf, html2canvas: window.html2canvas });
                    } else {
                        removeProcessingMessage();
                        document.body.removeChild(container);
                        alert('Não foi possível carregar as bibliotecas necessárias para exportação em PDF. Por favor, verifique sua conexão com a internet e tente novamente.');
                    }
                }, 2000);
            });
    }
    
    // Iniciar o processo de exportação
    tryUsingJsPdfHtml2Canvas();
}
        // Função para exportar todas as avaliações
        function exportAllExams() {
            const exams = getExams();
            
    if (!exams || exams.length === 0) {
                alert('Não há avaliações para exportar.');
                return;
            }
            
    alert(`Iniciando exportação de ${exams.length} avaliações. Isso pode levar alguns instantes.`);
    
    // Exportar de forma sequencial com um atraso entre cada exportação
    function exportSequentially(index) {
        if (index >= exams.length) {
            alert('Todas as avaliações foram exportadas com sucesso!');
            return;
        }
        
        setTimeout(() => {
            try {
                exportExamToDocx(exams[index]);
                
                // Após 1.5 segundos, exportar a próxima
                setTimeout(() => {
                    exportSequentially(index + 1);
                }, 1500);
            } catch (error) {
                console.error(`Erro ao exportar avaliação ${index + 1}:`, error);
                alert(`Ocorreu um erro ao exportar a avaliação "${exams[index].name}". Continuando com as próximas...`);
                
                // Continuar mesmo em caso de erro
                setTimeout(() => {
                    exportSequentially(index + 1);
                }, 500);
            }
        }, 100);
    }
    
    // Iniciar a exportação sequencial
    exportSequentially(0);
}
      // Função para exportar todas as avaliações
      function exportAllExams() {
        const exams = getExams();

        if (exams.length === 0) {
          alert("Não há avaliações para exportar.");
          return;
        }

        alert(`Exportando ${exams.length} avaliações. Por favor, aguarde...`);

        // Exportar cada exame em sequência
        let contador = 0;

        function exportarProximo() {
          if (contador < exams.length) {
            exportExamToDocx(exams[contador]);
            contador++;

            // Aguardar um pequeno intervalo antes de exportar a próxima
            setTimeout(exportarProximo, 1500);
          } else {
            alert("Todas as provas foram exportadas com sucesso!");
          }
        }

        // Iniciar o processo de exportação
        exportarProximo();
        }
        
        // Função para carregar o banco de questões (placeholder)
        function loadQuestionBank() {
        console.log("Carregando banco de questões...");
            // Implementar lógica para carregar questões do banco
            
        const questionBankList = document.getElementById("questionBankList");
            if (questionBankList) {
                // Exemplo de como preencher o banco
                questionBankList.innerHTML = `
                    <div class="p-4 border-b">
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600">
                            <div class="ml-3">
                                <p class="text-sm font-medium text-gray-700">Qual é a capital do Brasil?</p>
                                <p class="text-xs text-gray-500 mt-1">Língua Portuguesa | 5º Ano | Fácil</p>
                            </div>
                        </label>
                    </div>
                    <div class="p-4 border-b">
                        <label class="flex items-start cursor-pointer">
                            <input type="checkbox" class="mt-1 form-checkbox h-4 w-4 text-blue-600">
                            <div class="ml-3">
                                <p class="text-sm font-medium text-gray-700">Qual é o resultado de 9 x 7?</p>
                                <p class="text-xs text-gray-500 mt-1">Matemática | 3º Ano | Médio</p>
                            </div>
                        </label>
                    </div>
                `;
            }
        }

        // Função para carregar provas da API
        async function loadExamsFromAPI() {
            try {
                // Mostrar mensagem de carregamento
          const examsList = document.getElementById("examsList");
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                        <i class="fas fa-spinner fa-spin mr-2"></i> Carregando provas da API...
                    </li>`;
                
                // Fazer requisição para a API
          const url = "https://sag-sag.rak8a3.easypanel.host/api/provas";
                console.log(`Carregando lista de provas da API: ${url}`);
                
                const response = await fetch(url, {
            method: "GET",
                    headers: {
              "Content-Type": "application/json",
            },
                });
                
          console.log(
            "Status da resposta da listagem de provas:",
            response.status
          );
                
                if (!response.ok) {
            const errorText = await response
              .text()
              .catch(() => "Erro desconhecido");
            console.error(
              `Erro ao carregar provas. Status: ${response.status}, Detalhes: ${errorText}`
            );
            throw new Error(
              `Erro ao carregar provas. Status: ${response.status}`
            );
                }
                
                const data = await response.json();
          console.log(
            `Provas recebidas da API: ${data.length} provas carregadas`
          );
                
                if (data.length === 0) {
            console.log("Nenhuma prova encontrada na API");
                    examsList.innerHTML = `
                        <li class="px-4 py-4 sm:px-6 text-center text-gray-500">
                            Nenhuma prova disponível na API.
                        </li>`;
                    return;
                }
                
                // Obter exames locais
                let localExams = getExams();
                
                // Converter dados da API para o formato local
                if (Array.isArray(data)) {
                    // Manter o controle de provas que foram encontradas na API
                    const apiExamIds = [];
                    
                    for (const apiExam of data) {
                        apiExamIds.push(apiExam.id);
                        
                        // Verificar se já existe um exame com este API ID
              const existingExamIndex = localExams.findIndex(
                (e) => e.apiId === apiExam.id
              );
                        
                        // Mapear os níveis de ensino para o formato esperado pela API
              let nivelEnsino = apiExam.nivel_ensino || "";
                        
                        // Se já existe localmente, atualizar os dados
                        if (existingExamIndex !== -1) {
                console.log(
                  `Atualizando prova local ID ${localExams[existingExamIndex].id} com dados da API ID ${apiExam.id}`
                );
                            
                            // Verificar explicitamente o campo nome
                            if (apiExam.nome !== undefined) {
                                console.log(`Nome da prova na API: "${apiExam.nome}"`);
                                localExams[existingExamIndex].name = apiExam.nome;
                            } else if (apiExam.titulo !== undefined) {
                                console.log(`Título da prova na API: "${apiExam.titulo}"`);
                                localExams[existingExamIndex].name = apiExam.titulo;
                            } else {
                                console.log("API não retornou nome ou título para a prova");
                            }
                            
                localExams[existingExamIndex].description =
                  apiExam.descricao || "";
                localExams[existingExamIndex].createdAt =
                  apiExam.data_aplicacao ||
                  apiExam.createdAt ||
                  new Date().toISOString();
                            localExams[existingExamIndex].educationLevel = nivelEnsino;
                            
                            // Buscar detalhes como questões, etc se necessário
                await loadExamDetails(
                  apiExam.id,
                  existingExamIndex,
                  localExams
                );
                        } else {
                            // Esta é uma nova prova da API, vamos adicioná-la localmente
                console.log(
                  `Adicionando nova prova da API ID ${apiExam.id} ao armazenamento local`
                );
                            
                            // Verificar explicitamente o campo nome para a nova prova
                let examName = "Prova sem título";
                            if (apiExam.nome !== undefined) {
                                examName = apiExam.nome;
                                console.log(`Nome da nova prova na API: "${apiExam.nome}"`);
                            } else if (apiExam.titulo !== undefined) {
                                examName = apiExam.titulo;
                  console.log(
                    `Título da nova prova na API: "${apiExam.titulo}"`
                  );
                            }
                            
                            // Adicionar um novo exame com dados básicos da API
                            const newExam = {
                  id:
                    localExams.length > 0
                      ? Math.max(...localExams.map((e) => e.id)) + 1
                      : 1,
                                name: examName,
                  description: apiExam.descricao || "",
                                educationLevel: nivelEnsino,
                                questions: [],
                  createdAt:
                    apiExam.data_aplicacao ||
                    apiExam.createdAt ||
                    new Date().toISOString(),
                                links: [],
                  apiId: apiExam.id,
                            };
                            
                            localExams.push(newExam);
                            const newExamIndex = localExams.length - 1;
                            
                            // Buscar detalhes da prova
                            await loadExamDetails(apiExam.id, newExamIndex, localExams);
                        }
                    }
                    
                    // Salvar a lista atualizada
            localStorage.setItem("exams", JSON.stringify(localExams));
            console.log(
              `${localExams.length} provas salvas no armazenamento local`
            );
                }
                
                // Renderizar a lista de provas
                renderExamsList();
            } catch (error) {
          console.error("Erro ao carregar provas da API:", error);
                
                // Mostrar mensagem de erro ao usuário
          const examsList = document.getElementById("examsList");
                examsList.innerHTML = `
                    <li class="px-4 py-4 sm:px-6 text-center text-red-500">
                        Erro ao carregar provas da API: ${error.message}. Usando dados locais.
                    </li>`;
                
                // Carregar dados locais como fallback
                setTimeout(() => {
                    renderExamsList();
                }, 1500);
            }
        }

        // Função para carregar detalhes de uma prova específica
        async function loadExamDetails(examId, localIndex, localExams) {
            try {
                console.log(`Carregando detalhes da prova ${examId} da API...`);
                
                // Fazer requisição para a API para obter detalhes da prova
          const url = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}`;
                console.log(`Fazendo requisição GET para: ${url}`);
                
                const response = await fetch(url, {
            method: "GET",
                    headers: {
              "Content-Type": "application/json",
            },
                });
                
                if (!response.ok) {
            const errorText = await response
              .text()
              .catch(() => "Erro desconhecido");
            console.error(
              `Erro ao carregar detalhes da prova. Status: ${response.status}, Detalhes: ${errorText}`
            );
            throw new Error(
              `Erro ao carregar detalhes da prova. Status: ${response.status}`
            );
                }
                
                const examDetails = await response.json();
          console.log("Detalhes da prova recebidos da API:", examDetails);
                
                // Se o índice local não for fornecido, buscar a prova pelo API ID
                if (localIndex === undefined || localIndex < 0) {
                    localExams = getExams();
            localIndex = localExams.findIndex((e) => e.apiId === examId);
                    
                    if (localIndex < 0) {
              console.warn(
                `Prova com API ID ${examId} não encontrada localmente.`
              );
                        return false;
                    }
                }
                
                // Atualizar TODOS os dados da prova com as informações da API
                if (examDetails) {
                    // Atualizar campos básicos - Usar explicitamente o campo 'nome' da API
                    if (examDetails.nome !== undefined) {
                        localExams[localIndex].name = examDetails.nome;
              console.log(
                `Prova atualizada com nome da API: "${examDetails.nome}"`
              );
                    } else if (examDetails.titulo !== undefined) {
                        localExams[localIndex].name = examDetails.titulo;
              console.log(
                `Prova atualizada com título da API: "${examDetails.titulo}"`
              );
            }

            localExams[localIndex].description =
              examDetails.descricao || localExams[localIndex].description;
            localExams[localIndex].educationLevel =
              examDetails.nivel_ensino || localExams[localIndex].educationLevel;
                    
                    if (examDetails.data_aplicacao) {
                        localExams[localIndex].createdAt = examDetails.data_aplicacao;
                    } else if (examDetails.createdAt) {
                        localExams[localIndex].createdAt = examDetails.createdAt;
                    }
                    
            console.log(
              `Prova local atualizada com nome: ${localExams[localIndex].name}`
            );
                }
                
                // Processar questões
                if (examDetails.questoes && Array.isArray(examDetails.questoes)) {
            console.log(
              `Recebidas ${examDetails.questoes.length} questões da API`
            );
                    
                    // Verificar se precisamos fazer uma busca separada por questões
                    if (examDetails.questoes.length > 0) {
                        // Verificar se as questões estão completas ou precisamos buscar detalhes
              const hasCompleteQuestions = examDetails.questoes[0].alternativas || 
                    (examDetails.questoes[0].alternativa_a && examDetails.questoes[0].alternativa_b);
                        
                        if (!hasCompleteQuestions) {
                    console.log("As questões não estão completas, buscando detalhes adicionais...");
                            try {
                                // Buscar todas as questões da prova usando a API dedicada
                                const questionsUrl = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/questoes-detalhadas`;
                                const questionsResponse = await fetch(questionsUrl, {
                                    method: "GET",
                                    headers: {
                                        "Content-Type": "application/json",
                                    },
                                });
                                
                                if (questionsResponse.ok) {
                                    const detailedQuestions = await questionsResponse.json();
                                    if (Array.isArray(detailedQuestions) && detailedQuestions.length > 0) {
                                        console.log(`Recebidas ${detailedQuestions.length} questões detalhadas da API`);
                                        examDetails.questoes = detailedQuestions;
                                    }
                                }
                            } catch (questError) {
                                console.error("Erro ao buscar detalhes das questões:", questError);
                                // Continuar com as questões originais mesmo em caso de erro
                            }
                        }
                    }
                    
                    // Debug: Verificar questões existentes localmente
                    if (localExams[localIndex].questions && localExams[localIndex].questions.length > 0) {
                        console.log("Questões já existentes ANTES da atualização:", 
                            JSON.stringify(localExams[localIndex].questions, null, 2));
                    }
                    
                    // Preservar opções existentes nas questões locais
                    const existingQuestions = localExams[localIndex].questions || [];

                    // Mapear as questões para o formato local
                    localExams[localIndex].questions = examDetails.questoes.map((q) => {
                        const existingQuestion = existingQuestions.find(eq => eq.apiId === q.id);
                        
                        // Obter as alternativas da API 
                        let optionsFromAPI = {};
                        
                        // Tenta obter alternativas de diferentes formatos da API
                        if (q.alternativas && Array.isArray(q.alternativas)) {
                            // Forma 1: Array de objetos com texto e correta
                            const letters = ['A', 'B', 'C', 'D', 'E'];
                            q.alternativas.forEach((alt, index) => {
                                if (index < letters.length) {
                                    optionsFromAPI[letters[index]] = alt.texto || '';
                                }
                            });
                            console.log("Alternativas obtidas do array:", optionsFromAPI);
                        } else if (q.alternativa_a || q.alternativa_b || q.alternativa_c || q.alternativa_d || q.alternativa_e) {
                            // Forma 2: Campos alternativa_a, alternativa_b, etc.
                            optionsFromAPI = {
                                A: q.alternativa_a || '',
                                B: q.alternativa_b || '',
                                C: q.alternativa_c || '',
                                D: q.alternativa_d || '',
                                E: q.alternativa_e || ''
                            };
                            console.log("Alternativas obtidas de campos separados:", optionsFromAPI);
                        }
                        
                        // Usar alternativas existentes ou da API
                        const options = (existingQuestion && existingQuestion.options && Object.values(existingQuestion.options).some(v => v !== '')) ? 
                            existingQuestion.options : 
                            optionsFromAPI;
                        
                        console.log("Alternativas finais usadas para a questão:", options);
                        
                        return {
                            id: q.id,
                            text: q.texto || q.enunciado || "Sem enunciado",
                            educationLevel: q.nivel_ensino || localExams[localIndex].educationLevel || "",
                            gradeLevel: q.serie || "",
                            difficultyLevel: q.dificuldade || "",
                            curriculumComponent: q.componente_curricular || q.disciplina || "",
                            bnccCodes: q.codigos_bncc || q.habilidades_bncc || "",
                            correctAnswer: q.resposta_correta || q.gabarito || "A",
                            options: options,
                            image: q.imagem || q.imagem_url || null,
                            apiId: q.id, // Garantir que o ID da API seja mantido
                        };
                    });
                    
                    console.log(`Exame ID ${examId} atualizado com ${localExams[localIndex].questions.length} questões da API`);
                    
                    // Debug: Verificar questões atualizadas
                    if (localExams[localIndex].questions && localExams[localIndex].questions.length > 0) {
                        console.log("Questões DEPOIS da atualização:", 
                            JSON.stringify(localExams[localIndex].questions, null, 2));
                    }
                    
                    // Atualizar o armazenamento local após carregar as questões
                    localStorage.setItem("exams", JSON.stringify(localExams));
                } else if (examDetails.questoes === null || examDetails.questoes === undefined) {
                    console.log(`Exame ID ${examId} não possui questões na API.`);
                    
                    // Tentar buscar questões especificamente
                    try {
                        const questionsUrl = `https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/questoes-detalhadas`;
                        console.log(`Buscando questões na endpoint específica: ${questionsUrl}`);
                        
                        const questionsResponse = await fetch(questionsUrl, {
                            method: "GET",
                            headers: {
                                "Content-Type": "application/json",
                            },
                        });
                        
                        if (questionsResponse.ok) {
                            const questions = await questionsResponse.json();
                            
                            if (Array.isArray(questions) && questions.length > 0) {
                                console.log(`Encontradas ${questions.length} questões na API dedicada`);
                                
                                // Preservar opções existentes nas questões locais
                                const existingQuestions = localExams[localIndex].questions || [];
                                
                                // Mapear as questões para o formato local
                                localExams[localIndex].questions = questions.map((q) => {
                                    const existingQuestion = existingQuestions.find(eq => eq.apiId === q.id);
                                    
                                    // Obter as alternativas da API 
                                    let optionsFromAPI = {};
                                    
                                    // Tenta obter alternativas de diferentes formatos da API
                                    if (q.alternativas && Array.isArray(q.alternativas)) {
                                        // Forma 1: Array de objetos com texto e correta
                                        const letters = ['A', 'B', 'C', 'D', 'E'];
                                        q.alternativas.forEach((alt, index) => {
                                            if (index < letters.length) {
                                                optionsFromAPI[letters[index]] = alt.texto || '';
                                            }
                                        });
                                    } else if (q.alternativa_a || q.alternativa_b || q.alternativa_c || q.alternativa_d || q.alternativa_e) {
                                        // Forma 2: Campos alternativa_a, alternativa_b, etc.
                                        optionsFromAPI = {
                                            A: q.alternativa_a || '',
                                            B: q.alternativa_b || '',
                                            C: q.alternativa_c || '',
                                            D: q.alternativa_d || '',
                                            E: q.alternativa_e || ''
                                        };
                                    }
                                    
                                    // Usar alternativas existentes ou da API
                                    const options = (existingQuestion && existingQuestion.options && Object.values(existingQuestion.options).some(v => v !== '')) ? 
                                        existingQuestion.options : 
                                        optionsFromAPI;
                                    
                                    return {
                                        id: q.id,
                                        text: q.texto || q.enunciado || "Sem enunciado",
                                        educationLevel: q.nivel_ensino || localExams[localIndex].educationLevel || "",
                                        gradeLevel: q.serie || "",
                                        difficultyLevel: q.dificuldade || "",
                                        curriculumComponent: q.componente_curricular || q.disciplina || "",
                                        bnccCodes: q.codigos_bncc || q.habilidades_bncc || "",
                                        correctAnswer: q.resposta_correta || q.gabarito || "A",
                                        options: options,
                                        image: q.imagem || q.imagem_url || null,
                                        apiId: q.id,
                                    };
                                });
                                
                                console.log(`Exame ID ${examId} atualizado com ${localExams[localIndex].questions.length} questões da API dedicada`);
                                
                                // Atualizar o armazenamento local após carregar as questões
                                localStorage.setItem("exams", JSON.stringify(localExams));
                            } else {
                                console.log("API de questões dedicada não retornou questões.");
                            }
                        } else {
                            console.log(`API de questões dedicada retornou erro ${questionsResponse.status}`);
                        }
                    } catch (questError) {
                        console.error("Erro ao buscar questões na API dedicada:", questError);
                    }
                }
                
                // Salvar as alterações no localStorage independentemente das questões
          localStorage.setItem("exams", JSON.stringify(localExams));
                
                return true;
            } catch (error) {
                console.error(`Erro ao carregar detalhes da prova ${examId}:`, error);
                return false;
            }
        }

        // Função para enviar prova para a API
        async function saveExamToAPI(exam) {
            try {
                // Mapear o nível de ensino - usar apenas valores válidos para a API
                let nivelEnsino = "ANOS_INICIAIS"; // Valor padrão
                if (exam.educationLevel) {
            switch (exam.educationLevel.toUpperCase()) {
                        case "FUNDAMENTAL ANOS INICIAIS":
                        case "FUNDAMENTAL I":
                        case "ANOS_INICIAIS":
                            nivelEnsino = "FUNDAMENTAL_I";
                            break;
                        case "FUNDAMENTAL ANOS FINAIS":
                        case "FUNDAMENTAL II":
                        case "ANOS_FINAIS":
                            nivelEnsino = "FUNDAMENTAL_II";
                            break;
                        case "ENSINO MÉDIO":
                        case "MÉDIO":
                        case "ENSINO_MEDIO":
                            nivelEnsino = "MEDIO";
                            break;
                        default:
                            // Caso não identifique, usar o padrão FUNDAMENTAL_I
                            nivelEnsino = "FUNDAMENTAL_I";
                    }
                }

                // Converter exame para o formato da API
                const apiExam = {
                    nome: exam.name, // CORREÇÃO: usar 'nome' em vez de 'titulo'
            descricao: exam.description || "",
                    data_aplicacao: new Date().toISOString(),
            nivel_ensino: nivelEnsino, // Adicionando o nível de ensino
                };
                
                // Para depuração
          console.log("Dados enviados para a API:", apiExam);
                
                // Verificar se há questões para adicionar
                if (exam.questions && exam.questions.length > 0) {
                    // Não enviar questões junto com a criação da prova
                    // Elas serão adicionadas depois via endpoint específico
            console.log(
              `${exam.questions.length} questões serão adicionadas após criar a prova`
            );
                }
                
          console.log(
            "Enviando exame para API usando a rota /api/provas:",
            apiExam
          );
                
          const url = "https://sag-sag.rak8a3.easypanel.host/api/provas";
                
                // Enviar para a API
                const response = await fetch(url, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(apiExam),
                });
                
                if (!response.ok) {
            const errorText = await response
              .text()
              .catch(() => "Erro desconhecido");
            console.error(
              `Erro ao salvar prova na API. Status: ${response.status}, Detalhes: ${errorText}`
            );
            throw new Error(
              `Erro ao salvar prova na API. Status: ${response.status}`
            );
                }
                
                const savedExam = await response.json();
          console.log(
            "Prova criada na API com sucesso. Resposta API:",
            savedExam
          );
                
                // Atualizar o ID da API no exame local
                exam.apiId = savedExam.id;
                
                return savedExam;
            } catch (error) {
          console.error("Erro ao salvar prova na API:", error);
                throw error; // Propagar o erro para permitir tratamento adequado pelo chamador
            }
        }

        // Função para enviar questão para a API
        async function saveQuestionToAPI(question, provaId = null) {
            try {
                // Validar se o provaId é válido
                if (!provaId) {
            console.error("Tentativa de salvar questão sem ID da prova!");
                    return question;
                }
                
          console.log(
            `Iniciando salvamento de questão para a prova ID: ${provaId}`
          );
                
                // Garantir que componente_curricular_id seja do tipo numérico
          const componente_curricular_id = parseInt(
            question.curriculumComponent,
            10
          );

          // Usar os IDs reais das habilidades BNCC selecionadas
          let codigos_bncc = [];

          // Se question.bnccCodes for um array, usá-lo diretamente
          if (Array.isArray(question.bnccCodes)) {
            codigos_bncc = question.bnccCodes;
          }
          // Se for uma string, tentar converter para array de IDs
          else if (typeof question.bnccCodes === "string") {
            // Remover espaços e dividir por vírgulas
            const bnccCodesStr = question.bnccCodes
              .split(",")
              .map((code) => code.trim());

            // Para cada código, procurar o ID correspondente no array de habilidades da API
            for (const codeStr of bnccCodesStr) {
              // Procurar a habilidade correspondente ao código
              const bnccSkill = bnccSkillsFromAPI.find(
                (skill) => skill.codigo === codeStr
              );

              if (bnccSkill && bnccSkill.id) {
                codigos_bncc.push(bnccSkill.id);
              }
            }
          }

          // Se não encontrou nenhum ID válido, usar o ID 1 como fallback (apenas para evitar erro)
          if (codigos_bncc.length === 0) {
            console.warn(
              "Nenhum código BNCC válido encontrado. Usando ID 1 como fallback."
            );
            codigos_bncc = [1];
          }

          console.log("Usando IDs BNCC:", codigos_bncc);
                
                // Obter a alternativa correta
                const correctAnswer = question.correctAnswer; // A, B, C, D ou E
                
                // Criar array de alternativas
                const alternativas = [];
                
                if (question.options) {
                    // Adicionar cada alternativa ao array (apenas se tiver texto)
                    if (question.options.A && question.options.A.trim()) {
                        alternativas.push({
                            texto: question.options.A,
                correta: correctAnswer === "A",
                        });
                    }
                    
                    if (question.options.B && question.options.B.trim()) {
                        alternativas.push({
                            texto: question.options.B,
                correta: correctAnswer === "B",
                        });
                    }
                    
                    if (question.options.C && question.options.C.trim()) {
                        alternativas.push({
                            texto: question.options.C,
                correta: correctAnswer === "C",
                        });
                    }
                    
                    if (question.options.D && question.options.D.trim()) {
                        alternativas.push({
                            texto: question.options.D,
                correta: correctAnswer === "D",
                        });
                    }
                    
                    if (question.options.E && question.options.E.trim()) {
                        alternativas.push({
                            texto: question.options.E,
                correta: correctAnswer === "E",
                        });
                    }
                }
                
                // Garantir que temos um número válido para o ID da prova
                const prova_id = parseInt(provaId, 10);
                if (isNaN(prova_id)) {
            console.error(
              `ID da prova inválido: ${provaId}. Não é possível salvar a questão.`
            );
                    return question;
                }
                
                // Construir o payload final para a API exatamente no formato solicitado
                const questionData = {
                    enunciado: question.text,
                    imagem_url: question.image || "",
                    nivel_ensino: question.educationLevel || "ANOS_INICIAIS",
                    dificuldade: question.difficultyLevel || "FACIL",
                    serie: question.gradeLevel || "PRIMEIRO_ANO",
                    pontos: 1,
                    prova_id: prova_id,
                    componente_curricular_id: componente_curricular_id,
                    codigos_bncc: codigos_bncc,
            alternativas: alternativas,
                };
                
          console.log(
            "Enviando questão para API:",
            JSON.stringify(questionData, null, 2)
          );
                
                // Enviar a requisição para o endpoint
          const baseUrl = "https://sag-sag.rak8a3.easypanel.host";
                const response = await fetch(`${baseUrl}/api/questoes`, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
                    },
            body: JSON.stringify(questionData),
                });
                
                if (!response.ok) {
            const errorText = await response
              .text()
              .catch(() => "Erro desconhecido");
            console.error(
              `Erro ao salvar questão na API. Status: ${response.status}, Detalhes: ${errorText}`
            );
                    throw new Error(`Erro ao salvar questão: ${response.status}`);
                }
                
                const savedQuestion = await response.json();
          console.log("Questão salva na API com sucesso:", savedQuestion);
                
                // Retornar a questão salva com o ID da API
                return {
                    ...question,
            apiId: savedQuestion.id,
                };
            } catch (error) {
          console.error("Erro ao salvar questão na API:", error);
                throw error;
            }
        }

        // Função para mostrar o modal de sucesso
        function showSuccessModal(title, message, callback = null) {
            // Usar a função showAlert do alert.js
        showAlert("success", title, message, 5000, callback);
        }

        // Carregaremos as habilidades BNCC e componentes curriculares da API
        // Manteremos os dados estáticos de backup caso a API falhe
        let bnccSkillsFromAPI = [];
        let curriculumComponentsFromAPI = [];
        
        // Função para carregar componentes curriculares da API
        async function loadCurriculumComponentsFromAPI() {
            try {
          const response = await fetch(
            "https://sag-sag.rak8a3.easypanel.host/api/componentes-curriculares",
            {
              method: "GET",
                    headers: {
                "Content-Type": "application/json",
              },
                    }
          );
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar componentes curriculares. Status: ${response.status}`
            );
                }
                
                const data = await response.json();
          console.log("Componentes curriculares carregados da API:", data);
                
                if (Array.isArray(data)) {
                    curriculumComponentsFromAPI = data;
                    
                    // Atualizar os selects de componentes curriculares
                    updateCurriculumComponentSelects();
                }
                
                return data;
            } catch (error) {
          console.error(
            "Erro ao carregar componentes curriculares da API:",
            error
          );
          showAlert(
            "error",
            "Erro",
            "Não foi possível carregar os componentes curriculares do servidor."
          );
                return [];
            }
        }
        
        // Função para atualizar os selects de componentes curriculares
        function updateCurriculumComponentSelects() {
            const selects = [
          document.getElementById("bnccComponent"),
          document.getElementById("bankComponent"),
          document.getElementById("curriculumComponent"),
        ];

        selects.forEach((select) => {
                if (!select) return;
                
                // Salvar a opção selecionada atual
                const currentValue = select.value;
                
                // Limpar select, mantendo apenas a primeira opção (placeholder)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Adicionar os componentes da API
          curriculumComponentsFromAPI.forEach((component) => {
            const option = document.createElement("option");
                    option.value = component.id;
                    option.textContent = component.nome;
                    select.appendChild(option);
                });
                
                // Restaurar valor selecionado se possível
                if (currentValue) {
                    for (let i = 0; i < select.options.length; i++) {
                        if (select.options[i].value === currentValue) {
                            select.selectedIndex = i;
                            break;
                        }
                    }
                }
            });
        }
        
        // Função para carregar habilidades BNCC da API com base nos filtros
        async function loadBnccSkillsFromAPI(grade, componentId) {
            try {
                // Construir URL com parâmetros de consulta
          let url = "https://sag-sag.rak8a3.easypanel.host/api/bncc";
                const params = new URLSearchParams();
                
                if (grade) {
            params.append("serie", grade);
                }
                
                if (componentId) {
            params.append("componente_curricular_id", componentId);
                }
                
                // Adicionar parâmetros se houver algum
                if (params.toString()) {
            url += "?" + params.toString();
                }
                
                console.log(`Carregando habilidades BNCC da API: ${url}`);
                
                const response = await fetch(url, {
            method: "GET",
                    headers: {
              "Content-Type": "application/json",
            },
                });
                
                if (!response.ok) {
            throw new Error(
              `Erro ao carregar habilidades BNCC. Status: ${response.status}`
            );
                }
                
                const data = await response.json();
          console.log(
            `Habilidades BNCC carregadas da API: ${data.length} registros encontrados`
          );

          // Log detalhado das primeiras 5 habilidades para depuração
          if (data.length > 0) {
            console.log("Detalhes das primeiras habilidades BNCC:");
            for (let i = 0; i < Math.min(5, data.length); i++) {
              console.log(
                `  Habilidade ${i + 1}: ID=${data[i].id}, Código=${
                  data[i].codigo
                }, Descrição=${data[i].descricao?.substring(0, 30)}...`
              );
            }
          }
                
                // Verificar se a resposta é um array
                if (Array.isArray(data)) {
                    bnccSkillsFromAPI = data;
                    return data;
                }
                
                return [];
            } catch (error) {
          console.error("Erro ao carregar habilidades BNCC da API:", error);
          showAlert(
            "error",
            "Erro",
            "Não foi possível carregar as habilidades BNCC do servidor."
          );
                return [];
            }
        }

        // Função para formatar o texto da série
        function getFormattedGradeText(value) {
            switch(value) {
                case "PRIMEIRO_ANO":
                    return "1º Ano";
                case "SEGUNDO_ANO":
                    return "2º Ano";
                case "TERCEIRO_ANO":
                    return "3º Ano";
                case "QUARTO_ANO":
                    return "4º Ano";
                case "QUINTO_ANO":
                    return "5º Ano";
                case "SEXTO_ANO":
                    return "6º Ano";
                case "SETIMO_ANO":
                    return "7º Ano";
                case "OITAVO_ANO":
                    return "8º Ano";
                case "NONO_ANO":
                    return "9º Ano";
                case "PRIMEIRA_SERIE":
                    return "1ª Série";
                case "SEGUNDA_SERIE":
                    return "2ª Série";
                case "TERCEIRA_SERIE":
                    return "3ª Série";
                default:
                    return value;
            }
        }

        // Função para atualizar uma prova local
        function updateLocalExam(exam) {
            try {
                let exams = getExams();
                const index = exams.findIndex((e) => e.id === exam.id);
                
                if (index !== -1) {
                    exams[index] = exam;
                    localStorage.setItem("exams", JSON.stringify(exams));
                    return true;
                }
                return false;
            } catch (error) {
                console.error("Erro ao atualizar prova local:", error);
                return false;
            }
        }

        // Add functions to delete exams locally and via API after the getExams function
        // Função para excluir uma prova localmente
        function removeExamLocally(id) {
            try {
                let exams = JSON.parse(localStorage.getItem('exams')) || [];
                exams = exams.filter(exam => exam.id !== id);
                localStorage.setItem('exams', JSON.stringify(exams));
                
                // Atualizar lista de provas
                renderExamsList();
                
                console.log(`Prova com ID ${id} removida localmente com sucesso`);
                return true;
            } catch (error) {
                console.error('Erro ao remover prova localmente:', error);
                return false;
            }
        }
        
        // Função para excluir uma prova via API
        async function deleteExamAPI(apiId, localId) {
            try {
                console.log(`Tentando excluir prova com API ID: ${apiId}, Local ID: ${localId}`);
                
                // Exibir indicador de progresso
                const progressIndicator = document.createElement('div');
                progressIndicator.className = 'fixed top-0 left-0 w-full bg-blue-600 text-center text-white py-2 z-50';
                progressIndicator.textContent = 'Excluindo prova...';
                document.body.appendChild(progressIndicator);
                
                const response = await fetch(`https://sag-sag.rak8a3.easypanel.host/api/provas/${apiId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                // Remover indicador de progresso
                document.body.removeChild(progressIndicator);
                
                console.log('Status da resposta de exclusão:', response.status);
                
                // Log da resposta completa para debug
                const responseText = await response.text();
                console.log('Resposta da API (exclusão):', responseText);
                
                // Tentar converter para JSON se possível
                let data;
                try {
                    if (responseText) {
                        data = JSON.parse(responseText);
                    }
                } catch (e) {
                    console.log('Resposta não é um JSON válido');
                }
                
                if (response.ok) {
                    // Excluir localmente após sucesso na API
                    removeExamLocally(localId);
                    alert('Prova excluída com sucesso!');
                    return true;
                } else {
                    const errorMessage = data ? data.message || 'Erro ao excluir prova.' : 'Erro ao excluir prova.';
                    alert(errorMessage);
                    return false;
                }
            } catch (error) {
                console.error('Erro ao excluir prova:', error);
                alert('Ocorreu um erro ao tentar excluir a prova: ' + error.message);
                return false;
            }
        }

        // Função para abrir o modal de edição de questões
        function openEditQuestionsModal(examId, apiId) {
            // Obter dados da prova
            const exams = getExams();
            const exam = exams.find(e => e.id === examId);
            
            if (!exam) {
                alert("Prova não encontrada!");
                return;
            }
            
            // Atualizar título do modal
            document.getElementById("editQuestionsExamName").textContent = exam.name;
            
            // Inicializar a UI
            document.getElementById("questionsList").innerHTML = `
                <div class="py-4 text-center text-gray-500">
                    <i class="fas fa-spinner fa-spin mr-2"></i> Carregando questões...
                </div>
            `;
            document.getElementById("questionCountDisplay").textContent = "Carregando...";
            
            // Carregar questões da API
            loadQuestionsForExam(apiId)
                .then(questions => {
                    // Atualizar contador usando optional chaining para evitar erros
                    document.getElementById("questionCountDisplay").textContent = `${questions?.length ?? 0} questões encontradas`;
                    
                    // Renderizar lista de questões
                    renderQuestionsList(questions, apiId);
                })
                .catch(error => {
                    console.error("Erro ao carregar questões:", error);
                    document.getElementById("questionsList").innerHTML = `
                        <div class="py-4 text-center text-red-500">
                            <i class="fas fa-exclamation-circle mr-2"></i> Erro ao carregar questões: ${error.message}
                        </div>
                    `;
                    document.getElementById("questionCountDisplay").textContent = "Erro ao carregar questões";
                });
            
            // Configurar abas
            setupQuestionsTabs();
            
            // Exibir o modal
            document.getElementById("editQuestionsModal").classList.remove("hidden");
            
            // Configurar formulário de nova questão
            setupNewQuestionForm(apiId);
            
            // Botão de fechar o modal
            const closeBtn = document.getElementById("closeEditQuestionsModal");
            const newCloseBtn = closeBtn.cloneNode(true);
            closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
            
            newCloseBtn.addEventListener("click", function() {
                document.getElementById("editQuestionsModal").classList.add("hidden");
            });
        }

        // Função para carregar questões de uma prova
        async function loadQuestionsForExam(examId) {
            try {
                console.log(`Carregando questões da prova ID: ${examId}`);
                
                const response = await fetch(`https://sag-sag.rak8a3.easypanel.host/api/provas/${examId}/questoes-detalhadas`, {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => "Erro desconhecido");
                    throw new Error(`Erro ao carregar questões. Status: ${response.status}. Detalhes: ${errorText}`);
                }
                
                const data = await response.json();
                
                // Validar se data.questoes existe e é um array
                if (!data.questoes || !Array.isArray(data.questoes)) {
                    console.error("Resposta da API não contém um array de questões válido:", data);
                    return [];
                }
                
                console.log(`Recebidas ${data.questoes?.length ?? 0} questões da API:`, data.questoes);
                return data.questoes;
            } catch (error) {
                console.error("Erro ao carregar questões da API:", error);
                throw error;
            }
        }

        // Função para renderizar a lista de questões
        function renderQuestionsList(questions, examId) {
            const questionsList = document.getElementById("questionsList");
            
            // Validar se questions é um array
            if (!questions || !Array.isArray(questions) || questions.length === 0) {
                questionsList.innerHTML = `
                    <div class="py-4 text-center text-gray-500">
                        Nenhuma questão encontrada para esta prova.
                    </div>
                `;
                return;
            }
            
            // Limpar lista
            questionsList.innerHTML = "";
            
            // Adicionar cada questão à lista
            questions.forEach((question, index) => {
                const questionItem = document.createElement("div");
                questionItem.className = "py-4";
                
                // Limitar texto para exibição
                const truncatedText = question.enunciado || "Sem texto";
                const displayText = truncatedText.length > 100 
                    ? truncatedText.substring(0, 100) + "..." 
                    : truncatedText;
                
                // Determinar alternativa correta
                let correctAnswer = "";
                if (question.alternativas && Array.isArray(question.alternativas)) {
                    const correctAlt = question.alternativas.find(alt => alt.correta);
                    if (correctAlt) {
                        // Determinar a letra da alternativa correta
                        const index = question.alternativas.indexOf(correctAlt);
                        if (index !== -1) {
                            correctAnswer = ['A', 'B', 'C', 'D', 'E'][index] || "";
                        }
                    }
                } else {
                    correctAnswer = question.resposta_correta || "";
                }
                
                // Componente curricular
                let componentName = "";
                if (question.componente_curricular_id) {
                    const component = curriculumComponentsFromAPI.find(c => c.id === question.componente_curricular_id);
                    componentName = component ? component.nome : "";
                }
                
                // Layout da questão
                questionItem.innerHTML = `
                    <div class="flex justify-between">
                        <div class="flex-grow">
                            <p class="text-sm font-medium">${index + 1}. ${displayText}</p>
                            <div class="mt-1 flex items-center text-xs text-gray-500">
                                ${componentName ? `<span class="mr-2 px-2 py-0.5 bg-blue-100 text-blue-800 rounded">${componentName}</span>` : ''}
                                ${question.dificuldade ? `<span class="mr-2">${question.dificuldade}</span>` : ''}
                                ${correctAnswer ? `<span class="px-2 py-0.5 bg-green-100 text-green-800 rounded">Resposta: ${correctAnswer}</span>` : ''}
                            </div>
                        </div>
                        <div class="flex items-start ml-4">
                            <button class="text-indigo-600 hover:text-indigo-900 edit-question-btn" 
                                    data-question-id="${question.id}" 
                                    data-exam-id="${examId}">
                                <i class="fas fa-edit"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                questionsList.appendChild(questionItem);
            });
            
            // Adicionar event listeners aos botões de edição
            document.querySelectorAll(".edit-question-btn").forEach(button => {
                button.addEventListener("click", function() {
                    const questionId = this.getAttribute("data-question-id");
                    const examId = this.getAttribute("data-exam-id");
                    openEditQuestionModal(questionId, examId);
                });
            });
        }

        // Função para configurar as abas do modal de questões
        function setupQuestionsTabs() {
            const questionsTab = document.getElementById("questionsTab");
            const addQuestionTab = document.getElementById("addQuestionTab");
            const questionsTabBtn = document.getElementById("questionsTabBtn");
            const addQuestionTabBtn = document.getElementById("addQuestionTabBtn");
            
            // Remover event listeners anteriores
            const newQuestionsTabBtn = questionsTabBtn.cloneNode(true);
            questionsTabBtn.parentNode.replaceChild(newQuestionsTabBtn, questionsTabBtn);
            
            const newAddQuestionTabBtn = addQuestionTabBtn.cloneNode(true);
            addQuestionTabBtn.parentNode.replaceChild(newAddQuestionTabBtn, addQuestionTabBtn);
            
            // Adicionar event listeners
            newQuestionsTabBtn.addEventListener("click", function() {
                // Ativar aba de questões
                questionsTab.classList.remove("hidden");
                addQuestionTab.classList.add("hidden");
                
                // Atualizar estilos dos botões
                newQuestionsTabBtn.classList.add("border-b-2", "border-blue-500", "text-blue-600");
                newQuestionsTabBtn.classList.remove("text-gray-500");
                
                newAddQuestionTabBtn.classList.remove("border-b-2", "border-blue-500", "text-blue-600");
                newAddQuestionTabBtn.classList.add("text-gray-500");
            });
            
            newAddQuestionTabBtn.addEventListener("click", function() {
                // Ativar aba de adicionar questão
                questionsTab.classList.add("hidden");
                addQuestionTab.classList.remove("hidden");
                
                // Atualizar estilos dos botões
                newQuestionsTabBtn.classList.remove("border-b-2", "border-blue-500", "text-blue-600");
                newQuestionsTabBtn.classList.add("text-gray-500");
                
                newAddQuestionTabBtn.classList.add("border-b-2", "border-blue-500", "text-blue-600");
                newAddQuestionTabBtn.classList.remove("text-gray-500");
            });
            
            // Botão de cancelar
            const cancelBtn = document.getElementById("cancelAddNewQuestionBtn");
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            newCancelBtn.addEventListener("click", function() {
                // Voltar para a aba de questões
                newQuestionsTabBtn.click();
            });
        }

        // Função para configurar o formulário de nova questão
        function setupNewQuestionForm(examId) {
            const newQuestionForm = document.getElementById("newQuestionForm");
            
            // Limpar qualquer event listener anterior
            const newForm = newQuestionForm.cloneNode(true);
            newQuestionForm.parentNode.replaceChild(newForm, newQuestionForm);
            
            // Configurar o preview de imagem
            const newQuestionImage = document.getElementById("newQuestionImage");
            const imagePreview = newForm.querySelector(".image-preview");
            const previewImg = imagePreview.querySelector("img");
            const removeImageBtn = imagePreview.querySelector(".remove-image");
            
            newQuestionImage.addEventListener("change", function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    previewImg.src = event.target.result;
                    imagePreview.classList.remove("hidden");
                };
                reader.readAsDataURL(file);
            });
            
            removeImageBtn.addEventListener("click", function() {
                newQuestionImage.value = "";
                imagePreview.classList.add("hidden");
                previewImg.src = "";
            });
            
            // Configurar submissão do formulário
            newForm.addEventListener("submit", async function(e) {
                e.preventDefault();
                
                try {
                    const questionText = document.getElementById("newQuestionText").value;
                    const educationLevel = document.getElementById("newEducationLevel").value;
                    const gradeLevel = document.getElementById("newGradeLevel").value;
                    const difficultyLevel = document.getElementById("newDifficultyLevel").value;
                    const curriculumComponent = document.getElementById("newCurriculumComponent").value;
                    
                    // Obter alternativa correta
                    const correctAnswer = document.querySelector('input[name="newCorrectAnswer"]:checked').value;
                    
                    // Montar alternativas
                    const alternativas = [];
                    
                    const optionA = document.getElementById("newOptionA").value;
                    if (optionA) {
                        alternativas.push({
                            texto: optionA,
                            correta: correctAnswer === "A"
                        });
                    }
                    
                    const optionB = document.getElementById("newOptionB").value;
                    if (optionB) {
                        alternativas.push({
                            texto: optionB,
                            correta: correctAnswer === "B"
                        });
                    }
                    
                    const optionC = document.getElementById("newOptionC").value;
                    if (optionC) {
                        alternativas.push({
                            texto: optionC,
                            correta: correctAnswer === "C"
                        });
                    }
                    
                    const optionD = document.getElementById("newOptionD").value;
                    if (optionD) {
                        alternativas.push({
                            texto: optionD,
                            correta: correctAnswer === "D"
                        });
                    }
                    
                    const optionE = document.getElementById("newOptionE").value;
                    if (optionE) {
                        alternativas.push({
                            texto: optionE,
                            correta: correctAnswer === "E"
                        });
                    }
                    
                    // Criar objeto da questão
                    const questionData = {
                        enunciado: questionText,
                        imagem_url: document.getElementById("newQuestionImage").value || "",
                        nivel_ensino: educationLevel || "ANOS_INICIAIS",
                        dificuldade: difficultyLevel || "FACIL",
                        serie: gradeLevel || "PRIMEIRO_ANO",
                        pontos: 1, // Valor padrão
                        prova_id: parseInt(examId),
                        componente_curricular_id: parseInt(curriculumComponent) || 0,
                        codigos_bncc: [], // Array vazio ou integre com a seleção de códigos BNCC se existir
                        alternativas: alternativas
                    };
                    
                    // Enviar para a API
                    const response = await fetch("https://sag-sag.rak8a3.easypanel.host/api/questoes", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify(questionData)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => "Erro desconhecido");
                        throw new Error(`Erro ao salvar questão. Status: ${response.status}. Detalhes: ${errorText}`);
                    }
                    
                    const savedQuestion = await response.json();
                    console.log("Questão salva com sucesso:", savedQuestion);
                    
                    // Limpar formulário
                    newForm.reset();
                    imagePreview.classList.add("hidden");
                    previewImg.src = "";
                    
                    // Voltar para a lista de questões e recarregar
                    document.getElementById("questionsTabBtn").click();
                    loadQuestionsForExam(examId)
                        .then(questions => {
                            document.getElementById("questionCountDisplay").textContent = `${questions.length} questões encontradas`;
                            renderQuestionsList(questions, examId);
                        });
                    
                    // Mostrar mensagem de sucesso
                    alert("Questão adicionada com sucesso!");
                    
                } catch (error) {
                    console.error("Erro ao salvar nova questão:", error);
                    alert(`Erro ao salvar questão: ${error.message}`);
                }
            });
        }

        // Função para abrir o modal de edição de uma questão específica
        async function openEditQuestionModal(questionId, examId) {
            try {
                // Mostrar indicador de carregamento
                document.getElementById("editQuestionText").value = "Carregando...";
                document.getElementById("editQuestionId").value = questionId;
                document.getElementById("editQuestionNumber").textContent = `#${questionId}`;
                
                // Exibir o modal
                document.getElementById("editQuestionModal").classList.remove("hidden");
                
                // Carregar dados da questão
                const question = await loadQuestionDetails(questionId);
                
                // Preencher formulário com dados da questão
                document.getElementById("editQuestionText").value = question.enunciado || "";
                
                // Preencher imagem se existir
                const imagePreview = document.getElementById("editImagePreview");
                const previewImg = imagePreview.querySelector("img");
                
                if (question.imagem_url) {
                    previewImg.src = question.imagem_url;
                    imagePreview.classList.remove("hidden");
                } else {
                    imagePreview.classList.add("hidden");
                }
                
                // Preencher metadados
                if (question.nivel_ensino) {
                    document.getElementById("editEducationLevel").value = question.nivel_ensino;
                }
                
                if (question.serie) {
                    document.getElementById("editGradeLevel").value = question.serie;
                }
                
                if (question.dificuldade) {
                    document.getElementById("editDifficultyLevel").value = question.dificuldade;
                }
                
                if (question.componente_curricular_id) {
                    document.getElementById("editCurriculumComponent").value = question.componente_curricular_id;
                }
                
                // Preencher alternativas e marcar a correta
                let correctAnswer = "";
                
                // Verificar se alternativas estão em um array
                if (question.alternativas && Array.isArray(question.alternativas)) {
                    // Limpar campos primeiro
                    document.getElementById("editOptionA").value = "";
                    document.getElementById("editOptionB").value = "";
                    document.getElementById("editOptionC").value = "";
                    document.getElementById("editOptionD").value = "";
                    document.getElementById("editOptionE").value = "";
                    
                    // Preencher alternativas disponíveis
                    const letters = ['A', 'B', 'C', 'D', 'E'];
                    
                    question.alternativas.forEach((alt, index) => {
                        if (index < letters.length) {
                            const letter = letters[index];
                            document.getElementById(`editOption${letter}`).value = alt.texto || "";
                            
                            if (alt.correta) {
                                correctAnswer = letter;
                                document.querySelector(`input[name="editCorrectAnswer"][value="${letter}"]`).checked = true;
                            }
                        }
                    });
                } 
                // Tentar outro formato de dados (alternativa_a, alternativa_b, etc.)
                else {
                    if (question.alternativa_a) document.getElementById("editOptionA").value = question.alternativa_a;
                    if (question.alternativa_b) document.getElementById("editOptionB").value = question.alternativa_b;
                    if (question.alternativa_c) document.getElementById("editOptionC").value = question.alternativa_c;
                    if (question.alternativa_d) document.getElementById("editOptionD").value = question.alternativa_d;
                    if (question.alternativa_e) document.getElementById("editOptionE").value = question.alternativa_e;
                    
                    if (question.resposta_correta) {
                        correctAnswer = question.resposta_correta;
                        const radioBtn = document.querySelector(`input[name="editCorrectAnswer"][value="${correctAnswer}"]`);
                        if (radioBtn) radioBtn.checked = true;
                    }
                }
                
                // Configurar botões
                setupEditQuestionButtons(questionId, examId);
                
            } catch (error) {
                console.error(`Erro ao carregar questão #${questionId}:`, error);
                alert(`Erro ao carregar detalhes da questão: ${error.message}`);
                document.getElementById("editQuestionModal").classList.add("hidden");
            }
        }

        // Função para carregar detalhes de uma questão específica
        async function loadQuestionDetails(questionId) {
            try {
                console.log(`Carregando detalhes da questão ID: ${questionId}`);
                
                const response = await fetch(`https://sag-sag.rak8a3.easypanel.host/api/questoes/${questionId}`, {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => "Erro desconhecido");
                    throw new Error(`Erro ao carregar detalhes da questão. Status: ${response.status}. Detalhes: ${errorText}`);
                }
                
                const question = await response.json();
                console.log("Detalhes da questão recebidos:", question);
                
                return question;
            } catch (error) {
                console.error("Erro ao carregar detalhes da questão:", error);
                throw error;
            }
        }

        // Função para configurar botões do modal de edição de questão
        function setupEditQuestionButtons(questionId, examId) {
            // Botão de fechar o modal
            const closeBtn = document.getElementById("closeEditQuestionModal");
            const cancelBtn = document.getElementById("cancelEditQuestionBtn");
            const deleteBtn = document.getElementById("deleteQuestionBtn");
            const editForm = document.getElementById("editQuestionForm");
            
            // Remover event listeners anteriores
            const newCloseBtn = closeBtn.cloneNode(true);
            closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
            
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            const newDeleteBtn = deleteBtn.cloneNode(true);
            deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
            
            const newEditForm = editForm.cloneNode(true);
            editForm.parentNode.replaceChild(newEditForm, editForm);
            
            // Adicionar event listeners
            newCloseBtn.addEventListener("click", function() {
                document.getElementById("editQuestionModal").classList.add("hidden");
            });
            
            newCancelBtn.addEventListener("click", function() {
                document.getElementById("editQuestionModal").classList.add("hidden");
            });
            
                                    // Configuração do botão de exclusão removida
            
            // Configurar submissão do formulário
            newEditForm.addEventListener("submit", function(e) {
                e.preventDefault();
                updateQuestion(questionId, examId);
            });
            
            // Configurar manipulação de imagem
            const editQuestionImage = document.getElementById("editQuestionImage");
            const imagePreview = document.getElementById("editImagePreview");
            const previewImg = imagePreview.querySelector("img");
            const removeImageBtn = document.getElementById("removeEditImage");
            
            editQuestionImage.addEventListener("change", function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    previewImg.src = event.target.result;
                    imagePreview.classList.remove("hidden");
                };
                reader.readAsDataURL(file);
            });
            
            removeImageBtn.addEventListener("click", function() {
                editQuestionImage.value = "";
                imagePreview.classList.add("hidden");
                previewImg.src = "";
            });
        }

        // Função para atualizar uma questão
        async function updateQuestion(questionId, examId) {
            try {
                const questionText = document.getElementById("editQuestionText").value;
                const educationLevel = document.getElementById("editEducationLevel").value;
                const gradeLevel = document.getElementById("editGradeLevel").value;
                const difficultyLevel = document.getElementById("editDifficultyLevel").value;
                const curriculumComponent = document.getElementById("editCurriculumComponent").value;
                
                // Verificar se há alternativa correta selecionada
                const correctAnswerElement = document.querySelector('input[name="editCorrectAnswer"]:checked');
                if (!correctAnswerElement) {
                    alert("Por favor, selecione a alternativa correta.");
                    return;
                }
                const correctAnswer = correctAnswerElement.value;
                
                // Montar alternativas
                const alternativas = [];
                
                const optionA = document.getElementById("editOptionA").value;
                if (optionA) {
                    alternativas.push({
                        texto: optionA,
                        correta: correctAnswer === "A"
                    });
                }
                
                const optionB = document.getElementById("editOptionB").value;
                if (optionB) {
                    alternativas.push({
                        texto: optionB,
                        correta: correctAnswer === "B"
                    });
                }
                
                const optionC = document.getElementById("editOptionC").value;
                if (optionC) {
                    alternativas.push({
                        texto: optionC,
                        correta: correctAnswer === "C"
                    });
                }
                
                const optionD = document.getElementById("editOptionD").value;
                if (optionD) {
                    alternativas.push({
                        texto: optionD,
                        correta: correctAnswer === "D"
                    });
                }
                
                const optionE = document.getElementById("editOptionE").value;
                if (optionE) {
                    alternativas.push({
                        texto: optionE,
                        correta: correctAnswer === "E"
                    });
                }
                
                // Validar se temos pelo menos duas alternativas
                if (alternativas.length < 2) {
                    alert("Por favor, adicione pelo menos duas alternativas.");
                    return;
                }
                
                // Validar se há exatamente uma alternativa correta
                const correctCount = alternativas.filter(alt => alt.correta).length;
                if (correctCount !== 1) {
                    alert("Deve haver exatamente uma alternativa correta.");
                    return;
                }
                
                // Criar objeto da questão
                const questionData = {
                    enunciado: questionText,
                    imagem_url: document.getElementById("editQuestionImage").value || "",
                    nivel_ensino: educationLevel || "ANOS_INICIAIS",
                    dificuldade: difficultyLevel || "FACIL",
                    serie: gradeLevel || "PRIMEIRO_ANO",
                    pontos: 1, // Valor padrão
                    prova_id: parseInt(examId),
                    componente_curricular_id: curriculumComponent ? parseInt(curriculumComponent) : 0,
                    codigos_bncc: [], // Array vazio ou integre com a seleção de códigos BNCC se existir
                    alternativas: alternativas
                };
                
                console.log("Enviando atualização de questão:", questionData);
                
                // Enviar para a API
                const response = await fetch(`https://sag-sag.rak8a3.easypanel.host/api/questoes/${questionId}`, {
                    method: "PUT",
                    headers: {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },
                    body: JSON.stringify(questionData)
                });
                
                if (!response.ok) {
                    let errorText;
                    try {
                        // Tentar obter detalhes do erro como JSON
                        const errorJson = await response.json();
                        errorText = JSON.stringify(errorJson);
                    } catch {
                        errorText = await response.text().catch(() => "Erro desconhecido");
                    }
                    throw new Error(`Erro ao atualizar questão. Status: ${response.status}. Detalhes: ${errorText}`);
                }
                
                const updatedQuestion = await response.json();
                console.log("Questão atualizada com sucesso:", updatedQuestion);
                
                // Fechar o modal
                document.getElementById("editQuestionModal").classList.add("hidden");
                
                // Recarregar questões
                loadQuestionsForExam(examId)
                    .then(questions => {
                        document.getElementById("questionCountDisplay").textContent = `${questions?.length ?? 0} questões encontradas`;
                        renderQuestionsList(questions, examId);
                    });
                
                // Mostrar mensagem de sucesso
                alert("Questão atualizada com sucesso!");
                
            } catch (error) {
                console.error("Erro ao atualizar questão:", error);
                alert(`Erro ao atualizar questão: ${error.message}`);
            }
        }

                        // Função para excluir uma questão - removida        async function deleteQuestion(questionId, examId) {            // Esta função foi desativada            console.log("Função de exclusão de questão foi desativada");            alert("A funcionalidade de exclusão de questões foi desativada.");            return false;        }
    </script>
    
    <!-- Edit Questions Modal -->
    <div id="editQuestionsModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto">
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-4xl mx-auto my-4 modal-overflow flex flex-col" style="max-height: 90vh">
            <div class="flex items-center justify-between mb-4 border-b pb-4">
                <h3 class="text-lg font-medium text-gray-900">Editar Questões da Prova: <span id="editQuestionsExamName">Carregando...</span></h3>
                <button id="closeEditQuestionsModal" class="text-gray-400 hover:text-gray-500">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div class="flex-grow overflow-y-auto">
                <!-- Navigation tabs -->
                <div class="flex border-b mb-4">
                    <div id="questionsTabBtn" class="cursor-pointer py-2 px-4 border-b-2 border-blue-500 text-blue-600 font-medium">Questões</div>
                    <div id="addQuestionTabBtn" class="cursor-pointer py-2 px-4 text-gray-500 hover:text-gray-700">Adicionar Questão</div>
                </div>
                
                <!-- Questions list -->
                <div id="questionsTab" class="space-y-4">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-md font-medium">Lista de Questões</h4>
                        <p id="questionCountDisplay" class="text-sm text-gray-500">Carregando questões...</p>
                    </div>
                    
                    <div id="questionsList" class="divide-y divide-gray-200">
                        <!-- Questões serão carregadas aqui dinamicamente -->
                        <div class="py-4 text-center text-gray-500">
                            <i class="fas fa-spinner fa-spin mr-2"></i> Carregando questões...
                        </div>
                    </div>
                </div>
                
                <!-- Add Question Tab (initially hidden) -->
                <div id="addQuestionTab" class="hidden">
                    <form id="newQuestionForm" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Enunciado</label>
                            <textarea id="newQuestionText" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" rows="3" required></textarea>
                        </div>
                        
                        <!-- Imagem da questão -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Imagem (opcional)</label>
                            <div class="mt-1 flex items-center">
                                <input type="file" accept="image/*" id="newQuestionImage" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                            </div>
                            <div class="mt-2 image-preview hidden">
                                <img src="" alt="Preview" class="max-h-48 rounded" />
                                <button type="button" class="remove-image mt-1 text-xs text-red-600 hover:text-red-900">
                                    <i class="fas fa-times mr-1"></i> Remover imagem
                                </button>
                            </div>
                        </div>
                        
                        <!-- Metadados da questão -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50 rounded-md">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Nível de ensino</label>
                                <select id="newEducationLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                    <option value="">Selecione</option>
                                    <option value="ANOS_INICIAIS">Anos Iniciais</option>
                                    <option value="ANOS_FINAIS">Anos Finais</option>
                                    <option value="ENSINO_MEDIO">Ensino Médio</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Série</label>
                                <select id="newGradeLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                    <option value="">Selecione</option>
                                    <option value="PRIMEIRO_ANO">1º Ano</option>
                                    <option value="SEGUNDO_ANO">2º Ano</option>
                                    <option value="TERCEIRO_ANO">3º Ano</option>
                                    <option value="QUARTO_ANO">4º Ano</option>
                                    <option value="QUINTO_ANO">5º Ano</option>
                                    <option value="SEXTO_ANO">6º Ano</option>
                                    <option value="SETIMO_ANO">7º Ano</option>
                                    <option value="OITAVO_ANO">8º Ano</option>
                                    <option value="NONO_ANO">9º Ano</option>
                                    <option value="PRIMEIRA_SERIE">1ª Série</option>
                                    <option value="SEGUNDA_SERIE">2ª Série</option>
                                    <option value="TERCEIRA_SERIE">3ª Série</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Dificuldade</label>
                                <select id="newDifficultyLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                    <option value="">Selecione</option>
                                    <option value="FACIL">Fácil</option>
                                    <option value="MEDIO">Médio</option>
                                    <option value="DIFICIL">Difícil</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Componente curricular</label>
                                <select id="newCurriculumComponent" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                    <option value="">Selecione</option>
                                    <option value="1">Língua Portuguesa</option>
                                    <option value="2">Matemática</option>
                                    <option value="3">Ciências</option>
                                    <option value="4">História</option>
                                    <option value="5">Geografia</option>
                                    <option value="6">Educação Física</option>
                                    <option value="7">Arte</option>
                                    <option value="8">Inglês</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Alternativas -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Alternativas</label>
                            <div class="space-y-3">
                                <div class="flex items-center mt-1">
                                    <input type="radio" name="newCorrectAnswer" value="A" class="mr-2" required />
                                    <span class="font-medium w-8">A)</span>
                                    <input type="text" id="newOptionA" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa A" required />
                                </div>
                                <div class="flex items-center mt-1">
                                    <input type="radio" name="newCorrectAnswer" value="B" class="mr-2" />
                                    <span class="font-medium w-8">B)</span>
                                    <input type="text" id="newOptionB" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa B" required />
                                </div>
                                <div class="flex items-center mt-1">
                                    <input type="radio" name="newCorrectAnswer" value="C" class="mr-2" />
                                    <span class="font-medium w-8">C)</span>
                                    <input type="text" id="newOptionC" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa C" required />
                                </div>
                                <div class="flex items-center mt-1">
                                    <input type="radio" name="newCorrectAnswer" value="D" class="mr-2" />
                                    <span class="font-medium w-8">D)</span>
                                    <input type="text" id="newOptionD" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa D" required />
                                </div>
                                <div class="flex items-center mt-1">
                                    <input type="radio" name="newCorrectAnswer" value="E" class="mr-2" />
                                    <span class="font-medium w-8">E)</span>
                                    <input type="text" id="newOptionE" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa E" required />
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex justify-end space-x-2">
                            <button type="button" id="cancelAddNewQuestionBtn" class="bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                                Cancelar
                            </button>
                            <button type="submit" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                                Adicionar Questão
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Edit Question Modal -->
    <div id="editQuestionModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden p-4 overflow-auto">
        <div class="bg-white rounded-lg p-4 sm:p-6 w-full max-w-3xl mx-auto my-4 modal-overflow">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-medium text-gray-900">Editar Questão <span id="editQuestionNumber"></span></h3>
                <button id="closeEditQuestionModal" class="text-gray-400 hover:text-gray-500">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="editQuestionForm" class="space-y-4">
                <input type="hidden" id="editQuestionId" />
                <div>
                    <label class="block text-sm font-medium text-gray-700">Enunciado</label>
                    <textarea id="editQuestionText" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" rows="3" required></textarea>
                </div>
                
                <!-- Imagem da questão -->
                <div>
                    <label class="block text-sm font-medium text-gray-700">Imagem (opcional)</label>
                    <div class="mt-1 flex items-center">
                        <input type="file" accept="image/*" id="editQuestionImage" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                    </div>
                    <div id="editImagePreview" class="mt-2 hidden">
                        <img src="" alt="Preview" class="max-h-48 rounded" />
                        <button type="button" id="removeEditImage" class="mt-1 text-xs text-red-600 hover:text-red-900">
                            <i class="fas fa-times mr-1"></i> Remover imagem
                        </button>
                    </div>
                </div>
                
                <!-- Metadados da questão -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-gray-50 rounded-md">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Nível de ensino</label>
                        <select id="editEducationLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="">Selecione</option>
                            <option value="ANOS_INICIAIS">Anos Iniciais</option>
                            <option value="ANOS_FINAIS">Anos Finais</option>
                            <option value="ENSINO_MEDIO">Ensino Médio</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Série</label>
                        <select id="editGradeLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="">Selecione</option>
                            <option value="PRIMEIRO_ANO">1º Ano</option>
                            <option value="SEGUNDO_ANO">2º Ano</option>
                            <option value="TERCEIRO_ANO">3º Ano</option>
                            <option value="QUARTO_ANO">4º Ano</option>
                            <option value="QUINTO_ANO">5º Ano</option>
                            <option value="SEXTO_ANO">6º Ano</option>
                            <option value="SETIMO_ANO">7º Ano</option>
                            <option value="OITAVO_ANO">8º Ano</option>
                            <option value="NONO_ANO">9º Ano</option>
                            <option value="PRIMEIRA_SERIE">1ª Série</option>
                            <option value="SEGUNDA_SERIE">2ª Série</option>
                            <option value="TERCEIRA_SERIE">3ª Série</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Dificuldade</label>
                        <select id="editDifficultyLevel" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="">Selecione</option>
                            <option value="FACIL">Fácil</option>
                            <option value="MEDIO">Médio</option>
                            <option value="DIFICIL">Difícil</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Componente curricular</label>
                        <select id="editCurriculumComponent" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="">Selecione</option>
                            <option value="1">Língua Portuguesa</option>
                            <option value="2">Matemática</option>
                            <option value="3">Ciências</option>
                            <option value="4">História</option>
                            <option value="5">Geografia</option>
                            <option value="6">Educação Física</option>
                            <option value="7">Arte</option>
                            <option value="8">Inglês</option>
                        </select>
                    </div>
                </div>
                
                <!-- Alternativas -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Alternativas</label>
                    <div class="space-y-3">
                        <div class="flex items-center mt-1">
                            <input type="radio" name="editCorrectAnswer" value="A" class="mr-2" required />
                            <span class="font-medium w-8">A)</span>
                            <input type="text" id="editOptionA" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa A" required />
                        </div>
                        <div class="flex items-center mt-1">
                            <input type="radio" name="editCorrectAnswer" value="B" class="mr-2" />
                            <span class="font-medium w-8">B)</span>
                            <input type="text" id="editOptionB" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa B" required />
                        </div>
                        <div class="flex items-center mt-1">
                            <input type="radio" name="editCorrectAnswer" value="C" class="mr-2" />
                            <span class="font-medium w-8">C)</span>
                            <input type="text" id="editOptionC" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa C" required />
                        </div>
                        <div class="flex items-center mt-1">
                            <input type="radio" name="editCorrectAnswer" value="D" class="mr-2" />
                            <span class="font-medium w-8">D)</span>
                            <input type="text" id="editOptionD" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa D" required />
                        </div>
                        <div class="flex items-center mt-1">
                            <input type="radio" name="editCorrectAnswer" value="E" class="mr-2" />
                            <span class="font-medium w-8">E)</span>
                            <input type="text" id="editOptionE" class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="Alternativa E" required />
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-end space-x-2">
                                                            <!-- Botão de exclusão removido -->
                    <button type="button" id="cancelEditQuestionBtn" class="bg-gray-200 px-4 py-2 text-sm font-medium text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">
                        Cancelar
                    </button>
                    <button type="submit" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                        Salvar Alterações
                    </button>
                </div>
            </form>
        </div>
    </div>
</body>
</html> 